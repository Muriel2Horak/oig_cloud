const INVERTER_SN = new URLSearchParams(window.location.search).get('inverter_sn') || '2206237016';

// === LAYOUT CUSTOMIZATION SYSTEM ===
let editMode = false;
let currentBreakpoint = null;
let draggedNode = null;
let dragStartX = 0;
let dragStartY = 0;
let dragStartTop = 0;
let dragStartLeft = 0;

// Detekce viewportu
function getCurrentBreakpoint() {
    const width = window.innerWidth;
    if (width <= 768) return 'mobile';
    if (width <= 1024) return 'tablet';
    return 'desktop';
}

// Ulo≈æen√≠ layoutu pro aktu√°ln√≠ breakpoint
function saveLayout(breakpoint, positions) {
    const key = `oig-layout-${breakpoint}`;
    localStorage.setItem(key, JSON.stringify(positions));
    console.log(`[Layout] Saved ${breakpoint} layout:`, positions);
}

// Naƒçten√≠ layoutu pro aktu√°ln√≠ breakpoint
function loadLayout(breakpoint) {
    const key = `oig-layout-${breakpoint}`;
    const saved = localStorage.getItem(key);

    if (saved) {
        try {
            const positions = JSON.parse(saved);
            console.log(`[Layout] Loading ${breakpoint} layout:`, positions);
            applyCustomPositions(positions);
            return true;
        } catch (e) {
            console.error(`[Layout] Failed to parse ${breakpoint} layout:`, e);
            return false;
        }
    }
    return false;
}

// Aplikace custom pozic
function applyCustomPositions(positions) {
    const nodes = ['solar', 'grid-node', 'battery', 'house', 'inverter'];

    nodes.forEach(nodeClass => {
        const node = document.querySelector(`.${nodeClass}`);
        if (!node || !positions[nodeClass]) return;

        const pos = positions[nodeClass];

        // Aplikovat pozice
        if (pos.top !== undefined) node.style.top = pos.top;
        if (pos.left !== undefined) node.style.left = pos.left;
        if (pos.right !== undefined) node.style.right = pos.right;
        if (pos.bottom !== undefined) node.style.bottom = pos.bottom;
        if (pos.transform !== undefined) node.style.transform = pos.transform;
    });

    // Invalidovat cache a p≈ôepoƒç√≠tat ƒç√°ry a ƒç√°stice
    invalidateNodeCentersCache();
    if (typeof drawConnections === 'function') {
        drawConnections();
    }
    if (typeof updateAllParticleFlows === 'function') {
        updateAllParticleFlows();
    }
}

// Reset layoutu pro aktu√°ln√≠ breakpoint
function resetLayout(breakpoint) {
    const key = `oig-layout-${breakpoint}`;
    localStorage.removeItem(key);
    console.log(`[Layout] Reset ${breakpoint} layout`);

    // Odstranit inline styles a vr√°tit k CSS variables
    const nodes = document.querySelectorAll('.solar, .grid-node, .battery, .house, .inverter');
    nodes.forEach(node => {
        node.style.top = '';
        node.style.left = '';
        node.style.right = '';
        node.style.bottom = '';
        node.style.transform = '';
    });

    // Invalidovat cache a p≈ôepoƒç√≠tat ƒç√°ry a ƒç√°stice
    invalidateNodeCentersCache();
    if (typeof drawConnections === 'function') {
        drawConnections();
    }
    if (typeof updateAllParticleFlows === 'function') {
        updateAllParticleFlows();
    }
}

// Toggle edit mode
function toggleEditMode() {
    editMode = !editMode;
    const canvas = document.querySelector('.flow-canvas');
    const btn = document.getElementById('edit-layout-btn');

    if (editMode) {
        canvas.classList.add('edit-mode');
        if (btn) btn.classList.add('active');
        console.log('[Layout] Edit mode enabled');
        initializeDragAndDrop();
    } else {
        canvas.classList.remove('edit-mode');
        if (btn) btn.classList.remove('active');
        console.log('[Layout] Edit mode disabled');
    }
}

// Inicializace drag & drop
function initializeDragAndDrop() {
    const nodes = document.querySelectorAll('.solar, .grid-node, .battery, .house, .inverter');

    nodes.forEach(node => {
        // Mouse events
        node.addEventListener('mousedown', handleDragStart);

        // Touch events
        node.addEventListener('touchstart', handleTouchStart, { passive: false });
    });

    // Global handlers
    document.addEventListener('mousemove', handleDragMove);
    document.addEventListener('mouseup', handleDragEnd);
    document.addEventListener('touchmove', handleTouchMove, { passive: false });
    document.addEventListener('touchend', handleTouchEnd);
}

// Mouse drag handlers
function handleDragStart(e) {
    if (!editMode) return;

    e.preventDefault();
    draggedNode = e.target.closest('.node');
    if (!draggedNode) return;

    draggedNode.classList.add('dragging');

    const rect = draggedNode.getBoundingClientRect();
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    dragStartTop = rect.top;
    dragStartLeft = rect.left;

    console.log('[Drag] Started:', draggedNode.className);
}

function handleDragMove(e) {
    if (!draggedNode || !editMode) return;

    e.preventDefault();

    const canvas = document.querySelector('.flow-canvas');
    const canvasRect = canvas.getBoundingClientRect();

    const deltaX = e.clientX - dragStartX;
    const deltaY = e.clientY - dragStartY;

    const newLeft = dragStartLeft + deltaX;
    const newTop = dragStartTop + deltaY;

    // Constraints - keep within canvas
    const nodeRect = draggedNode.getBoundingClientRect();
    const minLeft = canvasRect.left;
    const maxLeft = canvasRect.right - nodeRect.width;
    const minTop = canvasRect.top;
    const maxTop = canvasRect.bottom - nodeRect.height;

    const constrainedLeft = Math.max(minLeft, Math.min(maxLeft, newLeft));
    const constrainedTop = Math.max(minTop, Math.min(maxTop, newTop));

    // P≈ôev√©st na pozice relativn√≠ k canvas
    const relativeLeft = ((constrainedLeft - canvasRect.left) / canvasRect.width) * 100;
    const relativeTop = ((constrainedTop - canvasRect.top) / canvasRect.height) * 100;

    draggedNode.style.left = `${relativeLeft}%`;
    draggedNode.style.top = `${relativeTop}%`;
    draggedNode.style.right = 'auto';
    draggedNode.style.bottom = 'auto';
    draggedNode.style.transform = 'none';

    // Live update ƒçar a ƒç√°stic bƒõhem ta≈æen√≠
    invalidateNodeCentersCache();
    if (typeof drawConnections === 'function') {
        drawConnections();
    }
}

function handleDragEnd(e) {
    if (!draggedNode || !editMode) return;

    e.preventDefault();

    draggedNode.classList.remove('dragging');

    // Ulo≈æit pozice
    saveCurrentLayout();

    // Fin√°ln√≠ update ƒçar a ƒç√°stic
    invalidateNodeCentersCache();
    if (typeof drawConnections === 'function') {
        drawConnections();
    }
    if (typeof updateAllParticleFlows === 'function') {
        updateAllParticleFlows();
    }

    console.log('[Drag] Ended');
    draggedNode = null;
}

// Touch handlers
function handleTouchStart(e) {
    if (!editMode) return;

    e.preventDefault();
    draggedNode = e.target.closest('.node');
    if (!draggedNode) return;

    draggedNode.classList.add('dragging');

    const touch = e.touches[0];
    const rect = draggedNode.getBoundingClientRect();

    dragStartX = touch.clientX;
    dragStartY = touch.clientY;
    dragStartTop = rect.top;
    dragStartLeft = rect.left;

    console.log('[Touch] Started:', draggedNode.className);
}

function handleTouchMove(e) {
    if (!draggedNode || !editMode) return;

    e.preventDefault();

    const touch = e.touches[0];
    const canvas = document.querySelector('.flow-canvas');
    const canvasRect = canvas.getBoundingClientRect();

    const deltaX = touch.clientX - dragStartX;
    const deltaY = touch.clientY - dragStartY;

    const newLeft = dragStartLeft + deltaX;
    const newTop = dragStartTop + deltaY;

    // Constraints
    const nodeRect = draggedNode.getBoundingClientRect();
    const minLeft = canvasRect.left;
    const maxLeft = canvasRect.right - nodeRect.width;
    const minTop = canvasRect.top;
    const maxTop = canvasRect.bottom - nodeRect.height;

    const constrainedLeft = Math.max(minLeft, Math.min(maxLeft, newLeft));
    const constrainedTop = Math.max(minTop, Math.min(maxTop, newTop));

    // Relativn√≠ pozice
    const relativeLeft = ((constrainedLeft - canvasRect.left) / canvasRect.width) * 100;
    const relativeTop = ((constrainedTop - canvasRect.top) / canvasRect.height) * 100;

    draggedNode.style.left = `${relativeLeft}%`;
    draggedNode.style.top = `${relativeTop}%`;
    draggedNode.style.right = 'auto';
    draggedNode.style.bottom = 'auto';
    draggedNode.style.transform = 'none';

    // Live update ƒçar bƒõhem touch ta≈æen√≠
    invalidateNodeCentersCache();
    if (typeof drawConnections === 'function') {
        drawConnections();
    }
}

function handleTouchEnd(e) {
    if (!draggedNode || !editMode) return;

    e.preventDefault();

    draggedNode.classList.remove('dragging');

    // Ulo≈æit pozice
    saveCurrentLayout();

    // Fin√°ln√≠ update ƒçar a ƒç√°stic
    invalidateNodeCentersCache();
    if (typeof drawConnections === 'function') {
        drawConnections();
    }
    if (typeof updateAllParticleFlows === 'function') {
        updateAllParticleFlows();
    }

    console.log('[Touch] Ended');
    draggedNode = null;
}

// Ulo≈æit aktu√°ln√≠ pozice v≈°ech nodes
function saveCurrentLayout() {
    const breakpoint = getCurrentBreakpoint();
    const canvas = document.querySelector('.flow-canvas');
    const canvasRect = canvas.getBoundingClientRect();

    const positions = {};
    const nodes = {
        'solar': document.querySelector('.solar'),
        'grid-node': document.querySelector('.grid-node'),
        'battery': document.querySelector('.battery'),
        'house': document.querySelector('.house'),
        'inverter': document.querySelector('.inverter')
    };

    Object.entries(nodes).forEach(([key, node]) => {
        if (!node) return;

        const rect = node.getBoundingClientRect();
        const relativeLeft = ((rect.left - canvasRect.left) / canvasRect.width) * 100;
        const relativeTop = ((rect.top - canvasRect.top) / canvasRect.height) * 100;

        positions[key] = {
            top: `${relativeTop}%`,
            left: `${relativeLeft}%`,
            right: 'auto',
            bottom: 'auto',
            transform: 'none'
        };
    });

    saveLayout(breakpoint, positions);
}

// Invalidace cache pro node centers
function invalidateNodeCentersCache() {
    if (typeof window.lastLayoutHash !== 'undefined') {
        window.lastLayoutHash = null;
    }
    if (typeof window.cachedNodeCenters !== 'undefined') {
        window.cachedNodeCenters = null;
    }
}

// Debounced resize handler
let resizeTimer = null;
function handleLayoutResize() {
    if (resizeTimer) clearTimeout(resizeTimer);

    resizeTimer = setTimeout(() => {
        const newBreakpoint = getCurrentBreakpoint();

        if (newBreakpoint !== currentBreakpoint) {
            console.log(`[Layout] Breakpoint changed: ${currentBreakpoint} ‚Üí ${newBreakpoint}`);
            currentBreakpoint = newBreakpoint;

            // Naƒç√≠st layout pro nov√Ω breakpoint
            const loaded = loadLayout(newBreakpoint);
            if (!loaded) {
                console.log(`[Layout] No custom ${newBreakpoint} layout, using defaults`);
            }
        }

        // OPRAVA: V≈ædy p≈ôekreslit ƒç√°ry p≈ôi resize (i bez zmƒõny breakpointu)
        // proto≈æe pozice nodes se mƒõn√≠ v % ‚Üí zmƒõna pixel pozic
        invalidateNodeCentersCache();
        if (typeof drawConnections === 'function') {
            drawConnections();
        }
        if (typeof updateAllParticleFlows === 'function') {
            updateAllParticleFlows();
        }
    }, 300);
}

// === GLOBAL VARIABLES FOR CHART DATA ===
// Store complete dataset for extremes calculation regardless of zoom
let originalPriceData = null;

// === TOOLTIP POSITIONING ===

// === CONTROL PANEL FUNCTIONS ===

// Toggle control panel
function toggleControlPanel() {
    const panel = document.getElementById('control-panel');
    const icon = document.getElementById('panel-toggle-icon');
    panel.classList.toggle('minimized');
    icon.textContent = panel.classList.contains('minimized') ? '+' : '‚àí';
}

// Toggle queue section
// === SHIELD (moved to dashboard-shield.js) ===
// Import shield functions
const startShieldQueueLiveUpdate = window.DashboardShield.startShieldQueueLiveUpdate;
const stopShieldQueueLiveUpdate = window.DashboardShield.stopShieldQueueLiveUpdate;
const loadShieldData = window.DashboardShield.loadShieldData;
const debouncedShieldMonitor = window.DashboardShield.debouncedShieldMonitor;
const setShieldMode = window.DashboardShield.setShieldMode;
const setShieldModeWithConfirmation = window.DashboardShield.setShieldModeWithConfirmation;
const cancelShieldAction = window.DashboardShield.cancelShieldAction;
const loadControlPanelStatus = window.DashboardShield.loadControlPanelStatus;
}

// === FLOW DIAGRAM (moved to dashboard-flow.js) ===
// Import functions from DashboardFlow module
const getSensorId = window.DashboardFlow.getSensorId;
const findShieldSensorId = window.DashboardFlow.findShieldSensorId;
const updateTime = window.DashboardFlow.updateTime;
const debouncedDrawConnections = window.DashboardFlow.debouncedDrawConnections;
const drawConnections = window.DashboardFlow.drawConnections;
const getNodeCenters = window.DashboardFlow.getNodeCenters;
const updateNode = window.DashboardFlow.updateNode;
const updateNodeDetails = window.DashboardFlow.updateNodeDetails;
const loadData = window.DashboardFlow.loadData;
const debouncedLoadData = window.DashboardFlow.debouncedLoadData;
const debouncedLoadNodeDetails = window.DashboardFlow.debouncedLoadNodeDetails;

// Find shield sensor dynamically (may have suffix like _2, _3)
function findShieldSensorId(sensorName) {
            btn.disabled = false;
            btn.classList.remove('pending');
        }
    }
}

// Initialize
// === THEME DETECTION ===

/**
 * Detekuje aktu√°ln√≠ t√©ma Home Assistantu a aplikuje spr√°vn√© styly
 */
function detectAndApplyTheme() {
    try {
        const hass = getHass();
        const bodyElement = document.body;
        let isLightTheme = false;

        if (hass && hass.themes) {
            // Metoda 1: P≈ô√≠m√Ω p≈ô√≠stup k HA theme konfiguraci (nejspolehlivƒõj≈°√≠)
            const selectedTheme = hass.selectedTheme || hass.themes.default_theme;
            const darkMode = hass.themes.darkMode;

            // console.log('[Theme] HA theme info:', {
            //     selectedTheme,
            //     darkMode,
            //     themes: hass.themes
            // });

            // HA m√° explicitn√≠ dark mode flag
            if (darkMode !== undefined) {
                isLightTheme = !darkMode;
                // console.log('[Theme] Using HA darkMode flag:', darkMode, '-> light theme:', isLightTheme);
            } else if (selectedTheme) {
                // Fallback: nƒõkter√° t√©mata maj√≠ v n√°zvu "light" nebo "dark"
                const themeName = selectedTheme.toLowerCase();
                if (themeName.includes('light')) {
                    isLightTheme = true;
                } else if (themeName.includes('dark')) {
                    isLightTheme = false;
                }
                // console.log('[Theme] Detected from theme name:', selectedTheme, '-> light:', isLightTheme);
            }
        } else {
            console.warn('[Theme] Cannot access hass.themes, trying CSS detection');
        }

        // Metoda 2: Fallback - detekce z CSS promƒõnn√Ωch
        if (!hass || !hass.themes) {
            try {
                const haElement = parent.document.querySelector('home-assistant');
                if (haElement) {
                    const computedStyle = getComputedStyle(haElement);
                    const primaryBg = computedStyle.getPropertyValue('--primary-background-color');

                    if (primaryBg) {
                        const rgb = primaryBg.match(/\d+/g);
                        if (rgb && rgb.length >= 3) {
                            const brightness = (parseInt(rgb[0]) + parseInt(rgb[1]) + parseInt(rgb[2])) / 3;
                            isLightTheme = brightness > 128;
                            console.log('[Theme] CSS detection - brightness:', brightness, '-> light:', isLightTheme);
                        }
                    }
                }
            } catch (e) {
                console.warn('[Theme] CSS detection failed:', e);
            }
        }

        // Aplikovat t≈ô√≠du na body
        if (isLightTheme) {
            bodyElement.classList.add('light-theme');
            bodyElement.classList.remove('dark-theme');
            // console.log('[Theme] ‚úì Light theme applied');
        } else {
            bodyElement.classList.add('dark-theme');
            bodyElement.classList.remove('light-theme');
            // console.log('[Theme] ‚úì Dark theme applied');
        }

    } catch (error) {
        console.error('[Theme] Error detecting theme:', error);
        // V√Ωchoz√≠: tmav√© t√©ma
        document.body.classList.add('dark-theme');
        document.body.classList.remove('light-theme');
    }
}

// === TOOLTIP SYSTEM ===

/**
 * Glob√°ln√≠ tooltip syst√©m - pou≈æ√≠v√° dedikovan√© DOM elementy mimo flow
 * Toto ≈ôe≈°en√≠ zaruƒçuje spr√°vn√© pozicov√°n√≠ bez ohledu na CSS transformace rodiƒç≈Ø
 */
function initTooltips() {
    const tooltip = document.getElementById('global-tooltip');
    const arrow = document.getElementById('global-tooltip-arrow');
    const entityValues = document.querySelectorAll('.entity-value[data-tooltip], .entity-value[data-tooltip-html], .detail-value[data-tooltip-html], #battery-grid-charging-indicator[data-tooltip], #battery-grid-charging-indicator[data-tooltip-html], #balancing-planned-time-short[data-tooltip-html], #battery-balancing-indicator[data-tooltip-html]');

    if (!tooltip || !arrow) {
        console.error('[Tooltips] Global tooltip elements not found!');
        return;
    }

    entityValues.forEach(element => {
        element.addEventListener('mouseenter', function () {
            const tooltipText = this.getAttribute('data-tooltip');
            const tooltipHtml = this.getAttribute('data-tooltip-html');

            if (!tooltipText && !tooltipHtml) return;

            // Nastavit text nebo HTML
            if (tooltipHtml) {
                tooltip.innerHTML = tooltipHtml;
            } else {
                tooltip.textContent = tooltipText;
            }

            // Z√≠skat pozici elementu v r√°mci viewportu
            const rect = this.getBoundingClientRect();

            // Nejprve zobrazit tooltip pro zmƒõ≈ôen√≠ jeho skuteƒçn√© velikosti
            tooltip.style.visibility = 'hidden';
            tooltip.style.opacity = '1';

            const tooltipRect = tooltip.getBoundingClientRect();
            const tooltipWidth = tooltipRect.width;
            const tooltipHeight = tooltipRect.height;
            const padding = 10;
            const arrowSize = 5;

            // Vypoƒç√≠tat pozici tooltipu
            let tooltipTop = rect.top - tooltipHeight - arrowSize - padding;
            let tooltipLeft = rect.left + (rect.width / 2) - (tooltipWidth / 2);

            // Zajistit ≈æe tooltip nen√≠ mimo viewport (horizont√°lnƒõ)
            const viewportWidth = window.innerWidth;
            if (tooltipLeft < padding) {
                tooltipLeft = padding;
            }
            if (tooltipLeft + tooltipWidth > viewportWidth - padding) {
                tooltipLeft = viewportWidth - tooltipWidth - padding;
            }

            // Kontrola zda se tooltip vejde nad element
            let isBelow = false;
            if (tooltipTop < padding) {
                // Nedostatek m√≠sta naho≈ôe - zobrazit dole
                tooltipTop = rect.bottom + arrowSize + padding;
                isBelow = true;
            }

            // Pozice ≈°ipky - v≈ædy uprost≈ôed p≈Øvodn√≠ho elementu
            const arrowLeft = rect.left + (rect.width / 2) - arrowSize;
            const arrowTop = isBelow
                ? rect.bottom + padding
                : rect.top - arrowSize - padding;

            // Aplikovat vypoƒç√≠tan√© pozice
            tooltip.style.top = `${tooltipTop}px`;
            tooltip.style.left = `${tooltipLeft}px`;
            tooltip.style.visibility = 'visible';

            arrow.style.top = `${arrowTop}px`;
            arrow.style.left = `${arrowLeft}px`;

            // Nastavit smƒõr ≈°ipky
            if (isBelow) {
                arrow.classList.add('below');
            } else {
                arrow.classList.remove('below');
            }

            // Zobrazit tooltip a ≈°ipku
            tooltip.classList.add('visible');
            arrow.classList.add('visible');
        });

        element.addEventListener('mouseleave', function () {
            // Skr√Ωt tooltip a ≈°ipku
            tooltip.classList.remove('visible');
            arrow.classList.remove('visible');

            // Po animaci schovat mimo obrazovku
            setTimeout(() => {
                if (!tooltip.classList.contains('visible')) {
                    tooltip.style.top = '-9999px';
                    tooltip.style.left = '-9999px';
                    arrow.style.top = '-9999px';
                    arrow.style.left = '-9999px';
                }
            }, 200); // d√©lka CSS transition
        });
    });

    // console.log('[Tooltips] Initialized for', entityValues.length, 'elements');
}

// === GRID CHARGING PLAN FUNCTIONS ===

// Update target warning indicator - kontrola dosa≈æitelnosti c√≠lov√© kapacity
async function updateTargetWarningIndicator() {
    const forecastData = await getSensorString(getSensorId('battery_forecast'));
    const warningRow = document.getElementById('target-warning-row');
    const warningIndicator = document.getElementById('target-warning-indicator');

    if (!forecastData || !forecastData.attributes || !warningRow || !warningIndicator) {
        return;
    }

    const attrs = forecastData.attributes;
    const targetAchieved = attrs.target_achieved;
    const minAchieved = attrs.min_achieved;
    const finalCapacityKwh = attrs.final_capacity_kwh;
    const targetCapacityKwh = attrs.target_capacity_kwh;
    const minCapacityKwh = attrs.min_capacity_kwh;
    const shortageKwh = attrs.shortage_kwh || 0;

    // Pokud nejsou dostupn√° data, skr√Ωt
    if (targetAchieved === undefined) {
        warningRow.style.display = 'none';
        return;
    }

    // Pokud je v≈°e OK (target dosa≈æen), skr√Ωt warning
    if (targetAchieved) {
        warningRow.style.display = 'none';
        return;
    }

    // Target NEN√ç dosa≈æen - zobrazit warning
    warningRow.style.display = 'flex';

    const maxCapacityKwh = attrs.max_capacity_kwh || 12.29;
    const finalPercentage = ((finalCapacityKwh / maxCapacityKwh) * 100).toFixed(0);
    const targetPercentage = ((targetCapacityKwh / maxCapacityKwh) * 100).toFixed(0);

    // Rozhodnout barvu a text podle z√°va≈ænosti
    let color, icon, text, tooltipText;

    if (!minAchieved) {
        // KRITICK√â: Nedos√°hne ani minimum
        color = '#f44336'; // ƒçerven√°
        icon = 'üî¥';
        text = `‚ö†Ô∏è Dos√°hne ${finalPercentage}%`;
        tooltipText = `
            <div style="padding: 8px; text-align: left;">
                <strong style="color: ${color};">‚ö†Ô∏è KRITICK√â VAROV√ÅN√ç</strong><br><br>
                <strong>Nedos√°hne minim√°ln√≠ kapacity!</strong><br>
                <span style="opacity: 0.8;">
                    C√≠lov√° kapacita: ${targetPercentage}% (${targetCapacityKwh.toFixed(1)} kWh)<br>
                    Minim√°ln√≠ kapacita: ${((minCapacityKwh / maxCapacityKwh) * 100).toFixed(0)}% (${minCapacityKwh.toFixed(1)} kWh)<br>
                    <strong>Dosa≈æiteln√°: ${finalPercentage}% (${finalCapacityKwh.toFixed(1)} kWh)</strong><br>
                    Chyb√≠: ${shortageKwh.toFixed(1)} kWh
                </span>
                <hr style="margin: 6px 0; border: none; border-top: 1px solid rgba(255,255,255,0.2);">
                <span style="font-size: 0.9em; opacity: 0.9;">
                    üí° Nen√≠ dostatek levn√Ωch hodin pro nab√≠jen√≠.<br>
                    Zvy≈°te max. cenu nebo sni≈æte c√≠lovou kapacitu.
                </span>
            </div>
        `;
    } else {
        // VAROV√ÅN√ç: Nedos√°hne target, ale dos√°hne minimum
        color = '#ff9800'; // oran≈æov√°
        icon = 'üü†';
        text = `‚ö†Ô∏è Dos√°hne ${finalPercentage}%`;
        tooltipText = `
            <div style="padding: 8px; text-align: left;">
                <strong style="color: ${color};">‚ö†Ô∏è VAROV√ÅN√ç</strong><br><br>
                <strong>Nedos√°hne c√≠lov√© kapacity</strong><br>
                <span style="opacity: 0.8;">
                    C√≠lov√° kapacita: ${targetPercentage}% (${targetCapacityKwh.toFixed(1)} kWh)<br>
                    <strong>Dosa≈æiteln√°: ${finalPercentage}% (${finalCapacityKwh.toFixed(1)} kWh)</strong><br>
                    Chyb√≠: ${shortageKwh.toFixed(1)} kWh
                </span>
                <hr style="margin: 6px 0; border: none; border-top: 1px solid rgba(255,255,255,0.2);">
                <span style="font-size: 0.9em; opacity: 0.9;">
                    üí° Nen√≠ dostatek levn√Ωch hodin pro dosa≈æen√≠ targetu.<br>
                    Minim√°ln√≠ kapacita bude zaji≈°tƒõna.
                </span>
            </div>
        `;
    }

    // Nastavit text a barvu
    warningIndicator.textContent = text;
    warningIndicator.style.color = color;
    warningIndicator.setAttribute('data-tooltip-html', tooltipText);

    // P≈ôidat blik√°n√≠ (pou≈æ√≠t existuj√≠c√≠ animaci)
    warningIndicator.style.animation = 'pulse-warning 2s ease-in-out infinite';
}

async function updateGridChargingPlan() {
    const gridChargingData = await getSensorString(getSensorId('grid_charging_planned'));
    const isPlanned = gridChargingData.value === 'on';

    // console.log('[Grid Charging] updateGridChargingPlan() called');
    // console.log('[Grid Charging] Sensor ID:', getSensorId('grid_charging_planned'));
    // console.log('[Grid Charging] Sensor value:', gridChargingData.value);
    // console.log('[Grid Charging] Is planned:', isPlanned);
    // console.log('[Grid Charging] Attributes:', gridChargingData.attributes);

    // Update indicator in battery card - always visible, but with active/inactive state
    const indicator = document.getElementById('battery-grid-charging-indicator');
    if (indicator) {
        // console.log('[Grid Charging] Indicator found, setting active class:', isPlanned);
        if (isPlanned) {
            indicator.classList.add('active');
        } else {
            indicator.classList.remove('active');
        }

        // Build tooltip with charging intervals table
        if (gridChargingData.attributes?.charging_intervals?.length > 0) {
            const intervals = gridChargingData.attributes.charging_intervals;
            const totalEnergy = gridChargingData.attributes.total_energy_kwh || 0;
            const totalCost = gridChargingData.attributes.total_cost_czk || 0;

            let tooltipHTML = '<div style="text-align: left; font-size: 11px; min-width: 250px;">';
            tooltipHTML += '<strong style="display: block; margin-bottom: 8px; font-size: 12px;">Pl√°novan√© nab√≠jen√≠ z gridu</strong>';
            tooltipHTML += '<table style="width: 100%; border-collapse: collapse;">';
            tooltipHTML += '<thead><tr style="border-bottom: 1px solid rgba(255,255,255,0.2);">';
            tooltipHTML += '<th style="padding: 4px; text-align: left;">ƒåas</th>';
            tooltipHTML += '<th style="padding: 4px; text-align: right;">Energie</th>';
            tooltipHTML += '<th style="padding: 4px; text-align: right;">Cena</th>';
            tooltipHTML += '</tr></thead>';
            tooltipHTML += '<tbody>';

            intervals.forEach(interval => {
                if (interval.is_charging_battery) {
                    const time = new Date(interval.timestamp).toLocaleTimeString('cs-CZ', { hour: '2-digit', minute: '2-digit' });
                    const energy = (interval.energy_kwh || 0).toFixed(2);
                    const cost = (interval.cost_czk || 0).toFixed(2);
                    tooltipHTML += '<tr>';
                    tooltipHTML += `<td style="padding: 2px 4px;">${time}</td>`;
                    tooltipHTML += `<td style="padding: 2px 4px; text-align: right;">${energy} kWh</td>`;
                    tooltipHTML += `<td style="padding: 2px 4px; text-align: right;">${cost} Kƒç</td>`;
                    tooltipHTML += '</tr>';
                }
            });

            tooltipHTML += '</tbody>';
            tooltipHTML += '<tfoot><tr style="border-top: 1px solid rgba(255,255,255,0.3); font-weight: bold;">';
            tooltipHTML += '<td style="padding: 4px;">Celkem</td>';
            tooltipHTML += `<td style="padding: 4px; text-align: right;">${totalEnergy.toFixed(2)} kWh</td>`;
            tooltipHTML += `<td style="padding: 4px; text-align: right;">${totalCost.toFixed(2)} Kƒç</td>`;
            tooltipHTML += '</tr></tfoot>';
            tooltipHTML += '</table>';
            tooltipHTML += '</div>';

            indicator.setAttribute('data-tooltip-html', tooltipHTML);
        } else {
            indicator.setAttribute('data-tooltip', '≈Ω√°dn√© pl√°novan√© nab√≠jen√≠');
        }

        // Re-inicializovat tooltips aby fungovaly i na dynamicky p≈ôidan√Ωch elementech
        initTooltips();
    }
    // else {
    //     console.error('[Grid Charging] Indicator element NOT FOUND!');
    // }

    // Show/hide section in battery details
    // OPRAVA: Zobrazit kdy≈æ existuj√≠ intervaly (ne jen kdy≈æ sensor je ON)
    const section = document.getElementById('grid-charging-plan-section');
    if (section) {
        const hasIntervals = gridChargingData.attributes?.charging_intervals?.length > 0;
        const shouldShow = hasIntervals; // Zobrazit kdy≈æ jsou pl√°novan√© intervaly
        // console.log('[Grid Charging] Section found, hasIntervals:', hasIntervals, 'shouldShow:', shouldShow);
        section.style.display = shouldShow ? 'block' : 'none';
    }
    // else {
    //     console.error('[Grid Charging] Section element NOT FOUND!');
    // }

    // Update energy (total_energy_kwh)
    const energyElement = document.getElementById('grid-charging-energy');
    if (energyElement && gridChargingData.attributes && gridChargingData.attributes.total_energy_kwh !== undefined) {
        const energy = parseFloat(gridChargingData.attributes.total_energy_kwh);
        energyElement.textContent = energy.toFixed(1) + ' kWh';
    }

    // Update cost
    const costElement = document.getElementById('grid-charging-cost');
    if (costElement && gridChargingData.attributes && gridChargingData.attributes.total_cost_czk !== undefined) {
        const cost = parseFloat(gridChargingData.attributes.total_cost_czk);
        costElement.textContent = '~' + cost.toFixed(2) + ' Kƒç';
    }

    // Update start time - relativn√≠ ƒças
    const startElement = document.getElementById('grid-charging-start');
    if (startElement && gridChargingData.attributes) {
        if (gridChargingData.attributes.next_charging_start) {
            // Get first charging interval to calculate relative time
            const intervals = gridChargingData.attributes.charging_intervals || [];
            const firstChargingInterval = intervals.find(i => i.is_charging_battery);

            if (firstChargingInterval) {
                const startTime = new Date(firstChargingInterval.timestamp);
                const now = new Date();
                const diffMs = startTime - now;
                const diffMinutes = Math.floor(diffMs / 60000);
                const diffHours = Math.floor(diffMinutes / 60);
                const remainingMinutes = diffMinutes % 60;

                let relativeText = '';
                if (diffMinutes < 0) {
                    relativeText = 'Prob√≠h√°';
                } else if (diffMinutes < 60) {
                    relativeText = `za ${diffMinutes} min`;
                } else if (diffMinutes < 1440) { // m√©nƒõ ne≈æ 24h
                    if (remainingMinutes > 0) {
                        relativeText = `za ${diffHours}h ${remainingMinutes}min`;
                    } else {
                        relativeText = `za ${diffHours}h`;
                    }
                } else {
                    const days = Math.floor(diffHours / 24);
                    relativeText = `za ${days}d`;
                }

                startElement.textContent = relativeText;
                startElement.setAttribute('title', gridChargingData.attributes.next_charging_start);
            } else {
                startElement.textContent = gridChargingData.attributes.next_charging_start;
            }
        } else {
            startElement.textContent = '--';
        }
    }

    // Update target warning indicator - naƒç√≠st data z battery_forecast sensoru
    await updateTargetWarningIndicator();

    // Build tooltip HTML with intervals table - na IKONƒö indik√°toru
    if (indicator && gridChargingData.attributes) {
        if (gridChargingData.attributes.charging_intervals && gridChargingData.attributes.charging_intervals.length > 0) {
            const intervals = gridChargingData.attributes.charging_intervals;
            const totalEnergy = gridChargingData.attributes.total_energy_kwh || 0;
            const totalCost = gridChargingData.attributes.total_cost_czk || 0;
            const startTimeFormatted = gridChargingData.attributes.next_charging_start || '';

            let tooltipHtml = `
                <div style="padding: 8px;">
                    <strong>Start:</strong> ${startTimeFormatted}<br>
                    <strong>Pl√°novan√© dobit√≠:</strong> ${totalEnergy.toFixed(1)} kWh<br>
                    <strong>Celkov√° cena:</strong> ~${totalCost.toFixed(2)} Kƒç
                    <hr style="margin: 8px 0; border: none; border-top: 1px solid var(--border-secondary);">
                    <table style="width: 100%; font-size: 0.85em; border-collapse: collapse;">
                        <thead>
                            <tr style="border-bottom: 1px solid var(--border-primary);">
                                <th style="padding: 4px; text-align: left;">ƒåas</th>
                                <th style="padding: 4px; text-align: right;">kWh</th>
                                <th style="padding: 4px; text-align: right;">Kƒç</th>
                                <th style="padding: 4px; text-align: center;">‚ö°</th>
                            </tr>
                        </thead>
                        <tbody>
            `;

            intervals.forEach((interval, index) => {
                if (!interval.is_charging_battery) return; // Skip non-charging intervals

                const time = new Date(interval.timestamp).toLocaleTimeString('cs-CZ', { hour: '2-digit', minute: '2-digit' });
                const energy = interval.energy_kwh ? interval.energy_kwh.toFixed(2) : '-';
                const cost = interval.cost_czk ? interval.cost_czk.toFixed(2) : '-';

                tooltipHtml += `
                    <tr style="border-bottom: 1px solid var(--border-tertiary);">
                        <td style="padding: 4px;">${time}</td>
                        <td style="padding: 4px; text-align: right;">${energy}</td>
                        <td style="padding: 4px; text-align: right;">${cost}</td>
                        <td style="padding: 4px; text-align: center;">‚ö°</td>
                    </tr>
                `;
            });

            tooltipHtml += `
                        </tbody>
                    </table>
                </div>
            `;

            indicator.setAttribute('data-tooltip-html', tooltipHtml);
        }
    }
}

async function updateBatteryBalancingCard() {
    try {
        const balancingData = await getSensorString(getSensorId('battery_balancing'));
        const forecastData = await getSensorString(getSensorId('battery_forecast'));

        if (!balancingData || !balancingData.attributes) {
            console.warn('[Balancing] No balancing data available');
            return;
        }

        const attrs = balancingData.attributes;
        const status = balancingData.value; // ok, due_soon, critical, overdue, disabled
        const daysSince = attrs.days_since_last ?? null;
        const intervalDays = attrs.config?.interval_days ?? 7;
        const lastBalancing = attrs.last_balancing ? new Date(attrs.last_balancing) : null;
        const planned = attrs.planned;
        const currentState = attrs.current_state ?? 'standby'; // charging/balancing/planned/standby
        const timeRemaining = attrs.time_remaining; // HH:MM

        // Z√≠skat p≈ôesnou cenu z forecast sensoru
        const balancingCost = forecastData?.attributes?.balancing_cost;

        console.log('[Balancing] Forecast data:', {
            hasForecast: !!forecastData,
            hasAttributes: !!forecastData?.attributes,
            balancingCost: balancingCost,
            allAttributes: forecastData?.attributes ? Object.keys(forecastData.attributes) : []
        });

        // Vypoƒç√≠tat dny do dal≈°√≠ho balancingu
        let daysRemaining = null;
        if (daysSince !== null) {
            daysRemaining = Math.max(0, intervalDays - daysSince);
        }

        // Status barvy
        const statusColors = {
            ok: '#4CAF50',           // zelen√°
            due_soon: '#FFC107',     // ≈ælut√°
            critical: '#FF9800',     // oran≈æov√°
            overdue: '#F44336',      // ƒçerven√°
            disabled: '#757575'      // ≈°ed√°
        };
        const statusColor = statusColors[status] || '#757575';

        // Current state texty a barvy
        const stateTexts = {
            charging: 'P≈ô√≠prava na 100%',
            balancing: 'Vyrovn√°v√°n√≠ ƒçl√°nk≈Ø',
            completed: 'Vybalancov√°no',
            planned: 'ƒåek√° na zah√°jen√≠',
            standby: 'Standby'
        };

        const stateColors = {
            charging: '#FFC107',    // ≈ælut√°
            balancing: '#FF9800',   // oran≈æov√°
            completed: '#4CAF50',   // zelen√°
            planned: '#2196F3',     // modr√°
            standby: '#757575'      // ≈°ed√°
        };

        // Update status label s detailn√≠m stavem
        const statusLabel = document.getElementById('balancing-status-label');
        if (statusLabel) {
            const stateText = stateTexts[currentState] || currentState;
            const stateColor = stateColors[currentState] || '#757575';

            if (currentState === 'charging' && timeRemaining) {
                statusLabel.textContent = `${stateText} (${timeRemaining} do balancov√°n√≠)`;
            } else if (currentState === 'balancing' && timeRemaining) {
                statusLabel.textContent = `${stateText} (zb√Ωv√° ${timeRemaining})`;
            } else if (currentState === 'planned' && timeRemaining) {
                statusLabel.textContent = `${stateText} (start za ${timeRemaining})`;
            } else if (currentState === 'completed' && timeRemaining) {
                statusLabel.textContent = `${stateText} ${timeRemaining}`;
            } else {
                statusLabel.textContent = stateText;
            }

            statusLabel.style.color = stateColor;
        }

        // OPRAVA: Update nadpisu karty podle aktu√°ln√≠ho stavu
        const cardTitle = document.getElementById('balancing-card-title');
        if (cardTitle) {
            if (currentState === 'balancing') {
                cardTitle.textContent = '‚ö° Prob√≠h√° balancov√°n√≠';
                cardTitle.style.color = '#FF9800';
            } else if (currentState === 'charging') {
                cardTitle.textContent = 'üîã P≈ô√≠prava na balancov√°n√≠';
                cardTitle.style.color = '#FFC107';
            } else if (currentState === 'completed') {
                cardTitle.textContent = '‚úÖ Balancov√°n√≠ dokonƒçeno';
                cardTitle.style.color = '#4CAF50';
            } else if (currentState === 'planned') {
                cardTitle.textContent = 'üìÖ Balancov√°n√≠ napl√°nov√°no';
                cardTitle.style.color = '#2196F3';
            } else {
                cardTitle.textContent = 'üîã Vyrovn√°n√≠ baterie';
                cardTitle.style.color = '#FF9800';
            }
        }

        // Update velk√© ƒç√≠slo - dny
        const daysNumber = document.getElementById('balancing-days-number');
        if (daysNumber) {
            if (daysRemaining !== null) {
                daysNumber.textContent = daysRemaining;
                daysNumber.style.color = statusColor;
            } else {
                daysNumber.textContent = '?';
                daysNumber.style.color = '#757575';
            }
        }

        // Update posledn√≠ balancing (kr√°tk√Ω form√°t)
        const lastDateShort = document.getElementById('balancing-last-date-short');
        if (lastDateShort && lastBalancing) {
            const dateStr = lastBalancing.toLocaleDateString('cs-CZ', { day: '2-digit', month: '2-digit' });
            lastDateShort.textContent = `${dateStr} (${daysSince}d)`;
        } else if (lastDateShort) {
            lastDateShort.textContent = '≈Ω√°dn√©';
        }

        // Update pl√°novan√© balancing (kr√°tk√Ω form√°t)
        const plannedShort = document.getElementById('balancing-planned-short');
        const plannedTimeShort = document.getElementById('balancing-planned-time-short');
        const costValueShort = document.getElementById('balancing-cost-value-short');

        if (planned && plannedTimeShort && costValueShort && plannedShort) {
            // Zobrazit pl√°novanou ≈ô√°dku
            plannedShort.style.display = 'flex';

            // Parsovat ƒçasy
            const startTime = new Date(planned.holding_start);
            const startStr = startTime.toLocaleTimeString('cs-CZ', { hour: '2-digit', minute: '2-digit' });

            // Zobrazit info o charging intervalech
            const chargingIntervals = planned.charging_intervals || [];
            const chargingAvgPrice = planned.charging_avg_price_czk || 0;
            const endTime = new Date(planned.holding_end);
            const endStr = endTime.toLocaleTimeString('cs-CZ', { hour: '2-digit', minute: '2-digit' });

            // Sestavit detailn√≠ tooltip s tabulkou (zmen≈°en√° ≈°√≠≈ôka aby se ve≈°la)
            let tooltipHTML = '<div style="text-align: left; font-size: 11px; min-width: 200px; max-width: 250px;">';
            tooltipHTML += '<strong style="display: block; margin-bottom: 8px; font-size: 12px; color: #FFA726;">üîã Pl√°n balancov√°n√≠</strong>';

            // Sekce: P≈ô√≠prava (nab√≠jen√≠)
            if (chargingIntervals.length > 0) {
                tooltipHTML += '<div style="margin-bottom: 10px;">';
                tooltipHTML += '<div style="font-weight: 600; margin-bottom: 4px; color: rgba(255,255,255,0.9);">üìä P≈ô√≠prava (nab√≠jen√≠ na 100%)</div>';
                tooltipHTML += '<table style="width: 100%; border-collapse: collapse; margin-left: 8px;">';

                // Form√°tovat intervaly s datem (dnes/z√≠tra)
                const now = new Date();
                const todayDate = now.getDate();
                const chargingTimes = chargingIntervals.map(t => {
                    const time = new Date(t);
                    const timeStr = time.toLocaleTimeString('cs-CZ', { hour: '2-digit', minute: '2-digit' });
                    const isTomorrow = time.getDate() !== todayDate;
                    return isTomorrow ? `z√≠tra ${timeStr}` : timeStr;
                });

                // Rozdƒõlit intervaly pod sebe pro lep≈°√≠ ƒçitelnost
                tooltipHTML += '<tr><td style="padding: 2px 4px; color: rgba(255,255,255,0.7); vertical-align: top;">Intervaly:</td>';
                tooltipHTML += `<td style="padding: 2px 4px; text-align: right; line-height: 1.4;">${chargingTimes.join('<br>')}</td></tr>`;
                tooltipHTML += '<tr><td style="padding: 2px 4px; color: rgba(255,255,255,0.7);">Pr≈Ømƒõrn√° cena:</td>';
                tooltipHTML += `<td style="padding: 2px 4px; text-align: right;">${chargingAvgPrice.toFixed(2)} Kƒç/kWh</td></tr>`;
                tooltipHTML += '</table>';
                tooltipHTML += '</div>';
            }

            // Sekce: Balancov√°n√≠ (dr≈æen√≠)
            tooltipHTML += '<div style="margin-bottom: 10px;">';
            tooltipHTML += '<div style="font-weight: 600; margin-bottom: 4px; color: rgba(255,255,255,0.9);">‚ö° Balancov√°n√≠ (dr≈æen√≠ na 100%)</div>';
            tooltipHTML += '<table style="width: 100%; border-collapse: collapse; margin-left: 8px;">';
            tooltipHTML += '<tr><td style="padding: 2px 4px; color: rgba(255,255,255,0.7);">Zaƒç√°tek:</td>';
            tooltipHTML += `<td style="padding: 2px 4px; text-align: right;">${startStr}</td></tr>`;
            tooltipHTML += '<tr><td style="padding: 2px 4px; color: rgba(255,255,255,0.7);">Konec:</td>';
            tooltipHTML += `<td style="padding: 2px 4px; text-align: right;">${endStr}</td></tr>`;
            tooltipHTML += '<tr><td style="padding: 2px 4px; color: rgba(255,255,255,0.7);">D√©lka:</td>';
            tooltipHTML += `<td style="padding: 2px 4px; text-align: right;">${attrs.config?.hold_hours ?? 3} hodiny</td></tr>`;
            tooltipHTML += '</table>';
            tooltipHTML += '</div>';

            // Sekce: N√°klady (pokud jsou k dispozici)
            if (balancingCost) {
                const chargingCostVal = balancingCost.charging_cost_czk ?? 0;
                const holdingCostVal = balancingCost.holding_cost_czk ?? 0;
                const totalCostVal = balancingCost.total_cost_czk ?? 0;

                tooltipHTML += '<table style="width: 100%; border-collapse: collapse; margin-top: 8px;">';
                tooltipHTML += '<thead><tr style="border-bottom: 1px solid rgba(255,255,255,0.2);">';
                tooltipHTML += '<th style="padding: 4px; text-align: left; color: rgba(255,255,255,0.9);">üí∞ N√°klady</th>';
                tooltipHTML += '<th style="padding: 4px; text-align: right;"></th>';
                tooltipHTML += '</tr></thead>';
                tooltipHTML += '<tbody>';
                tooltipHTML += '<tr><td style="padding: 2px 4px; color: rgba(255,255,255,0.7);">Nab√≠jen√≠:</td>';
                tooltipHTML += `<td style="padding: 2px 4px; text-align: right;">${chargingCostVal.toFixed(2)} Kƒç</td></tr>`;
                tooltipHTML += '<tr><td style="padding: 2px 4px; color: rgba(255,255,255,0.7);">Dr≈æen√≠:</td>';
                tooltipHTML += `<td style="padding: 2px 4px; text-align: right;">${holdingCostVal.toFixed(2)} Kƒç</td></tr>`;
                tooltipHTML += '</tbody>';
                tooltipHTML += '<tfoot><tr style="border-top: 1px solid rgba(255,255,255,0.3); font-weight: bold;">';
                tooltipHTML += '<td style="padding: 4px;">Celkem:</td>';
                tooltipHTML += `<td style="padding: 4px; text-align: right;">${totalCostVal.toFixed(2)} Kƒç</td>`;
                tooltipHTML += '</tr></tfoot>';
                tooltipHTML += '</table>';
            }

            tooltipHTML += '</div>';

            plannedTimeShort.textContent = `dnes ${startStr}`;
            plannedTimeShort.setAttribute('data-tooltip-html', tooltipHTML);

            // P≈ôesn√© n√°klady pokud jsou k dispozici
            if (balancingCost) {
                const totalCost = balancingCost.total_cost_czk ?? 0;
                const chargingCost = balancingCost.charging_cost_czk ?? 0;
                const holdingCost = balancingCost.holding_cost_czk ?? 0;

                console.log('[Balancing] Cost data:', { totalCost, chargingCost, holdingCost, balancingCost });

                costValueShort.textContent = `${totalCost.toFixed(1)} Kƒç`;
                costValueShort.title = `Nab√≠jen√≠: ${chargingCost.toFixed(2)} Kƒç\nDr≈æen√≠: ${holdingCost.toFixed(2)} Kƒç\nCelkem: ${totalCost.toFixed(2)} Kƒç`;
            } else {
                // Fallback odhad
                console.warn('[Balancing] No balancing_cost in forecast, using estimate');
                const avgPrice = planned.avg_price_czk ?? 0;
                const holdHours = attrs.config?.hold_hours ?? 3;
                const estimatedCost = avgPrice * holdHours * 0.7;
                costValueShort.textContent = `~${estimatedCost.toFixed(1)} Kƒç`;
                costValueShort.title = `Odhad (p≈ôesn√© n√°klady nejsou k dispozici)`;
            }
        } else if (plannedShort) {
            // Skr√Ωt pl√°novanou ≈ô√°dku
            plannedShort.style.display = 'none';
            if (costValueShort) costValueShort.textContent = '--';
        }

        // Update timeline bar
        const timelineBar = document.getElementById('balancing-timeline-bar');
        const timelineLabel = document.getElementById('balancing-timeline-label');

        if (timelineBar && timelineLabel && daysSince !== null) {
            const progressPercent = Math.min(100, (daysSince / intervalDays) * 100);

            timelineBar.style.width = `${progressPercent}%`;
            timelineBar.style.background = `linear-gradient(90deg, ${statusColor} 0%, ${statusColor}aa 100%)`;

            timelineLabel.textContent = `${daysSince}/${intervalDays} dn√≠`;
        }

        // Re-inicializovat tooltips aby fungovaly na dynamicky p≈ôidan√Ωch elementech
        initTooltips();

        // NOV√â: Aktualizovat baterie balancing indik√°tor
        updateBatteryBalancingIndicator(currentState, timeRemaining, balancingCost);

    } catch (error) {
        console.error('[Balancing] Error updating battery balancing card:', error);
    }
}

/**
 * Aktualizuje indik√°tor balancov√°n√≠ baterie v boxu baterie
 * @param {string} state - Aktu√°ln√≠ stav: 'charging', 'balancing', 'planned', 'standby'
 * @param {string} timeRemaining - Zb√Ωvaj√≠c√≠ ƒças ve form√°tu HH:MM
 * @param {object} balancingCost - Objekt s n√°klady na balancov√°n√≠
 */
function updateBatteryBalancingIndicator(state, timeRemaining, balancingCost) {
    const indicator = document.getElementById('battery-balancing-indicator');
    const icon = document.getElementById('balancing-icon');
    const text = document.getElementById('balancing-text');

    if (!indicator || !icon || !text) return;

    // Zobrazit indik√°tor jen bƒõhem aktivn√≠ho balancov√°n√≠
    if (state === 'charging' || state === 'balancing') {
        indicator.style.display = 'flex';

        // Ikona podle stavu
        if (state === 'charging') {
            icon.textContent = '‚ö°';
            text.textContent = 'Nab√≠jen√≠...';
            indicator.className = 'battery-balancing-indicator charging';
        } else if (state === 'balancing') {
            icon.textContent = '‚è∏Ô∏è';
            text.textContent = 'Balancuje...';
            indicator.className = 'battery-balancing-indicator holding';
        }

        // Sestavit tooltip s detaily
        let tooltipHtml = '<div style="text-align: left; min-width: 200px;">';
        tooltipHtml += `<strong>üîã Balancov√°n√≠ baterie</strong><br><br>`;

        if (state === 'charging') {
            tooltipHtml += `<strong>F√°ze:</strong> Nab√≠jen√≠ baterie<br>`;
            tooltipHtml += `<em>Baterie se nab√≠j√≠ p≈ôed vyva≈æov√°n√≠m ƒçl√°nk≈Ø</em><br><br>`;
        } else {
            tooltipHtml += `<strong>F√°ze:</strong> Dr≈æen√≠ (balancov√°n√≠)<br>`;
            tooltipHtml += `<em>ƒål√°nky baterie se vyva≈æuj√≠ na stejnou √∫rove≈à</em><br><br>`;
        }

        if (timeRemaining) {
            tooltipHtml += `‚è±Ô∏è <strong>Zb√Ωv√°:</strong> ${timeRemaining}<br>`;
        }

        if (balancingCost) {
            const totalCost = balancingCost.total_cost_czk ?? 0;
            const chargingCost = balancingCost.charging_cost_czk ?? 0;
            const holdingCost = balancingCost.holding_cost_czk ?? 0;

            tooltipHtml += `<br><strong>üí∞ N√°klady:</strong><br>`;
            tooltipHtml += `‚Ä¢ Nab√≠jen√≠: ${chargingCost.toFixed(2)} Kƒç<br>`;
            tooltipHtml += `‚Ä¢ Dr≈æen√≠: ${holdingCost.toFixed(2)} Kƒç<br>`;
            tooltipHtml += `‚Ä¢ <strong>Celkem: ${totalCost.toFixed(2)} Kƒç</strong><br>`;
        }

        tooltipHtml += `<br><small style="opacity: 0.7;">‚ÑπÔ∏è Balancov√°n√≠ prodlu≈æuje ≈æivotnost baterie t√≠m, ≈æe vyrovn√° napƒõt√≠ v≈°ech ƒçl√°nk≈Ø</small>`;
        tooltipHtml += `</div>`;

        indicator.setAttribute('data-tooltip-html', tooltipHtml);

    } else {
        // Skr√Ωt indik√°tor pokud nen√≠ aktivn√≠ balancov√°n√≠
        indicator.style.display = 'none';
    }

    // Reinicializovat tooltips
    initTooltips();
}

function showGridChargingPopup() {
    getSensorString(getSensorId('grid_charging_planned')).then(gridChargingData => {
        if (!gridChargingData.attributes || !gridChargingData.attributes.charging_intervals) {
            showDialog('Pl√°novan√© nab√≠jen√≠ ze s√≠tƒõ', '≈Ω√°dn√© intervaly nejsou napl√°nov√°ny.');
            return;
        }

        const intervals = gridChargingData.attributes.charging_intervals;
        const totalEnergy = gridChargingData.attributes.total_energy_kwh || 0;
        const totalCost = gridChargingData.attributes.total_cost_czk || 0;

        // Build table HTML
        let tableHtml = `
            <div style="margin-bottom: 15px;">
                <strong>Celkov√° energie:</strong> ${totalEnergy.toFixed(2)} kWh<br>
                <strong>Celkov√° cena:</strong> ~${totalCost.toFixed(2)} Kƒç
            </div>
            <table style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
                <thead>
                    <tr style="background: var(--bg-secondary); border-bottom: 2px solid var(--border-primary);">
                        <th style="padding: 8px; text-align: left;">ƒåas</th>
                        <th style="padding: 8px; text-align: right;">Energie</th>
                        <th style="padding: 8px; text-align: right;">Cena</th>
                        <th style="padding: 8px; text-align: center;">Stav</th>
                    </tr>
                </thead>
                <tbody>
        `;

        intervals.forEach((interval, index) => {
            const rowBg = index % 2 === 0 ? 'var(--bg-tertiary)' : 'transparent';
            const isCharging = interval.is_charging_battery;
            const statusIcon = isCharging ? '‚ö°' : 'üîã';
            const statusText = isCharging ? 'Nab√≠j√≠' : interval.note || 'Baterie pln√°';
            const energyText = interval.grid_charge_kwh ? interval.grid_charge_kwh.toFixed(2) + ' kWh' : '-';
            const costText = interval.grid_charge_cost ? '~' + interval.grid_charge_cost.toFixed(2) + ' Kƒç' : '-';

            tableHtml += `
                <tr style="background: ${rowBg}; border-bottom: 1px solid var(--border-tertiary);">
                    <td style="padding: 8px;">${interval.time_from} - ${interval.time_to}</td>
                    <td style="padding: 8px; text-align: right;">${energyText}</td>
                    <td style="padding: 8px; text-align: right;">${costText}</td>
                    <td style="padding: 8px; text-align: center;" title="${statusText}">${statusIcon}</td>
                </tr>
            `;
        });

        tableHtml += `
                </tbody>
            </table>
        `;

        showDialog('‚ö° Pl√°novan√© nab√≠jen√≠ ze s√≠tƒõ', tableHtml);
    });
}

// === INITIALIZATION ===

function init() {
    drawConnections();

    // Detekovat a aplikovat t√©ma z Home Assistantu
    detectAndApplyTheme();

    // === LAYOUT CUSTOMIZATION INITIALIZATION ===
    currentBreakpoint = getCurrentBreakpoint();
    console.log(`[Layout] Initial breakpoint: ${currentBreakpoint}`);

    // Naƒç√≠st custom layout pokud existuje
    const loaded = loadLayout(currentBreakpoint);
    if (loaded) {
        console.log(`[Layout] Custom ${currentBreakpoint} layout loaded`);
    } else {
        console.log(`[Layout] Using default ${currentBreakpoint} layout`);
    }

    // Resize listener pro breakpoint changes
    window.addEventListener('resize', handleLayoutResize);

    // Auto-collapse control panel on mobile
    if (window.innerWidth <= 768) {
        const panel = document.getElementById('control-panel');
        const icon = document.getElementById('panel-toggle-icon');
        if (panel && icon) {
            panel.classList.add('minimized');
            icon.textContent = '+';
        }
    }

    // Initialize tooltip system
    initTooltips();

    // Phase 2.7: Initialize performance tracking chart
    initPerformanceChart();

    // OPRAVA: Poƒçkat na dokonƒçen√≠ layout naƒçten√≠ p≈ôed vol√°n√≠m loadData()
    // Pokud byl naƒçten custom layout, particles byly zastaveny
    // a needsFlowReinitialize je TRUE, tak≈æe loadData() je restartuje
    setTimeout(() => {
        // Initial full load
        forceFullRefresh();
        updateTime();

        // NOV√â: Load extended timeline for Today Plan Tile
        buildExtendedTimeline();

        // OPRAVA: Naƒç√≠st pricing data pokud je pricing tab aktivn√≠ p≈ôi naƒçten√≠ str√°nky
        const pricingTab = document.getElementById('pricing-tab');
        if (pricingTab && pricingTab.classList.contains('active')) {
            console.log('[Init] Pricing tab is active, loading initial pricing data...');
            pricingTabActive = true;
            setTimeout(() => {
                loadPricingData();
            }, 200);
        }
    }, 50);

    // Subscribe to shield state changes for real-time updates
    subscribeToShield();

    // Initial shield UI update with retry logic (wait for sensors after HA restart)
    let retryCount = 0;
    const maxRetries = 10;
    const retryInterval = 2000; // 2s between retries

    function tryInitialShieldLoad() {
        console.log(`[Shield] Attempting initial load (attempt ${retryCount + 1}/${maxRetries})...`);

        // Check if shield sensors are available
        const hass = getHass();
        if (!hass || !hass.states) {
            console.warn('[Shield] HA connection not ready, will retry...');
            retryCount++;
            if (retryCount < maxRetries) {
                setTimeout(tryInitialShieldLoad, retryInterval);
            } else {
                console.error('[Shield] Failed to load after', maxRetries, 'attempts');
                console.warn('[Shield] Falling back to 20s polling as backup');
                // Fallback: Enable backup polling if initial load fails
                setInterval(() => {
                    console.log('[Shield] Backup polling triggered');
                    monitorShieldActivity();
                    updateShieldQueue();
                    updateShieldUI();
                    updateButtonStates();
                }, 20000);
            }
            return;
        }

        const activitySensorId = findShieldSensorId('service_shield_activity');
        if (!activitySensorId || !hass.states[activitySensorId]) {
            console.warn('[Shield] Shield sensors not ready yet, will retry...');
            retryCount++;
            if (retryCount < maxRetries) {
                setTimeout(tryInitialShieldLoad, retryInterval);
            } else {
                console.error('[Shield] Shield sensors not available after', maxRetries, 'attempts');
                console.warn('[Shield] Falling back to 20s polling as backup');
                // Fallback: Enable backup polling if sensors not available
                setInterval(() => {
                    console.log('[Shield] Backup polling triggered');
                    monitorShieldActivity();
                    updateShieldQueue();
                    updateShieldUI();
                    updateButtonStates();
                }, 20000);
            }
            return;
        }

        // Sensors are ready, load UI
        console.log('[Shield] Sensors ready, loading initial UI...');
        updateButtonStates(); // Set initial active states (green highlighting)
        updateShieldQueue();  // Load initial queue state
        updateShieldUI();     // Load initial shield status
        monitorShieldActivity(); // Start activity monitoring
    }

    // Start initial load with delay
    setTimeout(tryInitialShieldLoad, 1000);

    // === EVENT-DRIVEN ARCHITECTURE ===
    // Ve≈°ker√© updates jsou ≈ô√≠zeny p≈ôes WebSocket subscriptions v subscribeToShield()
    // - Data sensors -> debouncedLoadData() (200ms debounce)
    // - Detail sensors -> debouncedLoadNodeDetails() (500ms debounce)
    // - Pricing sensors -> debouncedLoadPricingData() (300ms debounce)
    // - Shield sensors -> debouncedShieldMonitor() (100ms debounce)

    // REMOVED: Polling-based updates (replaced by WebSocket events)
    // setInterval(loadData, 5000);  ‚ùå Nahrazeno event-driven
    // setInterval(loadNodeDetails, 30000);  ‚ùå Nahrazeno event-driven
    // setInterval(detectAndApplyTheme, 5000);  ‚ùå Nahrazeno event-driven

    // Theme detection - pouze event listeners (NO POLLING)
    // 1. Parent window theme changes
    try {
        if (parent && parent.addEventListener) {
            parent.addEventListener('theme-changed', () => {
                console.log('[Theme] Theme changed event detected');
                detectAndApplyTheme();
            });
        }
    } catch (e) {
        console.warn('[Theme] Cannot listen to parent events:', e);
    }

    // 2. System preference changes
    if (window.matchMedia) {
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
            console.log('[Theme] System preference changed');
            detectAndApplyTheme();
        });
    }

    // 3. Fallback: Check theme on visibility change (tab switch)
    document.addEventListener('visibilitychange', () => {
        if (!document.hidden) {
            console.log('[Theme] Tab became visible, checking theme');
            detectAndApplyTheme();
        }
    });

    // REMOVED: Backup shield monitoring - WebSocket events handle all updates in real-time
    // setInterval(() => {
    //     monitorShieldActivity();
    //     updateShieldQueue();
    // }, 10000);

    // Time update every second
    setInterval(updateTime, 1000);

    // Redraw lines on resize with debounce
    let resizeTimer;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        // Clear cache on resize
        cachedNodeCenters = null;
        lastLayoutHash = null;
        resizeTimer = setTimeout(() => {
            // OPRAVA: P≈ôi resize na flow tabu mus√≠me reinicializovat particles
            const flowTab = document.querySelector('#flow-tab');
            const isFlowTabActive = flowTab && flowTab.classList.contains('active');

            if (isFlowTabActive) {
                console.log('[Resize] Flow tab is active, reinitializing particles...');
                // Zastavit star√© particles
                stopAllParticleFlows();
                // P≈ôekreslit connections s nov√Ωm layoutem
                drawConnections();
                // Force restart particles s aktu√°ln√≠mi pozicemi
                needsFlowReinitialize = true;
                loadData();
            } else {
                // Jen p≈ôekreslit connections pokud nejsme na flow tabu
                drawConnections();
            }
        }, 100);
    });

    // FIX: Force layout stabilization after initial render
    // Probl√©m: Po restartu HA se nƒõkdy naƒç√≠taj√≠ CSS/HTML v jin√©m po≈ôad√≠
    // ≈òe≈°en√≠: Opakovan√© p≈ôekreslen√≠ po r≈Øzn√Ωch intervalech
    // OPRAVA BUG #3: Inicializovat cache p≈ôed prvn√≠m kreslen√≠m
    setTimeout(() => { getNodeCenters(); drawConnections(); }, 100);   // Prvn√≠ pokus po 100ms
    setTimeout(() => { getNodeCenters(); drawConnections(); }, 500);   // Druh√Ω pokus po 500ms
    setTimeout(() => { getNodeCenters(); drawConnections(); }, 1000);  // T≈ôet√≠ pokus po 1s
    setTimeout(() => { getNodeCenters(); drawConnections(); }, 2000);  // Fin√°ln√≠ po 2s

    // Mobile: Toggle node details on click (collapsed by default)
    if (window.innerWidth <= 768) {
        const nodes = document.querySelectorAll('.node');
        nodes.forEach(node => {
            node.addEventListener('click', function (e) {
                // Ignore clicks on buttons inside nodes
                if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                    return;
                }
                this.classList.toggle('expanded');
            });

            // Add cursor pointer to indicate clickability
            node.style.cursor = 'pointer';
        });
    }

    // === CUSTOM TILES INITIALIZATION ===
    initCustomTiles();

    // === PERIODICK√ù CLEANUP PARTICLES (PREVENCE √öNIK PAMƒöTI) ===
    // Ka≈æd√Ωch 30 sekund zkontrolujeme poƒçet particles
    // Pokud NEJSME na tab Toky, NEMA≈Ω particles (budou pot≈ôeba po n√°vratu)
    // Pokud JSME na tab Toky a je > 40 kuliƒçek, proveƒè cleanup
    setInterval(() => {
        const flowTab = document.querySelector('#flow-tab');
        const isFlowTabActive = flowTab && flowTab.classList.contains('active');
        const particlesContainer = document.getElementById('particles');

        if (!isFlowTabActive) {
            // OPRAVA: NEMA≈Ω particles kdy≈æ nejsi na tabu - budou pot≈ôeba p≈ôi n√°vratu
            // Jen zkontroluj count pro monitoring
            if (particlesContainer) {
                const particleCount = particlesContainer.children.length;
                if (particleCount > 50) {
                    console.log(`[Particles] ‚ö†Ô∏è High particle count while tab inactive: ${particleCount} (will cleanup on tab switch)`);
                }
            }
        } else if (particlesContainer) {
            // Jsme na tab flow (toky) -> cleanup jen pokud je > 40 kuliƒçek
            const particleCount = particlesContainer.children.length;
            if (particleCount > 40) {
                console.log(`[Particles] ‚è∞ Periodic cleanup (${particleCount} particles exceeded threshold)`);
                stopAllParticleFlows();
                // Po cleanup restartovat animace s aktu√°ln√≠mi daty
                setTimeout(() => {
                    needsFlowReinitialize = true;
                    loadData();
                }, 200);
            }
        }
    }, 30000); // 30 sekund

    console.log('[Particles] ‚úì Periodic cleanup timer started (30s interval)');
}

// Wait for DOM
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
} else {
    init();
}

// === TAB SWITCHING ===
let pricingTabActive = false;
let needsFlowReinitialize = false; // Flag pro vynucen√© restartov√°n√≠ flow animac√≠

function switchTab(tabName) {
    // Zapamatuj si p≈ôedchoz√≠ tab P≈òED zmƒõnou
    const previousActiveContent = document.querySelector('.tab-content.active');
    const previousTab = previousActiveContent ? previousActiveContent.id.replace('-tab', '') : null;

    console.log(`[Tab] Switching from '${previousTab}' to '${tabName}'`);

    // Remove active from all tabs and contents
    document.querySelectorAll('.dashboard-tab').forEach(tab => tab.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

    // Add active to clicked tab (find by checking which one was clicked via event)
    const clickedTab = event ? event.target : document.querySelector('.dashboard-tab');
    if (clickedTab) {
        clickedTab.classList.add('active');
    }

    // Add active to corresponding content
    const tabContent = document.getElementById(tabName + '-tab');
    if (tabContent) {
        tabContent.classList.add('active');
    }

    // Track active tab for event-driven updates
    pricingTabActive = (tabName === 'pricing');

    // OPRAVA: P≈ôi ODCHODU z tab flow (toky), zastavit particles (cleanup)
    if (previousTab === 'flow' && tabName !== 'flow') {
        console.log('[Tab] ========== LEAVING FLOW TAB - CLEANUP ==========');
        stopAllParticleFlows();
    }

    // OPRAVA: P≈ôi p≈ôepnut√≠ NA tab flow (toky), p≈ôekreslit connections a FORCE restart particles
    if (tabName === 'flow') {
        console.log('[Tab] ========== SWITCHING TO FLOW TAB ==========');

        // D≈ÆLE≈ΩIT√â: Poƒçkat a≈æ se tab zobraz√≠ a DOM se vykresl√≠
        setTimeout(() => {
            console.log('[Tab] --- Timeout fired, starting redraw ---');

            const flowTab = document.getElementById('flow-tab');
            console.log('[Tab] Flow tab visible?', flowTab && flowTab.classList.contains('active'));
            console.log('[Tab] Flow tab offsetHeight:', flowTab?.offsetHeight);

            // OPRAVA: Zkontrolovat jestli je tab skuteƒçnƒõ viditeln√Ω
            if (!flowTab || !flowTab.classList.contains('active')) {
                console.warn('[Tab] ‚úó Flow tab not visible yet, aborting redraw');
                return;
            }

            // 3. Invalidovat cache pozic
            cachedNodeCenters = null;
            lastLayoutHash = null;
            console.log('[Tab] ‚úì Cache invalidated');

            // 4. Force browser reflow aby DOM byl stabiln√≠
            if (flowTab) {
                const reflow = flowTab.offsetHeight; // Trigger reflow
                console.log('[Tab] ‚úì Browser reflow triggered:', reflow, 'px');
            }

            // 5. Naƒç√≠st fresh pozice node element≈Ø
            console.log('[Tab] Getting node centers...');
            const centers = getNodeCenters();
            console.log('[Tab] Node centers result:', centers);

            // OPRAVA: Zkontrolovat jestli se pozice naƒçetly spr√°vnƒõ
            if (!centers || Object.keys(centers).length === 0) {
                console.error('[Tab] ‚úó Failed to get node centers (DOM not ready), retrying...');
                // Zkusit znovu s del≈°√≠m timeout
                setTimeout(() => {
                    cachedNodeCenters = null;
                    lastLayoutHash = null;
                    const retryCenters = getNodeCenters();
                    console.log('[Tab] Retry node centers result:', retryCenters);

                    if (!retryCenters || Object.keys(retryCenters).length === 0) {
                        console.error('[Tab] ‚úó Retry also failed, giving up');
                        return;
                    }

                    console.log('[Tab] ‚úì Node centers loaded on retry:', Object.keys(retryCenters).length);
                    drawConnections();
                    needsFlowReinitialize = true;
                    loadData();
                    console.log('[Tab] ‚úì Retry complete');
                }, 200);
                return;
            }

            // 6. P≈ôekreslit ƒç√°ry (teƒè u≈æ m√°me spr√°vn√© pozice)
            console.log('[Tab] ‚úì Node centers cached:', Object.keys(centers).length);
            console.log('[Tab] Drawing connections...');
            drawConnections();
            console.log('[Tab] ‚úì Connections drawn');

            // 7. Nastavit flag pro vynucen√© restartov√°n√≠ animac√≠
            needsFlowReinitialize = true;
            console.log('[Tab] Flag needsFlowReinitialize set to TRUE');

            // 8. Naƒç√≠st aktu√°ln√≠ data a restartovat particles
            console.log('[Tab] Loading fresh data for animations...');
            loadData(); // Naƒçte data a zavol√° animateFlow() s aktu√°ln√≠mi hodnotami
            console.log('[Tab] ========== TOKY TAB SWITCH COMPLETE ==========');
        }, 150); // Del≈°√≠ timeout aby se DOM stihl vykreslit
    }

    // Load data when entering pricing tab
    if (tabName === 'pricing') {
        console.log('[Tab] ========== SWITCHING TO PRICING TAB ==========');
        // Poƒçkat a≈æ se tab zobraz√≠ a canvas bude viditeln√Ω
        setTimeout(() => {
            console.log('[Pricing] Tab visible, loading pricing data...');
            loadPricingData();
        }, 150); // Stejn√Ω timeout jako u Toky pro konzistenci
    }

    // Load boiler dashboard when entering boiler tab
    if (tabName === 'boiler') {
        console.log('[Tab] ========== SWITCHING TO BOILER TAB ==========');
        setTimeout(() => {
            console.log('[Boiler] Tab visible, initializing boiler dashboard...');
            if (typeof initBoilerDashboard === 'function') {
                initBoilerDashboard();
            } else {
                console.error('[Boiler] initBoilerDashboard function not found');
            }
        }, 150);
    }

    // Load data when entering boiler tab
    if (tabName === 'boiler') {
        console.log('[Tab] ========== SWITCHING TO BOILER TAB ==========');
        // Poƒçkat a≈æ se tab zobraz√≠ a canvas bude viditeln√Ω
        setTimeout(() => {
            console.log('[Boiler] Tab visible, loading boiler data...');
            loadBoilerData();
        }, 150);
    }
}

// === BOILER DATA & CHART ===
let boilerChartInstance = null;

async function loadBoilerData() {
    console.log('[Boiler] Loading boiler data...');

    try {
        // Update boiler sensor values
        await updateBoilerSensors();

        // Update boiler profile
        await updateBoilerProfile();

        // NEW: Update energy breakdown
        await updateBoilerEnergyBreakdown();

        // NEW: Update predicted usage
        await updateBoilerPredictedUsage();

        // NEW: Update grade thermometer
        await updateBoilerGradeThermometer();

        // NEW: Render profiling chart
        await renderBoilerProfilingChart();

        // NEW: Render heatmap
        await renderBoilerHeatmap();

        // Initialize or refresh boiler chart
        await initializeBoilerChart();

        console.log('[Boiler] Data loaded successfully');
    } catch (error) {
        console.error('[Boiler] Failed to load data:', error);
    }
}

async function updateBoilerSensors() {
    const hass = getHass();
    if (!hass) return;

    // Boiler sensors have different naming: sensor.oig_bojler_*
    const sensorMap = {
        'boiler-soc-value': 'sensor.oig_bojler_stav_nabiti',
        'boiler-temp-top-value': 'sensor.oig_bojler_teplota_nahore',
        'boiler-energy-required-value': 'sensor.oig_bojler_pozadovana_energie',
        'boiler-plan-cost-value': 'sensor.oig_bojler_cena_planu_ohrevu'
    };

    for (const [elementId, entityId] of Object.entries(sensorMap)) {
        const state = hass?.states?.[entityId];

        const element = document.getElementById(elementId);
        if (element && state) {
            const value = parseFloat(state.state);
            if (!isNaN(value)) {
                if (entityId.includes('stav_nabiti')) {
                    element.textContent = `${value.toFixed(0)} %`;
                } else if (entityId.includes('teplota')) {
                    element.textContent = `${value.toFixed(1)} ¬∞C`;
                } else if (entityId.includes('energie')) {
                    element.textContent = `${value.toFixed(2)} kWh`;
                } else if (entityId.includes('cena')) {
                    element.textContent = `${value.toFixed(2)} Kƒç`;
                }
            }
        }
    }

    // Update plan info
    const planEntityId = 'sensor.oig_bojler_cena_planu_ohrevu';
    const planState = hass?.states?.[planEntityId];

    if (planState?.attributes?.plan) {
        const plan = planState.attributes.plan;
        const slots = plan.slots || [];
        const activeSlots = slots.filter(s => s.heating).length;

        document.getElementById('boiler-plan-digest').textContent = plan.digest || 'N/A';
        document.getElementById('boiler-plan-slots').textContent = slots.length;
        document.getElementById('boiler-plan-active-slots').textContent = activeSlots;

        if (slots.length > 0) {
            const startTime = new Date(slots[0].start_time);
            const endTime = new Date(slots[slots.length - 1].start_time);

            document.getElementById('boiler-plan-start').textContent = startTime.toLocaleString('cs-CZ', {
                day: '2-digit',
                month: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
            document.getElementById('boiler-plan-end').textContent = endTime.toLocaleString('cs-CZ', {
                day: '2-digit',
                month: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            });
        }
    }
}

async function updateBoilerProfile() {
    // Get configuration from energy sensor attributes
    const hass = getHass();
    if (!hass) return;

    const energyEntityId = 'sensor.oig_bojler_pozadovana_energie';
    const energyState = hass?.states?.[energyEntityId];

    if (energyState?.attributes) {
        const attrs = energyState.attributes;

        document.getElementById('boiler-profile-volume').textContent = `${attrs.volume_l || '--'} L`;
        document.getElementById('boiler-profile-target-temp').textContent = `${attrs.target_temp_c || '--'} ¬∞C`;

        // Deadline from plan or config
        const planEntityId = 'sensor.oig_bojler_cena_planu_ohrevu';
        const planState = hass?.states?.[planEntityId];
        const deadline = planState?.attributes?.plan?.deadline || attrs.deadline || '--:--';
        document.getElementById('boiler-profile-deadline').textContent = deadline;

        document.getElementById('boiler-profile-stratification').textContent = attrs.stratification_mode || attrs.method || '--';
        document.getElementById('boiler-profile-k-constant').textContent = attrs.k_constant?.toFixed(4) || '--';

        // Heater power - hide if element doesn't exist
        const heaterPowerEl = document.getElementById('boiler-profile-heater-power');
        if (heaterPowerEl) {
            heaterPowerEl.textContent = '--'; // Not available in attributes
        }
    }
}

async function initializeBoilerChart() {
    const canvas = document.getElementById('boiler-chart');
    if (!canvas) {
        console.warn('[Boiler] Chart canvas not found');
        return;
    }

    const hass = getHass();
    if (!hass) {
        console.warn('[Boiler] Hass not available for chart');
        return;
    }

    // Lazy load boiler chart module
    if (!window.BoilerChartModule) {
        try {
            const module = await import('./modules/boiler-chart.js');
            window.BoilerChartModule = module.BoilerChartModule;
        } catch (error) {
            console.error('[Boiler] Failed to load boiler-chart.js:', error);
            return;
        }
    }

    // Create or refresh chart instance
    if (!boilerChartInstance) {
        boilerChartInstance = new window.BoilerChartModule();
        await boilerChartInstance.init(canvas, hass, INVERTER_SN);
    } else {
        await boilerChartInstance.refresh();
    }
}

// Boiler control functions (will use ServiceShield)
async function planBoilerHeating() {
    console.log('[Boiler] Planning heating...');

    const hass = getHass();
    if (!hass) return;

    const service = 'oig_cloud.plan_boiler_heating';
    const entityId = 'sensor.oig_bojler_cena_planu_ohrevu';

    try {
        await hass.callService('oig_cloud', 'plan_boiler_heating', {
            entity_id: entityId
        });

        showNotification('‚úÖ Pl√°n topen√≠ byl √∫spƒõ≈°nƒõ vytvo≈ôen', 'success');

        // Refresh after planning
        setTimeout(() => loadBoilerData(), 2000);
    } catch (error) {
        console.error('[Boiler] Failed to plan heating:', error);
        showNotification('‚ùå Chyba p≈ôi pl√°nov√°n√≠ topen√≠', 'error');
    }
}

async function applyBoilerPlan() {
    console.log('[Boiler] Applying heating plan...');

    const hass = getHass();
    if (!hass) return;

    const service = 'oig_cloud.apply_boiler_plan';
    const entityId = 'sensor.oig_bojler_cena_planu_ohrevu';

    try {
        await hass.callService('oig_cloud', 'apply_boiler_plan', {
            entity_id: entityId
        });

        showNotification('‚úÖ Pl√°n topen√≠ byl aplikov√°n', 'success');

        // Refresh after applying
        setTimeout(() => loadBoilerData(), 2000);
    } catch (error) {
        console.error('[Boiler] Failed to apply plan:', error);
        showNotification('‚ùå Chyba p≈ôi aplikaci pl√°nu', 'error');
    }
}

async function cancelBoilerPlan() {
    console.log('[Boiler] Canceling heating plan...');

    const hass = getHass();
    if (!hass) return;

    const service = 'oig_cloud.cancel_boiler_plan';
    const entityId = 'sensor.oig_bojler_cena_planu_ohrevu';

    try {
        await hass.callService('oig_cloud', 'cancel_boiler_plan', {
            entity_id: entityId
        });

        showNotification('‚úÖ Pl√°n topen√≠ byl zru≈°en', 'success');

        // Refresh after canceling
        setTimeout(() => loadBoilerData(), 2000);
    } catch (error) {
        console.error('[Boiler] Failed to cancel plan:', error);
        showNotification('‚ùå Chyba p≈ôi ru≈°en√≠ pl√°nu', 'error');
    }
}

// NEW: Update energy breakdown (grid vs alternative)
async function updateBoilerEnergyBreakdown() {
    const hass = getHass();
    if (!hass) return;

    const planEntityId = 'sensor.oig_bojler_cena_planu_ohrevu';
    const planState = hass?.states?.[planEntityId];

    if (planState?.attributes?.plan) {
        const plan = planState.attributes.plan;
        const gridEnergy = plan.grid_energy_kwh || 0;
        const gridCost = plan.grid_cost_czk || 0;
        const altEnergy = plan.alt_energy_kwh || 0;
        const altCost = plan.alt_cost_czk || 0;

        // Update breakdown cards
        document.getElementById('boiler-grid-energy-value').textContent =
            `${gridEnergy.toFixed(2)} kWh (${gridCost.toFixed(2)} Kƒç)`;
        document.getElementById('boiler-alt-energy-value').textContent =
            `${altEnergy.toFixed(2)} kWh (${altCost.toFixed(2)} Kƒç)`;

        // Update heating ratio bar
        const totalEnergy = gridEnergy + altEnergy;
        if (totalEnergy > 0) {
            const gridPercent = (gridEnergy / totalEnergy) * 100;
            const altPercent = (altEnergy / totalEnergy) * 100;

            document.getElementById('boiler-ratio-grid').style.width = `${gridPercent}%`;
            document.getElementById('boiler-ratio-alt').style.width = `${altPercent}%`;
            document.getElementById('boiler-ratio-grid-label').textContent = `${gridPercent.toFixed(0)}% s√≠≈•`;
            document.getElementById('boiler-ratio-alt-label').textContent = `${altPercent.toFixed(0)}% alternativa`;
        }
    }
}

// NEW: Update predicted usage
async function updateBoilerPredictedUsage() {
    const hass = getHass();
    if (!hass) return;

    const energyEntityId = 'sensor.oig_bojler_pozadovana_energie';
    const energyState = hass?.states?.[energyEntityId];

    if (energyState?.attributes) {
        const predictedToday = energyState.attributes.predicted_usage_today || 0;
        const peakHours = energyState.attributes.peak_hours || [];

        document.getElementById('boiler-predicted-today').textContent = `${predictedToday.toFixed(2)} kWh`;
        document.getElementById('boiler-peak-hours').textContent = peakHours.map(h => `${h}h`).join(', ') || '--';

        // Calculate approximate liters at 40¬∞C
        // Energy = Volume √ó (40 - 15) √ó 0.00116
        // Volume = Energy / (25 √ó 0.00116)
        const liters = predictedToday / (25 * 0.00116);
        document.getElementById('boiler-water-liters').textContent = `${liters.toFixed(0)} L`;
    }
}

// NEW: Update grade thermometer
async function updateBoilerGradeThermometer() {
    const hass = getHass();
    if (!hass) return;

    const tempTopEntityId = 'sensor.oig_bojler_teplota_nahore';
    const socEntityId = 'sensor.oig_bojler_stav_nabiti';
    const energyEntityId = 'sensor.oig_bojler_pozadovana_energie';

    const tempTopState = hass?.states?.[tempTopEntityId];
    const socState = hass?.states?.[socEntityId];
    const energyState = hass?.states?.[energyEntityId];

    if (tempTopState && socState) {
        const tempTop = parseFloat(tempTopState.state);
        const soc = parseFloat(socState.state);
        const tempBottom = energyState?.attributes?.temp_bottom_c || tempTop * 0.8;
        const targetTemp = energyState?.attributes?.target_temp_c || 60;

        // Update water level (based on SOC)
        document.getElementById('boiler-water-level').style.height = `${soc}%`;

        // Update grade label
        document.getElementById('boiler-grade-label').textContent = `${soc.toFixed(0)}% nah≈ô√°to`;

        // Update sensor markers
        // Temperature range: 10¬∞C (bottom) to 70¬∞C (top)
        // Position calculation: (temp - 10) / (70 - 10) * 100
        const topPosition = ((tempTop - 10) / 60) * 100;
        const bottomPosition = ((tempBottom - 10) / 60) * 100;
        const targetPosition = ((targetTemp - 10) / 60) * 100;

        document.getElementById('boiler-sensor-top').style.bottom = `${topPosition}%`;
        document.getElementById('boiler-sensor-top').querySelector('.sensor-label').textContent = `${tempTop.toFixed(1)}¬∞C`;

        document.getElementById('boiler-sensor-bottom').style.bottom = `${bottomPosition}%`;
        document.getElementById('boiler-sensor-bottom').querySelector('.sensor-label').textContent = `${tempBottom.toFixed(1)}¬∞C`;

        document.getElementById('boiler-target-line').style.bottom = `${targetPosition}%`;
    }
}

// NEW: Render profiling chart
async function renderBoilerProfilingChart() {
    const canvas = document.getElementById('boiler-profile-chart');
    if (!canvas) return;

    try {
        const hass = getHass();
        if (!hass) {
            console.warn('[Boiler] Hass not available');
            return;
        }

        // Get data from sensor attributes
        const energySensor = hass.states['sensor.oig_bojler_pozadovana_energie'];
        if (!energySensor || !energySensor.attributes) {
            console.warn('[Boiler] Energy sensor not available');
            return;
        }

        const attrs = energySensor.attributes;
        const hourlyData = attrs.hourly_avg_kwh || {};
        const peakHours = attrs.peak_hours || [];
        const predictedToday = attrs.predicted_usage_today || 0;
        const daysTracked = attrs.days_tracked || 7;

        // Prepare data for chart
        const labels = Array.from({ length: 24 }, (_, i) => `${i}h`);
        const data = labels.map((_, i) => parseFloat(hourlyData[i] || 0));

        // Destroy existing chart
        if (window.boilerProfileChart) {
            window.boilerProfileChart.destroy();
        }

        // Create new chart
        const ctx = canvas.getContext('2d');
        window.boilerProfileChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Pr≈Ømƒõrn√° spot≈ôeba (kWh)',
                    data: data,
                    backgroundColor: labels.map((_, i) =>
                        peakHours.includes(i)
                            ? 'rgba(244, 67, 54, 0.6)'
                            : 'rgba(33, 150, 243, 0.6)'
                    ),
                    borderColor: labels.map((_, i) =>
                        peakHours.includes(i)
                            ? 'rgba(244, 67, 54, 1)'
                            : 'rgba(33, 150, 243, 1)'
                    ),
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: (context) => `${context.parsed.y.toFixed(2)} kWh`
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: 'kWh'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Hodina'
                        }
                    }
                }
            }
        });

        // Update stats
        document.getElementById('profile-stat-today').textContent = `${predictedToday.toFixed(2)} kWh`;
        document.getElementById('profile-stat-peaks').textContent = peakHours.map(h => `${h}h`).join(', ') || '--';
        document.getElementById('profile-stat-days').textContent = `${daysTracked} dn√≠`;

    } catch (error) {
        console.error('[Boiler] Error rendering profiling chart:', error);
    }
}

// NEW: Render heatmap
async function renderBoilerHeatmap() {
    const container = document.getElementById('boiler-heatmap');
    if (!container) return;

    try {
        const hass = getHass();
        if (!hass) {
            console.warn('[Boiler] Hass not available');
            return;
        }

        // Get data from sensor attributes
        const energySensor = hass.states['sensor.oig_bojler_pozadovana_energie'];
        if (!energySensor || !energySensor.attributes) {
            console.warn('[Boiler] Energy sensor not available for heatmap');
            return;
        }

        const attrs = energySensor.attributes;
        const heatmapData = attrs.heatmap_data || [];

        // If no heatmap_data, build from hourly_avg_kwh
        let dataMatrix = heatmapData;
        if (!heatmapData || heatmapData.length === 0) {
            const hourlyData = attrs.hourly_avg_kwh || {};
            dataMatrix = Array.from({ length: 7 }, () =>
                Array.from({ length: 24 }, (_, hour) => parseFloat(hourlyData[hour] || 0))
            );
        }

        // Calculate thresholds
        const allValues = dataMatrix.flat();
        const maxValue = Math.max(...allValues, 0.1);
        const lowThreshold = maxValue * 0.3;
        const highThreshold = maxValue * 0.7;

        // Clear container
        container.innerHTML = '';

        // Day labels
        const days = ['Po', '√öt', 'St', 'ƒåt', 'P√°', 'So', 'Ne'];

        // Header row with hour labels
        const headerDiv = document.createElement('div');
        headerDiv.className = 'heatmap-day-label';
        container.appendChild(headerDiv);

        for (let hour = 0; hour < 24; hour++) {
            const hourLabel = document.createElement('div');
            hourLabel.className = 'heatmap-hour-label';
            hourLabel.textContent = hour;
            container.appendChild(hourLabel);
        }

        // Rows for each day
        days.forEach((day, dayIndex) => {
            const dayLabel = document.createElement('div');
            dayLabel.className = 'heatmap-day-label';
            dayLabel.textContent = day;
            container.appendChild(dayLabel);

            for (let hour = 0; hour < 24; hour++) {
                const value = dataMatrix[dayIndex]?.[hour] || 0;
                const cell = document.createElement('div');
                cell.className = 'heatmap-cell';

                if (value === 0) {
                    cell.classList.add('none');
                } else if (value < lowThreshold) {
                    cell.classList.add('low');
                } else if (value < highThreshold) {
                    cell.classList.add('medium');
                } else {
                    cell.classList.add('high');
                }

                cell.title = `${day} ${hour}h: ${value.toFixed(2)} kWh`;
                container.appendChild(cell);
            }
        });

    } catch (error) {
        console.error('[Boiler] Error rendering heatmap:', error);
    }
}

function toggleBoilerControlPanel() {
    const panel = document.getElementById('boiler-control-panel');
    const icon = document.getElementById('boiler-panel-toggle-icon');

    if (panel.classList.contains('minimized')) {
        panel.classList.remove('minimized');
        icon.textContent = '‚àí';
    } else {
        panel.classList.add('minimized');
        icon.textContent = '+';
    }
}

// Removed duplicate showNotification - using DashboardUtils.showNotification instead

// === PRICING (moved to dashboard-pricing.js) ===
const debouncedLoadPricingData = window.DashboardPricing.debouncedLoadPricingData;
const debouncedUpdatePlannedConsumption = window.DashboardPricing.debouncedUpdatePlannedConsumption;
const loadPricingData = window.DashboardPricing.loadPricingData;
const updatePlannedConsumptionStats = window.DashboardPricing.updatePlannedConsumptionStats;
let tileDialog = null;

/**
 * Initialize custom tiles system
 */
async function initCustomTiles() {
    console.log('[Tiles] Initializing custom tiles system...');

    // Initialize tile dialog only if not already initialized
    const hass = getHass();
    if (!hass) {
        console.warn('[Tiles] Cannot initialize - no HA connection, retrying...');
        setTimeout(initCustomTiles, 1000); // Retry
        return;
    }

    // Initialize tile manager (only once)
    if (!tileManager) {
        tileManager = new DashboardTileManager(hass);
        window.tileManager = tileManager; // Export for dialog access

        // Listen for config changes
        tileManager.addChangeListener(() => {
            console.log('[Tiles] Config changed, re-rendering...');
            renderAllTiles();
            updateTileControlsUI();
        });

        // ASYNCHRONNƒö naƒç√≠st konfiguraci z HA storage
        console.log('[Tiles] Loading configuration...');
        await tileManager.init();
        console.log('[Tiles] Configuration loaded');
    }

    // Initialize tile dialog (only once)
    if (!tileDialog) {
        tileDialog = new TileConfigDialog(hass, tileManager);
        window.tileDialog = tileDialog; // Export for onclick handlers
    }

    // Initial render
    renderAllTiles();
    updateTileControlsUI();

    console.log('[Tiles] Initialization complete');
}

/**
 * Update tile count from UI input
 */
function updateTileCount(side, value) {
    if (!tileManager) {
        console.error('[Tiles] Tile manager not initialized');
        return;
    }

    tileManager.setTileCount(side, value);
}

/**
 * Toggle tiles section visibility
 */
function toggleTilesVisibility() {
    if (!tileManager) {
        console.error('[Tiles] Tile manager not initialized');
        return;
    }

    tileManager.toggleVisibility();

    const section = document.querySelector('.custom-tiles-section');
    if (section) {
        section.style.display = tileManager.isVisible() ? 'block' : 'none';
    }
}

/**
 * Reset all tiles to default
 */
function resetAllTiles() {
    if (!tileManager) {
        console.error('[Tiles] Tile manager not initialized');
        return;
    }

    if (!confirm('Opravdu smazat v≈°echny dla≈ædice a vr√°tit nastaven√≠ na v√Ωchoz√≠?')) {
        return;
    }

    tileManager.reset();

    // Reset UI inputs
    document.getElementById('tiles-left-count').value = 6;
    document.getElementById('tiles-right-count').value = 6;
}

/**
 * Update tile controls UI (inputs visibility toggle button)
 */
function updateTileControlsUI() {
    if (!tileManager) return;

    // Update inputs
    const leftInput = document.getElementById('tiles-left-count');
    const rightInput = document.getElementById('tiles-right-count');

    if (leftInput) {
        leftInput.value = tileManager.getTileCount('left');
    }
    if (rightInput) {
        rightInput.value = tileManager.getTileCount('right');
    }

    // Update visibility
    const section = document.querySelector('.custom-tiles-section');
    if (section) {
        const isVisible = tileManager.isVisible();
        section.style.display = isVisible ? 'block' : 'none';
        console.log(`[Tiles] Section visibility updated: ${isVisible}`);
    }

    // Update toggle button text
    const toggleBtn = document.getElementById('btn-tiles-toggle');
    if (toggleBtn && tileManager.isVisible()) {
        toggleBtn.style.background = 'rgba(76, 175, 80, 0.2)';
        toggleBtn.style.borderColor = 'rgba(76, 175, 80, 0.5)';
    } else if (toggleBtn) {
        toggleBtn.style.background = 'var(--button-bg)';
        toggleBtn.style.borderColor = 'var(--button-border)';
    }
}

/**
 * Render all tiles (both blocks)
 */
function renderAllTiles() {
    renderTilesBlock('left');
    renderTilesBlock('right');
}

/**
 * Render one tiles block
 * @param {string} side - 'left' or 'right'
 */
function renderTilesBlock(side) {
    const blockElement = document.getElementById(`tiles-${side}`);
    if (!blockElement) {
        console.warn(`[Tiles] Block element not found: tiles-${side}`);
        return;
    }

    const gridElement = blockElement.querySelector('.tiles-grid');
    if (!gridElement) {
        console.warn(`[Tiles] Grid element not found in tiles-${side}`);
        return;
    }

    // Get tile count for this side
    const tileCount = tileManager.getTileCount(side);

    // Hide block if count is 0
    if (tileCount === 0) {
        blockElement.style.display = 'none';
        return;
    } else {
        blockElement.style.display = 'block';
    }

    // Get configuration
    const tiles = tileManager.getTiles(side);

    // Debug log pro diagnostiku
    // console.log(`[Tiles] DEBUG ${side} tiles:`, tiles, 'non-null:', tiles.filter(t => t !== null));

    // Render tiles up to count
    gridElement.innerHTML = '';
    for (let i = 0; i < tileCount; i++) {
        const tileConfig = tiles[i];
        const tileElement = renderTile(side, i, tileConfig);
        gridElement.appendChild(tileElement);
    }

    // console.log(`[Tiles] Rendered ${side} block with ${tileCount} slots (${tiles.filter(t => t !== null).length} configured)`);
}

/**
 * Render single tile
 * @param {string} side - 'left' or 'right'
 * @param {number} index - Tile index (0-5)
 * @param {object|null} config - Tile configuration
 * @returns {HTMLElement} - Tile element
 */
function renderTile(side, index, config) {
    const tile = document.createElement('div');
    tile.className = 'dashboard-tile';
    tile.dataset.side = side;
    tile.dataset.index = index.toString();

    if (!config) {
        // Placeholder tile
        tile.classList.add('tile-placeholder');
        tile.innerHTML = `
            <div class="tile-placeholder-content" onclick="window.tileDialog.open(${index}, '${side}')">
                <div class="tile-placeholder-icon">‚ûï</div>
                <div class="tile-placeholder-text">P≈ôidat dla≈ædici</div>
            </div>
        `;
    } else if (config.type === 'entity') {
        // Entity tile
        tile.classList.add('tile-entity');
        tile.innerHTML = renderEntityTile(config, side, index);
    } else if (config.type === 'button') {
        // Button tile
        tile.classList.add('tile-button');
        tile.innerHTML = renderButtonTile(config, side, index);
    }

    // Add edit button (visible on hover)
    if (config) {
        const editBtn = document.createElement('button');
        editBtn.className = 'tile-edit';
        editBtn.innerHTML = '‚öôÔ∏è';
        editBtn.title = 'Upravit dla≈ædici';
        editBtn.onclick = (e) => {
            e.stopPropagation();
            window.tileDialog.open(index, side);
        };
        tile.appendChild(editBtn);
    }

    // Add remove button (visible on hover)
    if (config) {
        const removeBtn = document.createElement('button');
        removeBtn.className = 'tile-remove';
        removeBtn.innerHTML = '‚úï';
        removeBtn.title = 'Odstranit dla≈ædici';
        removeBtn.onclick = (e) => {
            e.stopPropagation();
            if (confirm('Opravdu odstranit tuto dla≈ædici?')) {
                tileManager.removeTile(side, index);
            }
        };
        tile.appendChild(removeBtn);
    }

    return tile;
}

/**
 * Render icon - podporuje emoji i MDI ikony
 * @param {string} icon - Icon string (emoji nebo mdi:xxx)
 * @param {string} color - Icon color
 * @returns {string} - HTML string
 */
function renderIcon(icon, color) {
    if (!icon) return '';

    // MDI ikona (form√°t mdi:xxx) - pou≈æ√≠t emoji fallback proto≈æe ha-icon nefunguje v iframe
    if (icon.startsWith('mdi:')) {
        const iconName = icon.substring(4); // Odstranit 'mdi:' prefix

        // Emoji mapa - stejn√° jako v dashboard-dialog.js
        const emojiMap = {
            // Spot≈ôebiƒçe
            'fridge': '‚ùÑÔ∏è', 'fridge-outline': '‚ùÑÔ∏è', 'dishwasher': 'üçΩÔ∏è', 'washing-machine': 'üß∫',
            'tumble-dryer': 'üå™Ô∏è', 'stove': 'üî•', 'microwave': 'üì¶', 'coffee-maker': '‚òï',
            'kettle': 'ü´ñ', 'toaster': 'üçû',
            // Osvƒõtlen√≠
            'lightbulb': 'üí°', 'lightbulb-outline': 'üí°', 'lamp': 'ü™î', 'ceiling-light': 'üí°',
            'floor-lamp': 'ü™î', 'led-strip': '‚ú®', 'led-strip-variant': '‚ú®', 'wall-sconce': 'üí°',
            'chandelier': 'üí°',
            // Vyt√°pƒõn√≠
            'thermometer': 'üå°Ô∏è', 'thermostat': 'üå°Ô∏è', 'radiator': '‚ô®Ô∏è', 'radiator-disabled': '‚ùÑÔ∏è',
            'heat-pump': '‚ô®Ô∏è', 'air-conditioner': '‚ùÑÔ∏è', 'fan': 'üåÄ', 'hvac': '‚ô®Ô∏è', 'fire': 'üî•',
            'snowflake': '‚ùÑÔ∏è',
            // Energie
            'lightning-bolt': '‚ö°', 'flash': '‚ö°', 'battery': 'üîã', 'battery-charging': 'üîã',
            'battery-50': 'üîã', 'solar-panel': '‚òÄÔ∏è', 'solar-power': '‚òÄÔ∏è', 'meter-electric': '‚ö°',
            'power-plug': 'üîå', 'power-socket': 'üîå',
            // Auto
            'car': 'üöó', 'car-electric': 'üöó', 'car-battery': 'üîã', 'ev-station': 'üîå',
            'ev-plug-type2': 'üîå', 'garage': 'üè†', 'garage-open': 'üè†',
            // Zabezpeƒçen√≠
            'door': 'üö™', 'door-open': 'üö™', 'lock': 'üîí', 'lock-open': 'üîì', 'shield-home': 'üõ°Ô∏è',
            'cctv': 'üìπ', 'camera': 'üìπ', 'motion-sensor': 'üëÅÔ∏è', 'alarm-light': 'üö®', 'bell': 'üîî',
            // Okna
            'window-closed': 'ü™ü', 'window-open': 'ü™ü', 'blinds': 'ü™ü', 'blinds-open': 'ü™ü',
            'curtains': 'ü™ü', 'roller-shade': 'ü™ü',
            // M√©dia
            'television': 'üì∫', 'speaker': 'üîä', 'speaker-wireless': 'üîä', 'music': 'üéµ',
            'volume-high': 'üîä', 'cast': 'üì°', 'chromecast': 'üì°',
            // S√≠≈•
            'router-wireless': 'üì°', 'wifi': 'üì∂', 'access-point': 'üì°', 'lan': 'üåê',
            'network': 'üåê', 'home-assistant': 'üè†',
            // Voda
            'water': 'üíß', 'water-percent': 'üíß', 'water-boiler': '‚ô®Ô∏è', 'water-pump': 'üíß',
            'shower': 'üöø', 'toilet': 'üöΩ', 'faucet': 'üö∞', 'pipe': 'üîß',
            // Poƒças√≠
            'weather-sunny': '‚òÄÔ∏è', 'weather-cloudy': '‚òÅÔ∏è', 'weather-night': 'üåô',
            'weather-rainy': 'üåßÔ∏è', 'weather-snowy': '‚ùÑÔ∏è', 'weather-windy': 'üí®',
            // Ostatn√≠
            'information': '‚ÑπÔ∏è', 'help-circle': '‚ùì', 'alert-circle': '‚ö†Ô∏è',
            'checkbox-marked-circle': '‚úÖ', 'toggle-switch': 'üîò', 'power': '‚ö°', 'sync': 'üîÑ'
        };

        const emoji = emojiMap[iconName] || '‚öôÔ∏è';
        return `<span style="font-size: 28px; color: ${color};">${emoji}</span>`;
    }

    // Emoji nebo jin√Ω text
    return icon;
}/**
 * Render entity tile content
 * @param {object} config - Entity tile config
 * @param {string} side - Tile side (left/right)
 * @param {number} index - Tile index
 * @returns {string} - HTML string
 */
function renderEntityTile(config, side, index) {
    const hass = getHass();
    if (!hass || !hass.states) {
        return '<div class="tile-error">HA nedostupn√©</div>';
    }

    const state = hass.states[config.entity_id];
    if (!state) {
        return `<div class="tile-error">Entita nenalezena:<br>${config.entity_id}</div>`;
    }

    const label = config.label || state.attributes.friendly_name || config.entity_id;
    // Pou≈æij POUZE ikonu z config, pokud nen√≠ nastavena, pou≈æij v√Ωchoz√≠ - nikdy ne z HA state
    const icon = config.icon || 'üìä';
    let value = state.state;
    let unit = state.attributes.unit_of_measurement || '';
    const color = config.color || '#03A9F4';

    // Konverze W/Wh na kW/kWh pokud >= 1000
    if (unit === 'W' || unit === 'Wh') {
        const numValue = parseFloat(value);
        if (!isNaN(numValue)) {
            if (Math.abs(numValue) >= 1000) {
                value = (numValue / 1000).toFixed(1);
                unit = unit === 'W' ? 'kW' : 'kWh';
            } else {
                value = Math.round(numValue);
            }
        }
    }

    // Podporn√© entity
    let supportHtml = '';
    if (config.support_entities) {
        // Top right
        if (config.support_entities.top_right) {
            const topRightState = hass.states[config.support_entities.top_right];
            if (topRightState) {
                let topRightValue = topRightState.state;
                let topRightUnit = topRightState.attributes.unit_of_measurement || '';
                const topRightIcon = topRightState.attributes.icon || '';

                // Konverze W/Wh na kW/kWh
                if (topRightUnit === 'W' || topRightUnit === 'Wh') {
                    const numValue = parseFloat(topRightValue);
                    if (!isNaN(numValue)) {
                        if (Math.abs(numValue) >= 1000) {
                            topRightValue = (numValue / 1000).toFixed(1);
                            topRightUnit = topRightUnit === 'W' ? 'kW' : 'kWh';
                        } else {
                            topRightValue = Math.round(numValue);
                        }
                    }
                }

                supportHtml += `
                    <div class="tile-support tile-support-top-right" onclick="event.stopPropagation(); openEntityDialog('${config.support_entities.top_right}')">
                        <span class="support-icon">${topRightIcon}</span>
                        <span class="support-value">${topRightValue}${topRightUnit}</span>
                    </div>
                `;
            }
        }

        // Bottom right
        if (config.support_entities.bottom_right) {
            const bottomRightState = hass.states[config.support_entities.bottom_right];
            if (bottomRightState) {
                let bottomRightValue = bottomRightState.state;
                let bottomRightUnit = bottomRightState.attributes.unit_of_measurement || '';
                const bottomRightIcon = bottomRightState.attributes.icon || '';

                // Konverze W/Wh na kW/kWh
                if (bottomRightUnit === 'W' || bottomRightUnit === 'Wh') {
                    const numValue = parseFloat(bottomRightValue);
                    if (!isNaN(numValue)) {
                        if (Math.abs(numValue) >= 1000) {
                            bottomRightValue = (numValue / 1000).toFixed(1);
                            bottomRightUnit = bottomRightUnit === 'W' ? 'kW' : 'kWh';
                        } else {
                            bottomRightValue = Math.round(numValue);
                        }
                    }
                }

                supportHtml += `
                    <div class="tile-support tile-support-bottom-right" onclick="event.stopPropagation(); openEntityDialog('${config.support_entities.bottom_right}')">
                        <span class="support-icon">${bottomRightIcon}</span>
                        <span class="support-value">${bottomRightValue}${bottomRightUnit}</span>
                    </div>
                `;
            }
        }
    }

    // Detekce neaktivn√≠ho stavu (0 W nebo 0 hodnota)
    const numericValue = parseFloat(state.state);
    const isInactive = !isNaN(numericValue) && numericValue === 0;
    const inactiveClass = isInactive ? ' tile-inactive' : '';

    return `
        <div class="tile-content tile-content-horizontal${inactiveClass}" style="border-left: 3px solid ${color};">
            <div class="tile-main-content">
                <div class="tile-icon-large" style="color: ${color};">${renderIcon(icon, color)}</div>
                <div class="tile-value-large" onclick="openEntityDialog('${config.entity_id}')" style="cursor: pointer;">${value}<span class="tile-unit">${unit}</span></div>
            </div>
            ${supportHtml}
            <div class="tile-label-hover">${label}</div>
        </div>
    `;
}

/**
 * Render button tile content
 * @param {object} config - Button tile config
 * @param {string} side - Tile side (left/right)
 * @param {number} index - Tile index
 * @returns {string} - HTML string
 */
function renderButtonTile(config, side, index) {
    const hass = getHass();
    if (!hass || !hass.states) {
        return '<div class="tile-error">HA nedostupn√©</div>';
    }

    const state = hass.states[config.entity_id];
    if (!state) {
        return `<div class="tile-error">Entita nenalezena:<br>${config.entity_id}</div>`;
    }

    const label = config.label || state.attributes.friendly_name || config.entity_id;
    // Pou≈æij POUZE ikonu z config, pokud nen√≠ nastavena, pou≈æij v√Ωchoz√≠ - nikdy ne z HA state
    const icon = config.icon || 'üîò';
    const color = config.color || '#FFC107';
    const action = config.action || 'toggle';
    const isOn = state.state === 'on';

    const buttonClass = isOn ? 'tile-button-active' : 'tile-button-inactive';

    // Popis akce pro u≈æivatele
    const actionLabels = {
        'toggle': 'P≈ôepnout',
        'turn_on': 'Zapnout',
        'turn_off': 'Vypnout'
    };
    const actionLabel = actionLabels[action] || 'Ovl√°dat';

    // Podporn√© entity
    let supportHtml = '';
    if (config.support_entities) {
        // Top right
        if (config.support_entities.top_right) {
            const topRightState = hass.states[config.support_entities.top_right];
            if (topRightState) {
                let topRightValue = topRightState.state;
                let topRightUnit = topRightState.attributes.unit_of_measurement || '';
                const topRightIcon = topRightState.attributes.icon || '';

                // Konverze W/Wh na kW/kWh
                if (topRightUnit === 'W' || topRightUnit === 'Wh') {
                    const numValue = parseFloat(topRightValue);
                    if (!isNaN(numValue)) {
                        if (Math.abs(numValue) >= 1000) {
                            topRightValue = (numValue / 1000).toFixed(1);
                            topRightUnit = topRightUnit === 'W' ? 'kW' : 'kWh';
                        } else {
                            topRightValue = Math.round(numValue);
                        }
                    }
                }

                supportHtml += `
                    <div class="tile-support tile-support-top-right" onclick="event.stopPropagation(); openEntityDialog('${config.support_entities.top_right}')">
                        <span class="support-icon">${topRightIcon}</span>
                        <span class="support-value">${topRightValue}${topRightUnit}</span>
                    </div>
                `;
            }
        }

        // Bottom right
        if (config.support_entities.bottom_right) {
            const bottomRightState = hass.states[config.support_entities.bottom_right];
            if (bottomRightState) {
                let bottomRightValue = bottomRightState.state;
                let bottomRightUnit = bottomRightState.attributes.unit_of_measurement || '';
                const bottomRightIcon = bottomRightState.attributes.icon || '';

                // Konverze W/Wh na kW/kWh
                if (bottomRightUnit === 'W' || bottomRightUnit === 'Wh') {
                    const numValue = parseFloat(bottomRightValue);
                    if (!isNaN(numValue)) {
                        if (Math.abs(numValue) >= 1000) {
                            bottomRightValue = (numValue / 1000).toFixed(1);
                            bottomRightUnit = bottomRightUnit === 'W' ? 'kW' : 'kWh';
                        } else {
                            bottomRightValue = Math.round(numValue);
                        }
                    }
                }

                supportHtml += `
                    <div class="tile-support tile-support-bottom-right" onclick="event.stopPropagation(); openEntityDialog('${config.support_entities.bottom_right}')">
                        <span class="support-icon">${bottomRightIcon}</span>
                        <span class="support-value">${bottomRightValue}${bottomRightUnit}</span>
                    </div>
                `;
            }
        }
    }

    return `
        <div class="tile-content tile-content-horizontal ${buttonClass}"
             style="border-left: 3px solid ${color};"
             onclick="executeTileButtonAction('${config.entity_id}', '${action}')">
            <div class="tile-main-content">
                <div class="tile-icon-large" style="color: ${color};">${renderIcon(icon, color)}</div>
                <div class="tile-button-state">${isOn ? 'ON' : 'OFF'}</div>
            </div>
            ${supportHtml}
            <div class="tile-label-hover">${label} ‚Ä¢ ${actionLabel}</div>
        </div>
    `;
}

/**
 * Execute button action
 * @param {string} entityId - Entity ID
 * @param {string} action - Action (toggle, turn_on, turn_off)
 */
function executeTileButtonAction(entityId, action) {
    const hass = getHass();
    if (!hass) {
        console.error('[Tiles] Cannot execute action - no HA connection');
        return;
    }

    const domain = entityId.split('.')[0];
    const service = action === 'toggle' ? 'toggle' : action;

    console.log(`[Tiles] Calling ${domain}.${service} on ${entityId}`);

    hass.callService(domain, service, { entity_id: entityId })
        .then(() => {
            console.log(`[Tiles] Service call successful`);
            // Re-render tiles after state change (debounced)
            setTimeout(renderAllTiles, 500);
        })
        .catch((err) => {
            console.error(`[Tiles] Service call failed:`, err);
            alert(`Chyba p≈ôi vol√°n√≠ slu≈æby: ${err.message}`);
        });
}

// === ƒåHM√ö WEATHER WARNING FUNCTIONS ===

let chmuWarningData = null;

// Update ƒåHM√ö warning badge
function updateChmuWarningBadge() {
    const hass = getHass();
    if (!hass) return;

    const localSensorId = `sensor.oig_${INVERTER_SN}_chmu_warning_level`;
    const globalSensorId = `sensor.oig_${INVERTER_SN}_chmu_warning_level_global`;

    const localSensor = hass.states[localSensorId];
    const globalSensor = hass.states[globalSensorId];

    if (!localSensor) {
        console.log('[ƒåHM√ö] Local sensor not found:', localSensorId);
        return;
    }

    const badge = document.getElementById('chmu-warning-badge');
    const icon = document.getElementById('chmu-icon');
    const text = document.getElementById('chmu-text');

    if (!badge || !icon || !text) return;

    const severity = parseInt(localSensor.state) || 0;
    const attrs = localSensor.attributes || {};
    const warningsCount = attrs.warnings_count || 0;
    const eventType = attrs.event_type || '';

    // OPRAVENO: Pokud je warnings_count=0 nebo event_type obsahuje "≈Ω√°dn√° v√Ωstraha", zobraz jako severity 0
    const effectiveSeverity = (warningsCount === 0 || eventType.includes('≈Ω√°dn√° v√Ωstraha')) ? 0 : severity;

    // Store data for modal
    chmuWarningData = {
        local: localSensor,
        global: globalSensor,
        severity: effectiveSeverity
    };

    // Remove all severity classes
    badge.className = 'chmu-warning-badge';
    badge.classList.add(`severity-${effectiveSeverity}`);

    // Update icon and text based on effective severity
    if (effectiveSeverity === 0) {
        icon.textContent = '‚úì';
        text.textContent = 'Bez v√Ωstrah';
    } else {
        if (effectiveSeverity >= 3) {
            icon.textContent = 'üö®';
        } else {
            icon.textContent = '‚ö†Ô∏è';
        }

        // Show event type instead of generic "Oran≈æov√© varov√°n√≠"
        text.textContent = eventType;

        // If multiple warnings, show count
        if (warningsCount > 1) {
            text.textContent = `${eventType} +${warningsCount - 1}`;
        }
    }
}

/**
 * Update battery efficiency statistics on Pricing tab
 * Loads data from battery_efficiency sensor and displays monthly stats
 */
async function updateBatteryEfficiencyStats() {
    const hass = getHass();
    if (!hass) return;

    const sensorId = `sensor.oig_${INVERTER_SN}_battery_efficiency`;
    const sensor = hass.states[sensorId];

    if (!sensor || sensor.state === 'unavailable' || sensor.state === 'unknown') {
        console.log('[Battery Efficiency] Sensor not available:', sensorId);
        return;
    }

    const attrs = sensor.attributes || {};

    // Prefer last month (complete), fallback to current month (partial)
    let displayEff, displayLossesPct, displayLossesKwh, displayCharge, displayDischarge, displayLabel;

    const lastMonthEff = attrs.efficiency_last_month_pct;
    const lastMonthLossesPct = attrs.losses_last_month_pct;
    const lastMonthLossesKwh = attrs.losses_last_month_kwh;
    const lastMonthCharge = attrs.last_month_charge_kwh;
    const lastMonthDischarge = attrs.last_month_discharge_kwh;

    const currentMonthEff = attrs.efficiency_current_month_pct;
    const currentMonthLossesPct = attrs.losses_current_month_pct;
    const currentMonthLossesKwh = attrs.losses_current_month_kwh;
    const currentMonthCharge = attrs.current_month_charge_kwh;
    const currentMonthDischarge = attrs.current_month_discharge_kwh;
    const currentMonthDays = attrs.current_month_days;

    // Use last month if available (complete data), otherwise use current month (partial)
    if (lastMonthEff !== null && lastMonthEff !== undefined &&
        lastMonthCharge !== null && lastMonthDischarge !== null) {
        displayEff = lastMonthEff;
        displayLossesPct = lastMonthLossesPct;
        displayLossesKwh = lastMonthLossesKwh;
        displayCharge = lastMonthCharge;
        displayDischarge = lastMonthDischarge;
        displayLabel = 'Minul√Ω mƒõs√≠c';
    } else if (currentMonthEff !== null && currentMonthEff !== undefined) {
        displayEff = currentMonthEff;
        displayLossesPct = currentMonthLossesPct;
        displayLossesKwh = currentMonthLossesKwh;
        displayCharge = currentMonthCharge;
        displayDischarge = currentMonthDischarge;
        displayLabel = `Tento mƒõs√≠c (${currentMonthDays} dn√≠)`;
    }

    if (displayEff !== undefined) {
        // Main value
        updateElementIfChanged('battery-efficiency-main', `${displayEff.toFixed(1)}%`, 'batt-eff-main');

        // Trend comparison
        if (lastMonthEff !== null && currentMonthEff !== null &&
            lastMonthEff !== undefined && currentMonthEff !== undefined) {
            const diff = currentMonthEff - lastMonthEff;
            const diffAbs = Math.abs(diff);
            let trendText = '';
            let trendColor = '';

            if (diff > 0.5) {
                trendText = `‚ÜóÔ∏è Vs minul√Ω mƒõs√≠c +${diffAbs.toFixed(1)}%`;
                trendColor = '#4CAF50';
            } else if (diff < -0.5) {
                trendText = `‚ÜòÔ∏è Vs minul√Ω mƒõs√≠c -${diffAbs.toFixed(1)}%`;
                trendColor = '#FF5722';
            } else {
                trendText = `‚û°Ô∏è Podobnƒõ jako minul√Ω mƒõs√≠c`;
                trendColor = 'var(--text-secondary)';
            }

            const trendEl = document.getElementById('battery-efficiency-trend');
            if (trendEl) {
                trendEl.textContent = trendText;
                trendEl.style.color = trendColor;
            }
        } else {
            updateElementIfChanged('battery-efficiency-trend', displayLabel, 'batt-trend');
        }

        // Detail values
        updateElementIfChanged('battery-charge-value', `${displayCharge?.toFixed(1) || '--'} kWh`, 'batt-charge-val');
        updateElementIfChanged('battery-discharge-value', `${displayDischarge?.toFixed(1) || '--'} kWh`, 'batt-discharge-val');
        updateElementIfChanged('battery-losses-value', `${displayLossesKwh?.toFixed(1) || '--'} kWh (${displayLossesPct?.toFixed(1) || '--'}%)`, 'batt-loss-val');

        // Update period label
        updateElementIfChanged('battery-efficiency-period-label', displayLabel, 'batt-period-label');

        // Update gradient bar comparison
        updateBatteryEfficiencyBar(lastMonthEff, currentMonthEff);
    } else {
        updateElementIfChanged('battery-efficiency-main', '--', 'batt-eff-main');
        updateElementIfChanged('battery-efficiency-period-label', 'ƒåek√°m na data...', 'batt-period-label');
        updateElementIfChanged('battery-efficiency-trend', 'ƒåek√°m na data...', 'batt-trend');
        updateElementIfChanged('battery-charge-value', '--', 'batt-charge-val');
        updateElementIfChanged('battery-discharge-value', '--', 'batt-discharge-val');
        updateElementIfChanged('battery-losses-value', '--', 'batt-loss-val');
    }
}

/**
 * Update gradient bar showing battery efficiency comparison
 */
function updateBatteryEfficiencyBar(lastMonthEff, currentMonthEff) {
    const barLast = document.getElementById('battery-efficiency-bar-last');
    const barCurrent = document.getElementById('battery-efficiency-bar-current');
    const labelLast = document.getElementById('battery-efficiency-bar-last-label');
    const labelCurrent = document.getElementById('battery-efficiency-bar-current-label');

    if (!barLast || !barCurrent || !labelLast || !labelCurrent) return;

    // Pokud m√°me obƒõ hodnoty, zobraz pomƒõr
    if (lastMonthEff !== null && lastMonthEff !== undefined &&
        currentMonthEff !== null && currentMonthEff !== undefined) {

        const total = lastMonthEff + currentMonthEff;
        const lastPercent = (lastMonthEff / total) * 100;
        const currentPercent = (currentMonthEff / total) * 100;

        barLast.style.width = `${lastPercent}%`;
        barCurrent.style.width = `${currentPercent}%`;
        labelLast.textContent = `${lastMonthEff.toFixed(1)}%`;
        labelCurrent.textContent = `${currentMonthEff.toFixed(1)}%`;
    } else if (lastMonthEff !== null && lastMonthEff !== undefined) {
        // Jen minul√Ω mƒõs√≠c
        barLast.style.width = '100%';
        barCurrent.style.width = '0%';
        labelLast.textContent = `${lastMonthEff.toFixed(1)}%`;
        labelCurrent.textContent = '--';
    } else if (currentMonthEff !== null && currentMonthEff !== undefined) {
        // Jen tento mƒõs√≠c
        barLast.style.width = '0%';
        barCurrent.style.width = '100%';
        labelLast.textContent = '--';
        labelCurrent.textContent = `${currentMonthEff.toFixed(1)}%`;
    } else {
        // ≈Ω√°dn√° data
        barLast.style.width = '0%';
        barCurrent.style.width = '0%';
        labelLast.textContent = '--';
        labelCurrent.textContent = '--';
    }
}

/**
 * Update planned consumption statistics on Pricing tab
 * Reads pre-calculated data from battery_forecast attributes
 */
async function updatePlannedConsumptionStats() {
    const hass = getHass();
    if (!hass) return;

    const forecastSensorId = `sensor.oig_${INVERTER_SN}_battery_forecast`;
    const forecastSensor = hass.states[forecastSensorId];

    // Check if sensor is available
    if (!forecastSensor || forecastSensor.state === 'unavailable' || forecastSensor.state === 'unknown') {
        console.log('[Planned Consumption] Battery forecast sensor not available:', forecastSensorId);
        updateElementIfChanged('planned-consumption-today', '--', 'planned-today');
        updateElementIfChanged('consumption-profile-today', 'ƒåek√°m na data...', 'profile-today');
        updateElementIfChanged('planned-consumption-tomorrow', '--', 'planned-tomorrow');
        updateElementIfChanged('consumption-profile-tomorrow', 'ƒåek√°m na data...', 'profile-tomorrow');
        return;
    }

    // Get pre-calculated consumption data from battery_forecast attributes
    const attrs = forecastSensor.attributes || {};

    // Display data (already calculated in Python) - naƒç√≠t√°me p≈ô√≠mo z root atribut≈Ø
    const todayPlannedKwh = attrs.planned_consumption_today;
    const tomorrowKwh = attrs.planned_consumption_tomorrow;
    const profileToday = attrs.profile_today;
    const profileTomorrow = attrs.profile_tomorrow;

    // Z√≠skat ji≈æ spot≈ôebovanou energii dnes z ac_out_en_day (vrac√≠ Wh, p≈ôev√©st na kWh)
    const todayConsumedSensorId = `sensor.oig_${INVERTER_SN}_ac_out_en_day`;
    const todayConsumedSensor = hass.states[todayConsumedSensorId];
    const todayConsumedWh = todayConsumedSensor && todayConsumedSensor.state !== 'unavailable'
        ? parseFloat(todayConsumedSensor.state) || 0
        : 0;
    const todayConsumedKwh = todayConsumedWh / 1000; // P≈ôevod Wh -> kWh

    // Celkov√° spot≈ôeba dnes (u≈æ spot≈ôebov√°no + je≈°tƒõ pl√°nov√°no)
    const todayTotalKwh = todayConsumedKwh + (todayPlannedKwh || 0);

    // Celkov√° pl√°novan√° spot≈ôeba (dnes zb√Ωv√° + z√≠t≈ôek cel√Ω)
    const totalPlannedKwh = (todayPlannedKwh || 0) + (tomorrowKwh || 0);

    // Update UI - Hlavn√≠ hodnota (pl√°novan√°: dnes zb√Ωv√° + z√≠t≈ôek)
    if (totalPlannedKwh > 0) {
        updateElementIfChanged('planned-consumption-main', `${totalPlannedKwh.toFixed(1)} kWh`, 'planned-main');
    } else {
        updateElementIfChanged('planned-consumption-main', '--', 'planned-main');
    }

    // Update trend text (porovn√°n√≠ celkem dnes vs z√≠t≈ôek)
    if (todayTotalKwh > 0 && tomorrowKwh !== null && tomorrowKwh !== undefined) {
        const diff = tomorrowKwh - todayTotalKwh;
        const diffPercent = todayTotalKwh > 0 ? ((diff / todayTotalKwh) * 100) : 0;
        let trendText = '';
        let trendIcon = '';

        if (Math.abs(diffPercent) < 5) {
            trendIcon = '‚û°Ô∏è';
            trendText = `Z√≠tra podobnƒõ`;
        } else if (diff > 0) {
            trendIcon = 'üìà';
            trendText = `Z√≠tra v√≠ce (+${Math.abs(diffPercent).toFixed(0)}%)`;
        } else {
            trendIcon = 'üìâ';
            trendText = `Z√≠tra m√©nƒõ (-${Math.abs(diffPercent).toFixed(0)}%)`;
        }

        updateElementIfChanged('planned-consumption-trend', `${trendIcon} ${trendText}`, 'planned-trend');
    } else {
        updateElementIfChanged('planned-consumption-trend', '--', 'planned-trend');
    }

    // Detail ≈ô√°dky - Dnes: spot≈ôebov√°no + zb√Ωv√° pl√°n, Z√≠tra: cel√Ω den
    if (todayConsumedKwh !== null && todayConsumedKwh !== undefined) {
        updateElementIfChanged('planned-today-consumed-kwh', `${todayConsumedKwh.toFixed(1)} kWh`, 'planned-today-consumed');
    } else {
        updateElementIfChanged('planned-today-consumed-kwh', '--', 'planned-today-consumed');
    }

    if (todayPlannedKwh !== null && todayPlannedKwh !== undefined) {
        updateElementIfChanged('planned-today-remaining-kwh', `${todayPlannedKwh.toFixed(1)} kWh`, 'planned-today-remaining');
    } else {
        updateElementIfChanged('planned-today-remaining-kwh', '--', 'planned-today-remaining');
    }

    if (tomorrowKwh !== null && tomorrowKwh !== undefined) {
        updateElementIfChanged('planned-tomorrow-kwh', `${tomorrowKwh.toFixed(1)} kWh`, 'planned-tomorrow-kwh');
    } else {
        updateElementIfChanged('planned-tomorrow-kwh', '--', 'planned-tomorrow-kwh');
    }

    // Profil display - bez emoji, ƒçist√Ω text (nahoru m√≠sto "Zb√Ωv√° dnes + cel√Ω z√≠t≈ôek")
    let profileDisplay = '';
    if (profileToday && profileToday !== '≈Ω√°dn√Ω profil' && profileToday !== 'Nezn√°m√Ω profil') {
        // Zkr√°tit dlouh√© n√°zvy profil≈Ø
        const shortProfile = profileToday.length > 55 ? profileToday.substring(0, 52) + '...' : profileToday;
        profileDisplay = shortProfile;
    } else {
        profileDisplay = '≈Ω√°dn√Ω profil';
    }
    updateElementIfChanged('consumption-profile-display', profileDisplay, 'profile-display');

    // Update gradient bar (m√≠sto canvas grafu)
    const barToday = document.getElementById('planned-consumption-bar-today');
    const barTomorrow = document.getElementById('planned-consumption-bar-tomorrow');
    const labelToday = document.getElementById('planned-bar-today-label');
    const labelTomorrow = document.getElementById('planned-bar-tomorrow-label');

    if (barToday && barTomorrow && todayTotalKwh > 0 && tomorrowKwh !== null && tomorrowKwh !== undefined) {
        const total = todayTotalKwh + tomorrowKwh;
        const todayPercent = (todayTotalKwh / total) * 100;
        const tomorrowPercent = (tomorrowKwh / total) * 100;

        barToday.style.width = `${todayPercent}%`;
        barTomorrow.style.width = `${tomorrowPercent}%`;

        if (labelToday) labelToday.textContent = `${todayTotalKwh.toFixed(1)}`;
        if (labelTomorrow) labelTomorrow.textContent = `${tomorrowKwh.toFixed(1)}`;
    }
}

/**
 * Update what-if analysis statistics on Pricing tab
 * Reads mode_optimization.alternatives from battery_forecast attributes
 */
async function updateWhatIfAnalysis() {
    const hass = getHass();
    if (!hass) return;

    const forecastSensorId = `sensor.oig_${INVERTER_SN}_battery_forecast`;
    const forecastSensor = hass.states[forecastSensorId];

    // Check if sensor is available
    if (!forecastSensor || forecastSensor.state === 'unavailable' || forecastSensor.state === 'unknown') {
        console.log('[What-if] Battery forecast sensor not available');
        updateElementIfChanged('whatif-optimized-cost', '--', 'whatif-main');
        updateElementIfChanged('whatif-savings-main', '--', 'whatif-savings');
        updateElementIfChanged('whatif-home-i-delta', '--', 'whatif-home-i');
        updateElementIfChanged('whatif-home-ii-delta', '--', 'whatif-home-ii');
        updateElementIfChanged('whatif-home-iii-delta', '--', 'whatif-home-iii');
        updateElementIfChanged('whatif-home-ups-delta', '--', 'whatif-home-ups');
        return;
    }

    // Get mode_optimization data (still in attributes)
    const attrs = forecastSensor.attributes || {};
    const modeOptData = attrs.mode_optimization || {};
    const alternatives = modeOptData.alternatives || {};

    console.log('[What-if Tile] modeOptData:', modeOptData);
    console.log('[What-if Tile] alternatives:', alternatives);

    // Phase 2.8: Use cached totals from mode_optimization instead of summing blocks
    // (mode_recommendations are per-interval, mode_optimization has pre-calculated totals for DNES+Z√çTRA)
    const totalCost = modeOptData.total_cost_czk || 0;
    const totalSavings = modeOptData.total_savings_vs_home_i_czk || 0;

    console.log('[What-if Tile] totalCost:', totalCost, 'totalSavings:', totalSavings);

    // Update optimized cost and savings
    updateElementIfChanged('whatif-optimized-cost', `${totalCost.toFixed(2)} Kƒç`, 'whatif-main');

    if (totalSavings > 0) {
        updateElementIfChanged('whatif-savings-main', `+${totalSavings.toFixed(2)} Kƒç`, 'whatif-savings');
    } else if (totalSavings < 0) {
        updateElementIfChanged('whatif-savings-main', `${totalSavings.toFixed(2)} Kƒç`, 'whatif-savings');
    } else {
        updateElementIfChanged('whatif-savings-main', '0 Kƒç', 'whatif-savings');
    }

    // Update what-if alternatives comparison - 4 modes only
    // Backend format: alternatives = { "HOME I": {...}, "HOME II": {...}, ... }
    const homeI = alternatives['HOME I'];
    const homeII = alternatives['HOME II'];
    const homeIII = alternatives['HOME III'];
    const homeUps = alternatives['HOME UPS'] || alternatives['FULL HOME UPS'];
    const doNothing = alternatives['DO NOTHING'];

    // Format deltas (delta_czk from backend - positive means alternative is more expensive)
    const formatDelta = (alt) => {
        if (!alt || alt.delta_czk === undefined) return '--';
        const delta = alt.delta_czk;
        if (delta > 0.01) {
            return `+${delta.toFixed(2)} Kƒç`;
        } else if (delta < -0.01) {
            return `${delta.toFixed(2)} Kƒç`;
        } else {
            return '~0 Kƒç';
        }
    };

    // Update values
    updateElementIfChanged('whatif-home-i-delta', formatDelta(homeI), 'whatif-home-i');
    updateElementIfChanged('whatif-home-ii-delta', formatDelta(homeII), 'whatif-home-ii');
    updateElementIfChanged('whatif-home-iii-delta', formatDelta(homeIII), 'whatif-home-iii');
    updateElementIfChanged('whatif-home-ups-delta', formatDelta(homeUps), 'whatif-home-ups');

    // Highlight active mode (DO NOTHING = current mode)
    // Reset all rows first
    const rows = ['whatif-home-i-row', 'whatif-home-ii-row', 'whatif-home-iii-row', 'whatif-home-ups-row'];
    rows.forEach(rowId => {
        const row = document.getElementById(rowId);
        if (row) {
            row.style.background = 'transparent';
            row.style.border = 'none';
        }
    });

    // Highlight the active one (if DO NOTHING exists, check which mode it represents)
    if (doNothing && doNothing.current_mode) {
        // Backend provides current_mode field in DO NOTHING
        const activeMode = doNothing.current_mode;
        let activeRowId = null;

        if (activeMode === 'HOME I') {
            activeRowId = 'whatif-home-i-row';
        } else if (activeMode === 'HOME II') {
            activeRowId = 'whatif-home-ii-row';
        } else if (activeMode === 'HOME III') {
            activeRowId = 'whatif-home-iii-row';
        } else if (activeMode === 'HOME UPS') {
            activeRowId = 'whatif-home-ups-row';
        }

        if (activeRowId) {
            const activeRow = document.getElementById(activeRowId);
            if (activeRow) {
                activeRow.style.background = 'rgba(76, 175, 80, 0.15)';
                activeRow.style.border = '1px solid rgba(76, 175, 80, 0.3)';
            }
        }
    }
}


/**
 * Update mode recommendations timeline on Pricing tab
 * Reads mode_recommendations from battery_forecast attributes
 */
async function updateModeRecommendations() {
    const hass = getHass();
    if (!hass) return;

    const forecastSensorId = `sensor.oig_${INVERTER_SN}_battery_forecast`;
    const forecastSensor = hass.states[forecastSensorId];

    const container = document.getElementById('mode-recommendations-timeline');
    if (!container) return;

    // Check if sensor is available
    if (!forecastSensor || forecastSensor.state === 'unavailable' || forecastSensor.state === 'unknown') {
        console.log('[Mode Recommendations] Battery forecast sensor not available');
        container.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary);">ƒåek√°m na data...</div>';
        return;
    }

    // Get mode_recommendations data
    const attrs = forecastSensor.attributes || {};
    const recommendations = attrs.mode_recommendations || [];

    if (!recommendations || recommendations.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary);">≈Ω√°dn√° doporuƒçen√≠ k dispozici</div>';
        return;
    }

    // Build timeline HTML
    const modeIcons = {
        'HOME I': 'üè†',
        'HOME II': 'üè°',
        'HOME III': 'üèòÔ∏è',
        'HOME UPS': '‚ö°'
    };

    const modeColors = {
        'HOME I': '#4CAF50',
        'HOME II': '#2196F3',
        'HOME III': '#FF9800',
        'HOME UPS': '#9C27B0'
    };

    let html = '<div style="display: flex; flex-direction: column; gap: 10px;">';

    recommendations.forEach((rec, index) => {
        const icon = modeIcons[rec.mode_name] || 'üìç';
        const color = modeColors[rec.mode_name] || '#757575';
        const fromTime = rec.from_time ? new Date(rec.from_time).toLocaleTimeString('cs-CZ', {hour: '2-digit', minute: '2-digit'}) : '--';
        const toTime = rec.to_time ? new Date(rec.to_time).toLocaleTimeString('cs-CZ', {hour: '2-digit', minute: '2-digit'}) : '--';
        const duration = rec.duration_hours || 0;

        html += `
            <div style="display: flex; align-items: center; padding: 8px 12px; background: rgba(255,255,255,0.02); border-left: 3px solid ${color}; border-radius: 4px;">
                <div style="font-size: 1.5em; margin-right: 10px;">${icon}</div>
                <div style="flex: 1;">
                    <div style="font-weight: 600; color: ${color};">${rec.mode_name}</div>
                    <div style="font-size: 0.85em; color: var(--text-secondary);">${fromTime} - ${toTime} (${duration.toFixed(1)}h)</div>
                </div>
                <div style="text-align: right; font-size: 0.85em; color: var(--text-secondary);">
                    ${rec.intervals_count || 0} interval≈Ø
                </div>
            </div>
        `;
    });

    html += '</div>';

    container.innerHTML = html;
}

// ============================================================================
// PHASE 2.7: PERFORMANCE TRACKING CHART
// ============================================================================

let performanceChart = null;

/**
 * Initialize performance tracking chart
 */
function initPerformanceChart() {
    const canvas = document.getElementById('performance-chart');
    if (!canvas) {
        console.log('[Performance Chart] Canvas not found');
        return;
    }

    const ctx = canvas.getContext('2d');

    // Create Chart.js instance
    performanceChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: [],
            datasets: [
                {
                    label: 'Oƒçek√°van√© n√°klady',
                    data: [],
                    backgroundColor: 'rgba(156, 39, 176, 0.5)',
                    borderColor: 'rgba(156, 39, 176, 0.8)',
                    borderWidth: 1
                },
                {
                    label: 'Skuteƒçn√© n√°klady',
                    data: [],
                    backgroundColor: 'rgba(76, 175, 80, 0.5)',
                    borderColor: 'rgba(76, 175, 80, 0.8)',
                    borderWidth: 1
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 3,
            plugins: {
                legend: {
                    display: true,
                    position: 'top',
                    labels: {
                        color: getComputedStyle(document.documentElement).getPropertyValue('--text-primary') || '#333',
                        font: {
                            size: 10
                        },
                        boxWidth: 12,
                        padding: 8
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) {
                                label += ': ';
                            }
                            label += context.parsed.y.toFixed(2) + ' Kƒç';
                            return label;
                        }
                    }
                }
            },
            scales: {
                x: {
                    ticks: {
                        color: getComputedStyle(document.documentElement).getPropertyValue('--text-secondary') || '#666',
                        font: {
                            size: 9
                        },
                        maxRotation: 45,
                        minRotation: 0
                    },
                    grid: {
                        display: false
                    }
                },
                y: {
                    beginAtZero: true,
                    ticks: {
                        color: getComputedStyle(document.documentElement).getPropertyValue('--text-secondary') || '#666',
                        font: {
                            size: 9
                        },
                        callback: function(value) {
                            return value.toFixed(0) + ' Kƒç';
                        }
                    },
                    grid: {
                        color: 'rgba(156, 39, 176, 0.1)'
                    }
                }
            }
        }
    });

    console.log('[Performance Chart] Initialized');
}

/**
 * Update performance tracking chart with latest data
 */
async function updatePerformanceChart() {
    const hass = getHass();
    if (!hass) return;

    const performanceSensorId = `sensor.oig_${INVERTER_SN}_battery_forecast_performance`;
    const performanceSensor = hass.states[performanceSensorId];

    // Check if sensor is available
    if (!performanceSensor || performanceSensor.state === 'unavailable' || performanceSensor.state === 'unknown') {
        console.log('[Performance Chart] Performance sensor not available');

        // Update summary with placeholder
        updateElementIfChanged('perf-accuracy', '--', 'perf-acc');
        updateElementIfChanged('perf-savings', '--', 'perf-sav');
        updateElementIfChanged('perf-days', '--', 'perf-days');

        return;
    }

    const attrs = performanceSensor.attributes || {};
    const dailyHistory = attrs.daily_history || [];
    const monthlySummary = attrs.monthly_summary || {};
    const today = attrs.today || {};
    const yesterday = attrs.yesterday || {};

    // Update summary stats
    const accuracy = monthlySummary.avg_accuracy || yesterday.accuracy || null;
    const totalSavings = monthlySummary.total_savings || 0;
    const daysTracked = monthlySummary.days_tracked || 0;

    updateElementIfChanged('perf-accuracy',
        accuracy !== null ? `${accuracy.toFixed(1)}%` : '--',
        'perf-acc');
    updateElementIfChanged('perf-savings',
        totalSavings > 0 ? `+${totalSavings.toFixed(1)} Kƒç` : totalSavings < 0 ? `${totalSavings.toFixed(1)} Kƒç` : '0 Kƒç',
        'perf-sav');
    updateElementIfChanged('perf-days',
        daysTracked > 0 ? `${daysTracked} dn√≠` : '--',
        'perf-days');

    // Update chart if initialized
    if (!performanceChart) {
        initPerformanceChart();
        if (!performanceChart) return;
    }

    // Prepare chart data (last 30 days)
    const last30Days = dailyHistory.slice(-30);

    const labels = [];
    const expectedData = [];
    const actualData = [];

    last30Days.forEach(day => {
        // Format date (DD.MM)
        const dateStr = day.date || '';
        const dateParts = dateStr.split('-');
        if (dateParts.length === 3) {
            labels.push(`${dateParts[2]}.${dateParts[1]}`);
        } else {
            labels.push(dateStr);
        }

        expectedData.push(day.expected || 0);
        actualData.push(day.actual || 0);
    });

    // Update chart data
    performanceChart.data.labels = labels;
    performanceChart.data.datasets[0].data = expectedData;
    performanceChart.data.datasets[1].data = actualData;

    // Update chart
    performanceChart.update('none'); // 'none' = no animation for performance

    console.log(`[Performance Chart] Updated with ${last30Days.length} days`);
}

// ============================================================================
// END PHASE 2.7
// ============================================================================

// Toggle ƒåHM√ö warning modal
function toggleChmuWarningModal() {
    const modal = document.getElementById('chmu-modal');
    if (!modal) return;

    if (modal.classList.contains('active')) {
        closeChmuWarningModal();
    } else {
        openChmuWarningModal();
    }
}

// Open ƒåHM√ö warning modal
function openChmuWarningModal() {
    const modal = document.getElementById('chmu-modal');
    const modalBody = document.getElementById('chmu-modal-body');

    if (!modal || !modalBody || !chmuWarningData) return;

    modal.classList.add('active');

    // Render modal content
    renderChmuWarningModal(modalBody);
}

// Close ƒåHM√ö warning modal
function closeChmuWarningModal(event) {
    const modal = document.getElementById('chmu-modal');
    if (!modal) return;

    // If event is provided, check if we clicked outside the content
    if (event && event.target !== modal) return;

    modal.classList.remove('active');
}

// Render ƒåHM√ö warning modal content
function renderChmuWarningModal(container) {
    if (!chmuWarningData || !container) return;

    const { local, global } = chmuWarningData;
    const attrs = local.attributes || {};
    const severity = parseInt(local.state) || 0;

    // If no warnings
    if (severity === 0) {
        container.innerHTML = `
            <div class="chmu-no-warnings">
                <div class="chmu-no-warnings-icon">‚òÄÔ∏è</div>
                <h4>≈Ω√°dn√° meteorologick√° v√Ωstraha</h4>
                <p>V souƒçasn√© dobƒõ nejsou aktivn√≠ ≈æ√°dn√° varov√°n√≠ pro v√°≈° region.</p>
            </div>
        `;
        return;
    }

    // Get warnings from new structure
    const allWarningsDetails = attrs.all_warnings_details || [];
    const topEventType = attrs.event_type;
    const topSeverity = attrs.severity;
    const topDescription = attrs.description;
    const topInstruction = attrs.instruction;
    const topOnset = attrs.onset;
    const topExpires = attrs.expires;
    const topEtaHours = attrs.eta_hours;

    if (allWarningsDetails.length === 0) {
        container.innerHTML = `
            <div class="chmu-no-warnings">
                <div class="chmu-no-warnings-icon">‚ùì</div>
                <h4>Data nejsou k dispozici</h4>
                <p>Varov√°n√≠ byla detekov√°na, ale detaily nejsou dostupn√©.</p>
            </div>
        `;
        return;
    }

    const icon = getWarningIcon(topEventType);
    const severityLabel = getSeverityLabel(severity);
    const onset = topOnset ? formatChmuDateTime(topOnset) : '--';
    const expires = topExpires ? formatChmuDateTime(topExpires) : '--';

    let etaText = '';
    if (topEtaHours !== null && topEtaHours !== undefined) {
        if (topEtaHours <= 0) {
            etaText = '<div class="chmu-info-item"><div class="chmu-info-icon">‚è±Ô∏è</div><div class="chmu-info-content"><div class="chmu-info-label">Status</div><div class="chmu-info-value" style="color: #ef4444; font-weight: 700;">PROB√çH√Å NYN√ç</div></div></div>';
        } else if (topEtaHours < 24) {
            etaText = `<div class="chmu-info-item"><div class="chmu-info-icon">‚è±Ô∏è</div><div class="chmu-info-content"><div class="chmu-info-label">Zaƒç√°tek za</div><div class="chmu-info-value">${Math.round(topEtaHours)} hodin</div></div></div>`;
        }
    }

    // TOP WARNING (hlavn√≠ sekce)
    let html = `
        <div class="chmu-warning-item chmu-warning-top severity-${severity}">
            <div class="chmu-warning-header">
                <div class="chmu-warning-icon">${icon}</div>
                <div class="chmu-warning-title">
                    <h4>${topEventType}</h4>
                    <span class="chmu-warning-severity severity-${severity}">${severityLabel}</span>
                </div>
            </div>

            <div class="chmu-warning-info">
                <div class="chmu-info-item">
                    <div class="chmu-info-icon">‚è∞</div>
                    <div class="chmu-info-content">
                        <div class="chmu-info-label">Zaƒç√°tek</div>
                        <div class="chmu-info-value">${onset}</div>
                    </div>
                </div>
                <div class="chmu-info-item">
                    <div class="chmu-info-icon">‚è≥</div>
                    <div class="chmu-info-content">
                        <div class="chmu-info-label">Konec</div>
                        <div class="chmu-info-value">${expires}</div>
                    </div>
                </div>
                ${etaText}
            </div>

            ${topDescription ? `
                <div class="chmu-warning-description">
                    <strong>üìã Popis</strong>
                    <p>${topDescription}</p>
                </div>
            ` : ''}

            ${topInstruction ? `
                <div class="chmu-warning-description">
                    <strong>üí° Doporuƒçen√≠</strong>
                    <p>${topInstruction}</p>
                </div>
            ` : ''}
        </div>
    `;

    // ALL WARNINGS (seznam v≈°ech aktivn√≠ch)
    if (allWarningsDetails.length > 1) {
        html += '<div class="chmu-all-warnings-header"><h5>üìã V≈°echny aktivn√≠ v√Ωstrahy</h5></div>';

        allWarningsDetails.forEach((warning, index) => {
            const wEventType = warning.event || 'Varov√°n√≠';
            const wSeverity = getSeverityLevelFromName(warning.severity);
            const wOnset = warning.onset ? formatChmuDateTime(warning.onset) : '--';
            const wExpires = warning.expires ? formatChmuDateTime(warning.expires) : '--';
            const wRegions = (warning.regions || []).join(', ') || 'Cel√° ƒåR';
            const wIcon = getWarningIcon(wEventType);
            const wSeverityLabel = warning.severity || 'Nezn√°m√°';

            html += `
                <div class="chmu-warning-item chmu-warning-compact severity-${wSeverity}">
                    <div class="chmu-warning-header">
                        <div class="chmu-warning-icon">${wIcon}</div>
                        <div class="chmu-warning-title">
                            <h5>${wEventType}</h5>
                            <span class="chmu-warning-severity severity-${wSeverity}">${wSeverityLabel}</span>
                        </div>
                    </div>
                    <div class="chmu-warning-info-compact">
                        <div class="chmu-info-row">
                            <span class="chmu-info-label">üìç Regiony:</span>
                            <span class="chmu-info-value">${wRegions}</span>
                        </div>
                        <div class="chmu-info-row">
                            <span class="chmu-info-label">‚è∞ Platnost:</span>
                            <span class="chmu-info-value">${wOnset} ‚Äì ${wExpires}</span>
                        </div>
                    </div>
                </div>
            `;
        });
    }

    container.innerHTML = html;
}

// Helper: Convert severity name to level
function getSeverityLevelFromName(severityName) {
    const map = {
        'Minor': 1,
        'Moderate': 2,
        'Severe': 3,
        'Extreme': 4
    };
    return map[severityName] || 1;
}

// Get icon for warning type
function getWarningIcon(eventType) {
    const icons = {
        'V√≠tr': 'üå™Ô∏è',
        'Siln√Ω v√≠tr': 'üí®',
        'D√©≈°≈•': 'üåßÔ∏è',
        'Siln√Ω d√©≈°≈•': '‚õàÔ∏è',
        'Sn√≠h': '‚ùÑÔ∏è',
        'Snƒõ≈æen√≠': 'üå®Ô∏è',
        'Bou≈ôky': '‚õàÔ∏è',
        'Mr√°z': 'ü•∂',
        'Vedro': 'üå°Ô∏è',
        'Mlha': 'üå´Ô∏è',
        'N√°led√≠': 'üßä',
        'Laviny': '‚ö†Ô∏è'
    };

    for (const [key, icon] of Object.entries(icons)) {
        if (eventType.includes(key)) return icon;
    }

    return '‚ö†Ô∏è';
}

// Get severity label
function getSeverityLabel(severity) {
    const labels = {
        1: 'Minor',
        2: 'Moderate',
        3: 'Severe',
        4: 'Extreme'
    };
    return labels[severity] || 'Unknown';
}

// Format ƒåHM√ö datetime
function formatChmuDateTime(isoString) {
    if (!isoString) return '--';

    try {
        const date = new Date(isoString);
        const day = date.getDate().toString().padStart(2, '0');
        const month = (date.getMonth() + 1).toString().padStart(2, '0');
        const hours = date.getHours().toString().padStart(2, '0');
        const minutes = date.getMinutes().toString().padStart(2, '0');

        return `${day}.${month}. ${hours}:${minutes}`;
    } catch (e) {
        return isoString;
    }
}

// ========================================================================
// MODE TIMELINE DIALOG - Phase 2.7
// ========================================================================

// === TIMELINE (moved to dashboard-timeline.js) ===
const MODE_CONFIG = window.DashboardTimeline.MODE_CONFIG;
const initTimelineDialog = window.DashboardTimeline.initTimelineDialog;
const openModeTimelineDialog = window.DashboardTimeline.openModeTimelineDialog;
const openTimelineDialog = window.DashboardTimeline.openTimelineDialog;
const closeModeTimelineDialog = window.DashboardTimeline.closeModeTimelineDialog;
const buildModeTimeline = window.DashboardTimeline.buildModeTimeline;
// =============================================================================
// TIMELINE DIALOG - Clean Implementation
// =============================================================================

/**
 * TimelineDialog Class - manages the timeline popup dialog
 * Clean lifecycle: init ‚Üí open ‚Üí render ‚Üí update ‚Üí close ‚Üí destroy
 */
class TimelineDialog {
    constructor() {
        this.dialogElement = null;
        this.isOpen = false;
        this.updateInterval = null;
        this.activeTab = 'today'; // Default tab - DNES
        this.cache = {
            yesterday: null,
            today: null,
            tomorrow: null,
            history: null
        };
    }

    /**
     * Initialize dialog - called once on page load
     */
    init() {
        this.dialogElement = document.getElementById('mode-timeline-dialog');
        if (!this.dialogElement) {
            console.error('[TimelineDialog] Dialog element not found');
            return;
        }

        // Attach event listeners
        this.attachEventListeners();
        console.log('[TimelineDialog] Initialized');
    }

    /**
     * Attach event listeners to dialog controls
     */
    attachEventListeners() {
        // Tab buttons
        const tabButtons = this.dialogElement.querySelectorAll('.timeline-tab-btn');
        tabButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                const tab = e.currentTarget.dataset.tab;
                this.switchTab(tab);
            });
        });

        // Close button
        const closeBtn = this.dialogElement.querySelector('.close-timeline-dialog');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => this.close());
        }

        // Click outside to close
        this.dialogElement.addEventListener('click', (e) => {
            if (e.target === this.dialogElement) {
                this.close();
            }
        });
    }

    /**
     * Open dialog and load data
     */
    async open() {
        if (this.isOpen) {
            console.log('[TimelineDialog] Already open');
            return;
        }

        console.log('[TimelineDialog] Opening...');
        this.isOpen = true;
        this.dialogElement.style.display = 'flex';

        // Load data for all tabs (parallel)
        await Promise.all([
            this.loadTabData('yesterday'),
            this.loadTabData('today'),
            this.loadTabData('tomorrow'),
            this.loadTabData('history')
        ]);

        // Switch to active tab (this will render + set CSS classes)
        this.switchTab(this.activeTab);

        // Start update interval (refresh every 60s)
        this.startUpdateInterval();
    }

    /**
     * Close dialog and cleanup
     */
    close() {
        console.log('[TimelineDialog] Closing...');
        this.isOpen = false;
        this.dialogElement.style.display = 'none';

        // Stop update interval
        this.stopUpdateInterval();
    }

    /**
     * Load data for specific tab from API
     */
    async loadTabData(dayType) {
        console.log(`[TimelineDialog] Loading ${dayType} data...`);

        try {
            const apiUrl = `/api/oig_cloud/battery_forecast/${INVERTER_SN}/timeline?type=active`;
            const response = await fetch(apiUrl);

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }

            const data = await response.json();
            const timelineData = data.timeline_extended;

            if (!timelineData) {
                throw new Error('No timeline_extended data');
            }

            // Cache the data
            this.cache[dayType] = timelineData[dayType];

            console.log(`[TimelineDialog] ${dayType} data loaded:`, this.cache[dayType]);

            // Extra debug for today
            if (dayType === 'today' && this.cache[dayType]?.intervals) {
                console.log(`[TimelineDialog] Today intervals count: ${this.cache[dayType].intervals.length}`);
                if (this.cache[dayType].intervals.length > 0) {
                    console.log('[TimelineDialog] First interval structure:', JSON.stringify(this.cache[dayType].intervals[0], null, 2));
                }
            }
        } catch (error) {
            console.error(`[TimelineDialog] Failed to load ${dayType} data:`, error);
            this.cache[dayType] = null;
        }
    }

    /**
     * Switch to different tab
     */
    switchTab(dayType) {
        console.log(`[TimelineDialog] Switching to ${dayType} tab`);

        // Update active tab
        this.activeTab = dayType;

        // Update tab buttons visual state
        const tabButtons = this.dialogElement.querySelectorAll('.timeline-tab-btn');
        console.log(`[TimelineDialog] Found ${tabButtons.length} tab buttons`);
        tabButtons.forEach(btn => {
            if (btn.dataset.tab === dayType) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        });

        // Update tab content visibility
        const allTabContents = this.dialogElement.querySelectorAll('.timeline-tab-content');
        console.log(`[TimelineDialog] Found ${allTabContents.length} tab contents`);
        allTabContents.forEach(content => {
            content.classList.remove('active');
        });

        const activeContent = document.getElementById(`timeline-${dayType}-content`);
        console.log(`[TimelineDialog] Active content element:`, activeContent);
        if (activeContent) {
            activeContent.classList.add('active');
            console.log(`[TimelineDialog] Added 'active' class to timeline-${dayType}-content`);
        }

        // Render the tab
        this.renderTab(dayType);
    }

    /**
     * Render specific tab based on dayType
     */
    renderTab(dayType) {
        console.log(`[TimelineDialog] Rendering ${dayType} tab`);

        const data = this.cache[dayType];
        const containerId = `${dayType}-timeline-container`;
        const container = document.getElementById(containerId);

        if (!container) {
            console.error(`[TimelineDialog] Container ${containerId} not found`);
            return;
        }

        if (!data || !data.intervals || data.intervals.length === 0) {
            container.innerHTML = this.renderNoData(dayType);
            return;
        }

        // Render based on tab type
        if (dayType === 'yesterday') {
            container.innerHTML = this.renderYesterdayTab(data);
            // Initialize charts after DOM is ready
            setTimeout(() => this.initializeYesterdayCharts(data.intervals, dayType), 0);
        } else if (dayType === 'today') {
            container.innerHTML = this.renderTodayTab(data);
            // Initialize charts after DOM is ready
            setTimeout(() => this.initializeTodayCharts(data.intervals, dayType), 0);
        } else if (dayType === 'tomorrow') {
            container.innerHTML = this.renderTomorrowTab(data);
        } else if (dayType === 'history') {
            container.innerHTML = this.renderHistoryTab(data);
        }
    }

    /**
     * Render "No Data" message
     */
    renderNoData(dayType) {
        const messages = {
            yesterday: 'Vƒçerej≈°√≠ data nejsou k dispozici',
            today: 'Dne≈°n√≠ data nejsou k dispozici',
            tomorrow: 'Pl√°n pro z√≠t≈ôek je≈°tƒõ nen√≠ k dispozici',
            history: 'Historick√° data nejsou k dispozici'
        };

        return `
            <div class="no-data" style="padding: 60px 20px; text-align: center;">
                <div style="font-size: 3em; margin-bottom: 20px;">üìä</div>
                <h3 style="color: var(--text-secondary); margin-bottom: 10px;">
                    ${messages[dayType] || 'Data nejsou k dispozici'}
                </h3>
            </div>
        `;
    }
    /**
     * Render VƒåERA tab - Plan vs Actual comparison
     */
    renderYesterdayTab(data) {
        const { intervals, summary } = data;

        // F√ÅZE 2: Use BE data if available
        if (summary && summary.mode_groups && summary.mode_adherence_pct !== undefined) {
            console.log('[TimelineDialog VƒåERA] Using BE mode statistics:', {
                mode_groups: summary.mode_groups.length,
                adherence: summary.mode_adherence_pct,
                top_variances: summary.top_variances?.length || 0
            });

            return `
                ${this.renderYesterdayHeaderBE(summary)}
                ${this.renderYesterdayModeGroupsBE(summary.mode_groups)}
                ${this.renderTopVariancesBE(summary.top_variances || [])}
            `;
        }

        // Fallback: FE calculation (backward compatibility)
        console.log('[TimelineDialog VƒåERA] Using FE calculations (BE data not available)');
        const stats = this.calculateStats(intervals);
        const topVariances = this.getTopVariances(intervals, 3);

        const enhancedSummary = {
            ...summary,
            mode_adherence_pct: stats.adherence,
            mode_matches: stats.modeMatches,
            total_intervals: stats.totalIntervals,
            biggest_variance: topVariances.length > 0 ? topVariances[0] : null
        };

        return `
            ${this.renderYesterdayHeader(enhancedSummary)}
            ${this.renderYesterdayIntervalAnalysis(intervals)}
            ${this.renderTopVariances(topVariances)}
            ${this.renderVarianceChart(intervals, 'yesterday')}
        `;
    }

    /**
     * Render VƒåERA header from BE data (F√ÅZE 2)
     */
    renderYesterdayHeaderBE(summary) {
        const plannedCost = summary.plan_total_cost || 0;
        const actualCost = summary.actual_total_cost || 0;
        const deltaCost = summary.delta || 0;
        const deltaPercent = summary.vs_plan_pct || 0;
        const modeAdherence = summary.mode_adherence_pct || 0;

        // Calculate total intervals from mode_groups
        const totalIntervals = summary.mode_groups?.reduce((sum, g) => sum + (g.interval_count || 0), 0) || 96;
        const totalMatches = summary.mode_groups?.reduce((sum, g) => sum + (g.mode_matches || 0), 0) || 0;

        return `
            <div class="today-header-cards">
                <div class="header-progress-large">
                    <div class="progress-bar-gradient">
                        <div class="progress-fill-gradient" style="width: ${modeAdherence}%"></div>
                        <div class="progress-label-overlay">${modeAdherence.toFixed(0)}% shoda re≈æim≈Ø</div>
                    </div>
                </div>

                <div class="metric-cards-grid">
                    <div class="metric-card card-completed">
                        <div class="card-header">
                            <span class="card-icon">üí∞</span>
                            <span class="card-title">Pl√°n</span>
                        </div>
                        <div class="card-body">
                            <div class="card-main-value">${plannedCost.toFixed(2)} Kƒç</div>
                            <div class="card-details">
                                <span class="detail-item">${totalIntervals} interval≈Ø</span>
                            </div>
                        </div>
                    </div>

                    <div class="metric-card card-active">
                        <div class="card-header">
                            <span class="card-icon">üí∏</span>
                            <span class="card-title">Skuteƒçnost</span>
                        </div>
                        <div class="card-body">
                            <div class="card-main-value">${actualCost.toFixed(2)} Kƒç</div>
                            <div class="card-details">
                                <span class="detail-item">re≈æimy OK ${totalMatches}/${totalIntervals}</span>
                            </div>
                        </div>
                    </div>

                    <div class="metric-card card-eod">
                        <div class="card-header">
                            <span class="card-icon">üìä</span>
                            <span class="card-title">V√Ωsledek</span>
                        </div>
                        <div class="card-body">
                            <div class="card-main-value">${deltaCost > 0 ? '+' : ''}${deltaCost.toFixed(2)} Kƒç</div>
                            <div class="card-details">
                                <span class="detail-separator">‚Ä¢</span>
                                <span class="detail-delta ${deltaPercent < -2 ? 'positive' : deltaPercent > 2 ? 'negative' : 'neutral'}">
                                    ${deltaPercent > 0 ? '+' : ''}${deltaPercent.toFixed(1)}%
                                </span>
                                <span class="detail-separator">‚Ä¢</span>
                                <span class="detail-item">${deltaCost < 0 ? 'lep≈°√≠' : deltaCost > 0 ? 'hor≈°√≠' : 'na pl√°nu'}</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    /**
     * Render mode groups from BE data (F√ÅZE 2)
     */
    renderYesterdayModeGroupsBE(groups) {
        if (!groups || groups.length === 0) {
            return '<div class="interval-section"><p>≈Ω√°dn√© skupiny</p></div>';
        }

        const modeIcons = {
            'HOME I': 'üè†',
            'HOME II': '‚ö°',
            'HOME III': 'üîã',
            'HOME UPS': '‚ö°'
        };

        const rows = groups.map(group => {
            const delta = group.delta || 0;
            const deltaClass = delta < -0.5 ? 'positive' : delta > 0.5 ? 'negative' : 'neutral';
            const icon = modeIcons[group.mode] || 'üéØ';
            const adherence = group.adherence_pct || 0;

            return `
                <div class="interval-section">
                    <div class="section-header">
                        <span class="section-icon">${icon}</span>
                        <span class="section-title">${group.mode}</span>
                        <span class="section-meta">
                            <span class="meta-item">‚è±Ô∏è ${group.interval_count}√ó15min</span>
                            <span class="meta-item">üí∞ ${group.actual_cost.toFixed(2)} Kƒç</span>
                            <span class="meta-item ${deltaClass}">‚ñ≥ ${delta > 0 ? '+' : ''}${delta.toFixed(2)} Kƒç</span>
                            <span class="meta-item">‚úÖ ${adherence.toFixed(0)}% shoda</span>
                        </span>
                    </div>
                </div>
            `;
        }).join('');

        return rows;
    }

    /**
     * Render top variances from BE data (F√ÅZE 2)
     */
    renderTopVariancesBE(variances) {
        if (!variances || variances.length === 0) {
            return '';
        }

        const rows = variances.map((v, idx) => {
            const deltaClass = v.variance < 0 ? 'positive' : 'negative';
            const icon = v.variance < 0 ? '‚úÖ' : '‚ùå';

            return `
                <div class="variance-row">
                    <span class="variance-rank">#${idx + 1}</span>
                    <span class="variance-time">${v.time}</span>
                    <span class="variance-planned">Pl√°n: ${v.planned} Kƒç</span>
                    <span class="variance-actual">Skuteƒçnost: ${v.actual} Kƒç</span>
                    <span class="variance-delta ${deltaClass}">${icon} ${v.variance > 0 ? '+' : ''}${v.variance} Kƒç (${v.variance_pct > 0 ? '+' : ''}${v.variance_pct}%)</span>
                </div>
            `;
        }).join('');

        return `
            <div class="interval-section collapsible collapsed">
                <div class="section-header" onclick="toggleSection('top-variances-be')">
                    <span class="section-icon">üìä</span>
                    <span class="section-title">TOP 3 ODCHYLKY</span>
                    <span class="section-toggle">‚ñ∂</span>
                </div>
                <div class="interval-list" id="top-variances-be" style="display: none;">
                    ${rows}
                </div>
            </div>
        `;
    }

    /**
     * Render card-based header for VƒåERA tab (v2.2 Dark) - FE fallback
     */
    renderYesterdayHeader(summary) {
        const plannedCost = summary?.planned_total_cost || 0;
        const actualCost = summary?.actual_total_cost || 0;
        const deltaCost = actualCost - plannedCost;
        const deltaPercent = plannedCost > 0 ? ((deltaCost / plannedCost) * 100) : 0;

        const modeAdherence = summary?.mode_adherence_pct || 0;
        const modeMatches = summary?.mode_matches || 0;
        const totalIntervals = summary?.total_intervals || 96;

        return `
            <div class="today-header-cards">
                <div class="header-progress-large">
                    <div class="progress-bar-gradient">
                        <div class="progress-fill-gradient" style="width: ${modeAdherence}%"></div>
                        <div class="progress-label-overlay">${modeAdherence.toFixed(0)}% shoda re≈æim≈Ø</div>
                    </div>
                </div>

                <div class="metric-cards-grid">
                    <div class="metric-card card-completed">
                        <div class="card-header">
                            <span class="card-icon">üí∞</span>
                            <span class="card-title">Pl√°n</span>
                        </div>
                        <div class="card-body">
                            <div class="card-main-value">${plannedCost.toFixed(2)} Kƒç</div>
                            <div class="card-details">
                                <span class="detail-item">${totalIntervals} interval≈Ø</span>
                            </div>
                        </div>
                    </div>

                    <div class="metric-card card-active">
                        <div class="card-header">
                            <span class="card-icon">üí∏</span>
                            <span class="card-title">Skuteƒçnost</span>
                        </div>
                        <div class="card-body">
                            <div class="card-main-value">${actualCost.toFixed(2)} Kƒç</div>
                            <div class="card-details">
                                <span class="detail-item">re≈æimy OK ${modeMatches}/${totalIntervals}</span>
                            </div>
                        </div>
                    </div>

                    <div class="metric-card card-eod">
                        <div class="card-header">
                            <span class="card-icon">üìä</span>
                            <span class="card-title">V√Ωsledek</span>
                        </div>
                        <div class="card-body">
                            <div class="card-main-value">${deltaCost > 0 ? '+' : ''}${deltaCost.toFixed(2)} Kƒç</div>
                            <div class="card-details">
                                <span class="detail-separator">‚Ä¢</span>
                                <span class="detail-delta ${deltaPercent < -2 ? 'positive' : deltaPercent > 2 ? 'negative' : 'neutral'}">
                                    ${deltaPercent > 0 ? '+' : ''}${deltaPercent.toFixed(1)}%
                                </span>
                                <span class="detail-separator">‚Ä¢</span>
                                <span class="detail-item">${deltaCost < 0 ? 'lep≈°√≠' : deltaCost > 0 ? 'hor≈°√≠' : 'na pl√°nu'}</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    /**
     * Render interval analysis for VƒåERA tab - grouped by mode with variance details
     */
    renderYesterdayIntervalAnalysis(intervals) {
        // Group intervals by mode (both planned and actual)
        const modeGroups = {};

        intervals.forEach(interval => {
            const plannedMode = interval.planned?.mode_name || 'Unknown';
            const actualMode = interval.actual?.mode_name || 'Unknown';

            if (!modeGroups[plannedMode]) {
                modeGroups[plannedMode] = {
                    mode: plannedMode,
                    intervals: [],
                    totalPlanned: 0,
                    totalActual: 0,
                    matchCount: 0,
                    mismatchCount: 0
                };
            }

            const costPlanned = interval.planned?.net_cost || 0;
            const costActual = interval.actual?.net_cost || 0;
            const matched = plannedMode === actualMode;

            modeGroups[plannedMode].intervals.push(interval);
            modeGroups[plannedMode].totalPlanned += costPlanned;
            modeGroups[plannedMode].totalActual += costActual;
            if (matched) modeGroups[plannedMode].matchCount++;
            else modeGroups[plannedMode].mismatchCount++;
        });        // Sort by total cost (highest first)
        const sortedGroups = Object.values(modeGroups).sort((a, b) => b.totalPlanned - a.totalPlanned);

        const modeEmojis = {
            'Balancer': '‚öñÔ∏è',
            'PV_to_Grid': '‚òÄÔ∏è',
            'Grid_Charging': 'üîå',
            'Export_Peak': 'üì§',
            'Import_Only': 'üì•',
            'Self_Consumption': 'üîã'
        };

        const groupsHtml = sortedGroups.map(group => {
            const delta = group.totalActual - group.totalPlanned;
            const adherence = group.intervals.length > 0 ? (group.matchCount / group.intervals.length * 100) : 0;
            const deltaPercent = group.totalPlanned > 0 ? (delta / group.totalPlanned * 100) : 0;
            const emoji = modeEmojis[group.mode] || 'üéØ';

            return `
                <div class="interval-group">
                    <div class="interval-group-header">
                        <div class="interval-group-mode">
                            <span class="mode-emoji">${emoji}</span>
                            <span class="mode-name">${group.mode}</span>
                            <span class="mode-count">${group.intervals.length} interval≈Ø</span>
                        </div>
                        <div class="interval-group-stats">
                            <div class="stat-item">
                                <span class="stat-label">Pl√°n:</span>
                                <span class="stat-value">${group.totalPlanned.toFixed(2)} Kƒç</span>
                            </div>
                            <div class="stat-item">
                                <span class="stat-label">Skuteƒçnost:</span>
                                <span class="stat-value">${group.totalActual.toFixed(2)} Kƒç</span>
                            </div>
                            <div class="stat-item ${delta < 0 ? 'positive' : delta > 0 ? 'negative' : 'neutral'}">
                                <span class="stat-label">Delta:</span>
                                <span class="stat-value">${delta > 0 ? '+' : ''}${delta.toFixed(2)} Kƒç (${deltaPercent > 0 ? '+' : ''}${deltaPercent.toFixed(1)}%)</span>
                            </div>
                            <div class="stat-item ${adherence >= 80 ? 'positive' : adherence >= 50 ? 'neutral' : 'negative'}">
                                <span class="stat-label">Shoda re≈æim≈Ø:</span>
                                <span class="stat-value">${adherence.toFixed(0)}% (${group.matchCount}/${group.intervals.length})</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }).join('');

        return `
            <div class="yesterday-interval-analysis">
                <h4>üìã Anal√Ωza interval≈Ø podle re≈æim≈Ø</h4>
                <div class="interval-groups">
                    ${groupsHtml}
                </div>
            </div>
        `;
    }

    /**
     * Render DNES tab - Live tracking + EOD prediction
     */
    renderTodayTab(data) {
        const { intervals, summary } = data;

        // Split into historical and planned
        const now = new Date();
        const historical = intervals.filter(i => i.status === 'historical' || i.status === 'current');
        const planned = intervals.filter(i => i.status === 'planned');

        // Calculate current progress
        const progress = this.calculateProgress(intervals);

        // Calculate EOD prediction
        const eodPrediction = this.calculateEODPrediction(intervals);

        // Load unified_cost_tile data (v2.1)
        let unifiedCostData = null;
        try {
            const hass = getHass();
            const forecastSensorId = `sensor.oig_${INVERTER_SN}_battery_forecast`;
            if (hass && hass.states && hass.states[forecastSensorId]) {
                const forecastState = hass.states[forecastSensorId];
                if (forecastState.attributes && forecastState.attributes.unified_cost_tile) {
                    unifiedCostData = forecastState.attributes.unified_cost_tile.today;
                    console.log('[TimelineDialog DNES] Loaded unified_cost_tile data', unifiedCostData);
                }
            }
        } catch (error) {
            console.warn('[TimelineDialog DNES] Could not load unified_cost_tile:', error);
        }

        return `
            <div class="today-content">
                ${unifiedCostData ? this.renderTodayHeaderBE(unifiedCostData) : ''}
                ${this.renderTodayIntervals(intervals, unifiedCostData)}
            </div>
        `;
    }

    /**
     * Render DNES header from BE data (F√ÅZE 1)
     */
    renderTodayHeaderBE(data) {
        const eodPredicted = data.eod_prediction?.predicted_total || 0;
        const eodPlan = data.plan_total_cost || 0;
        const eodVsPlan = data.eod_prediction?.vs_plan || 0;
        const eodVsPlanPct = data.vs_plan_pct || 0;

        const actualSoFar = data.actual_total_cost || 0;
        const planSoFar = data.completed_so_far?.planned_cost || 0;
        const deltaSoFar = data.completed_so_far?.delta_cost || 0;
        const deltaSoFarPct = data.completed_so_far?.delta_pct || 0;

        const predictedSavings = data.eod_prediction?.predicted_savings || 0;
        const plannedSavings = data.eod_prediction?.planned_savings || 0;

        const progressPct = data.progress_pct || 0;

        return `
            <div class="today-header-cards">
                <div class="header-progress-large">
                    <div class="progress-bar-gradient">
                        <div class="progress-fill-gradient" style="width: ${progressPct}%"></div>
                        <div class="progress-label-overlay">${progressPct.toFixed(0)}% dne ‚Ä¢ ${new Date().toLocaleTimeString('cs-CZ', {hour: '2-digit', minute: '2-digit'})}</div>
                    </div>
                </div>

                <div class="metric-cards-grid">
                    <div class="metric-card card-completed">
                        <div class="card-header">
                            <span class="card-icon">üí∞</span>
                            <span class="card-title">Odhad n√°klad≈Ø na konec dne</span>
                        </div>
                        <div class="card-body">
                            <div class="card-main-value">${eodPredicted.toFixed(2)} Kƒç</div>
                            <div class="card-details">
                                <span class="detail-item">pl√°n: ${eodPlan.toFixed(2)} Kƒç</span>
                                <span class="detail-separator">‚Ä¢</span>
                                <span class="detail-delta ${eodVsPlanPct < -2 ? 'positive' : eodVsPlanPct > 2 ? 'negative' : 'neutral'}">
                                    ${eodVsPlanPct > 0 ? '+' : ''}${eodVsPlanPct.toFixed(1)}%
                                </span>
                            </div>
                        </div>
                    </div>

                    <div class="metric-card card-active">
                        <div class="card-header">
                            <span class="card-icon">üìä</span>
                            <span class="card-title">Dosud skuteƒçnƒõ</span>
                        </div>
                        <div class="card-body">
                            <div class="card-main-value">${actualSoFar.toFixed(2)} Kƒç</div>
                            <div class="card-details">
                                <span class="detail-item">pl√°n: ${planSoFar.toFixed(2)} Kƒç</span>
                                <span class="detail-separator">‚Ä¢</span>
                                <span class="detail-delta ${deltaSoFarPct < -2 ? 'positive' : deltaSoFarPct > 2 ? 'negative' : 'neutral'}">
                                    ${deltaSoFarPct > 0 ? '+' : ''}${deltaSoFarPct.toFixed(1)}%
                                </span>
                            </div>
                        </div>
                    </div>

                    <div class="metric-card card-eod">
                        <div class="card-header">
                            <span class="card-icon">üíé</span>
                            <span class="card-title">P≈ôedpokl√°dan√° √∫spora</span>
                        </div>
                        <div class="card-body">
                            <div class="card-main-value">${predictedSavings.toFixed(2)} Kƒç</div>
                            <div class="card-details">
                                <span class="detail-item">vs. HOME I re≈æim</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    /**
     * Group 15-min intervals into time blocks by mode (HOME regime changes)
     */
    groupIntervalsByMode(intervals) {
        if (intervals.length === 0) return [];

        const groups = [];
        let currentGroup = null;

        intervals.forEach((interval, idx) => {
            // Normalize mode name (trim whitespace)
            const rawMode = interval.planned?.mode_name || interval.actual?.mode_name || '?';
            const mode = rawMode.trim();

            if (!currentGroup || currentGroup.mode !== mode) {
                // Start new group
                currentGroup = {
                    mode: mode,
                    intervals: [interval],
                    startTime: interval.time,
                    endTime: interval.time
                };
                groups.push(currentGroup);
            } else {
                // Add to existing group
                currentGroup.intervals.push(interval);
                currentGroup.endTime = interval.time;
            }
        });

        console.log(`[TimelineDialog] Grouped ${intervals.length} intervals into ${groups.length} groups by mode`);

        return groups;
    }

    /**
     * Render intervals for DNES tab (v2.1 compact format)
     * F√ÅZE 1-3: Now uses BE grouped data
     */
    renderTodayIntervals(intervals, unifiedCostData) {
        const now = new Date();

        // F√ÅZE 1: Use BE grouped data if available
        if (unifiedCostData && unifiedCostData.completed_groups && unifiedCostData.future_groups) {
            console.log('[TimelineDialog DNES] Using BE grouped data:', {
                completed: unifiedCostData.completed_groups.length,
                active: unifiedCostData.active_group ? 1 : 0,
                future: unifiedCostData.future_groups.length
            });

            return `
                ${this.renderCompletedIntervalGroupsBE(unifiedCostData.completed_groups)}
                ${unifiedCostData.active_group ? this.renderActiveIntervalBE(unifiedCostData.active_group) : ''}
                ${this.renderFutureIntervalGroupsBE(unifiedCostData.future_groups)}
            `;
        }

        // Fallback to FE grouping (backward compatibility)
        console.log('[TimelineDialog DNES] BE grouped data not available, using FE grouping');

        // Separate intervals by status
        const completed = [];
        let active = null;
        const future = [];

        intervals.forEach(interval => {
            const status = interval.status;

            if (status === 'historical') {
                completed.push(interval);
            } else if (status === 'current') {
                active = interval;
            } else {
                future.push(interval);
            }
        });

        console.log(`[TimelineDialog] Separated intervals: completed=${completed.length}, active=${active ? 1 : 0}, future=${future.length}`);

        // Group intervals by mode (HOME regime changes)
        const completedGroups = this.groupIntervalsByMode(completed);
        const futureGroups = this.groupIntervalsByMode(future);

        // Get active interval data from unifiedCostData
        const activeIntervalData = unifiedCostData?.active_interval;

        return `
            ${this.renderCompletedIntervalGroups(completedGroups)}
            ${active ? this.renderActiveInterval(active, activeIntervalData) : ''}
            ${this.renderFutureIntervalGroups(futureGroups, unifiedCostData)}
        `;
    }

    /**
     * Render completed interval groups - compact one-line format
     */
    renderCompletedIntervalGroups(groups) {
        if (groups.length === 0) {
            return '<div class="interval-section"><p>≈Ω√°dn√© uplynul√© intervaly</p></div>';
        }

        const totalIntervals = groups.reduce((sum, g) => sum + g.intervals.length, 0);

        // Calculate aggregated values
        const totalActualCost = groups.reduce((sum, g) => {
            return sum + g.intervals.reduce((s, iv) => s + (iv.actual?.net_cost || 0), 0);
        }, 0);

        const totalPlannedCost = groups.reduce((sum, g) => {
            return sum + g.intervals.reduce((s, iv) => s + (iv.planned?.net_cost || 0), 0);
        }, 0);

        const totalSavings = groups.reduce((sum, g) => {
            return sum + g.intervals.reduce((s, iv) => s + (iv.actual?.savings || 0), 0);
        }, 0);

        const totalDelta = totalActualCost - totalPlannedCost;
        const totalDeltaPct = totalPlannedCost > 0 ? ((totalDelta / totalPlannedCost) * 100) : 0;
        const deltaClass = totalDelta < -0.5 ? 'positive' : totalDelta > 0.5 ? 'negative' : 'neutral';

        const rows = groups.map((group, idx) => {
            const startTime = new Date(group.startTime);
            const endTime = new Date(group.endTime);

            // Calculate end time + 15 minutes for the range
            const rangeEnd = new Date(endTime.getTime() + 15 * 60 * 1000);

            const startStr = `${startTime.getHours().toString().padStart(2, '0')}:${startTime.getMinutes().toString().padStart(2, '0')}`;
            const endStr = `${rangeEnd.getHours().toString().padStart(2, '0')}:${rangeEnd.getMinutes().toString().padStart(2, '0')}`;
            const timeRange = `${startStr} - ${endStr}`;

            const mode = group.mode;
            const modeIcon = mode.includes('HOME I') ? 'üè†' : mode.includes('HOME UPS') ? '‚ö°' : 'üîã';

            // Sum costs across all intervals in group
            const actualCost = group.intervals.reduce((sum, iv) => sum + (iv.actual?.net_cost || 0), 0);
            const plannedCost = group.intervals.reduce((sum, iv) => sum + (iv.planned?.net_cost || 0), 0);
            const actualSavings = group.intervals.reduce((sum, iv) => sum + (iv.actual?.savings || 0), 0);

            const delta = actualCost - plannedCost;
            const deltaPct = plannedCost > 0 ? ((delta / plannedCost) * 100) : 0;

            const deltaClass = delta < -0.5 ? 'positive' : delta > 0.5 ? 'negative' : 'neutral';
            const deltaIcon = delta < -0.5 ? '‚úÖ' : delta > 0.5 ? '‚ùå' : '‚ö™';

            const intervalCount = group.intervals.length;

            return `
                <div class="interval-row completed" data-interval-id="${idx}">
                    <div class="interval-summary" onclick="toggleIntervalDetail(${idx})">
                        <span class="interval-time">${timeRange}</span>
                        <span class="interval-mode">${modeIcon} ${mode}</span>
                        <span class="interval-count">(${intervalCount}√ó15min)</span>
                        <span class="interval-cost ${deltaClass}">${actualCost.toFixed(2)} Kƒç</span>
                        <span class="interval-delta ${deltaClass}">${deltaIcon} ${Math.abs(deltaPct).toFixed(0)}%</span>
                        <span class="interval-toggle">‚ñº</span>
                    </div>
                    <div class="interval-detail" id="interval-detail-${idx}" style="display: none;">
                        <div class="detail-grid">
                            <div class="detail-item">
                                <span class="detail-label">‚è±Ô∏è Trv√°n√≠:</span>
                                <span class="detail-value">${intervalCount} √ó 15 min = ${(intervalCount * 15)} min</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">üí∞ N√°klady:</span>
                                <span class="detail-value">${actualCost.toFixed(2)} Kƒç skuteƒçnƒõ <span class="detail-plan">(pl√°n: ${plannedCost.toFixed(2)} Kƒç)</span></span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">üíé √öspora:</span>
                                <span class="detail-value">${actualSavings.toFixed(2)} Kƒç</span>
                            </div>
                            <div class="detail-item">
                                <span class="detail-label">üìä Delta:</span>
                                <span class="detail-value ${deltaClass}">${delta > 0 ? '+' : ''}${delta.toFixed(2)} Kƒç (${deltaPct > 0 ? '+' : ''}${deltaPct.toFixed(1)}%)</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }).join('');

        return `
            <div class="interval-section collapsible collapsed">
                <div class="section-header" onclick="toggleSection('completed-intervals')">
                    <span class="section-icon">‚úÖ</span>
                    <span class="section-title">UPLYNUL√â</span>
                    <span class="section-meta">
                        <span class="meta-item">üí∞ ${totalActualCost.toFixed(2)} Kƒç</span>
                        <span class="meta-item">üíé ${totalSavings.toFixed(2)} Kƒç</span>
                        <span class="meta-item ${deltaClass}">‚úÖ ${totalDelta > 0 ? '+' : ''}${totalDelta.toFixed(2)} Kƒç (${totalDeltaPct > 0 ? '+' : ''}${totalDeltaPct.toFixed(0)}%)</span>
                    </span>
                    <span class="section-toggle">‚ñ∂</span>
                </div>
                <div class="interval-list" id="completed-intervals" style="display: none;">
                    ${rows}
                </div>
            </div>
        `;
    }

    /**
     * Render completed interval groups from BE data (F√ÅZE 1)
     */
    renderCompletedIntervalGroupsBE(groups) {
        if (!groups || groups.length === 0) {
            return '<div class="interval-section"><p>≈Ω√°dn√© uplynul√© intervaly</p></div>';
        }

        const totalActualCost = groups.reduce((sum, g) => sum + (g.actual_cost || 0), 0);
        const totalPlannedCost = groups.reduce((sum, g) => sum + (g.planned_cost || 0), 0);
        const totalDelta = groups.reduce((sum, g) => sum + (g.delta || 0), 0);
        const totalDeltaPct = totalPlannedCost > 0 ? ((totalDelta / totalPlannedCost) * 100) : 0;
        const deltaClass = totalDelta < -0.5 ? 'positive' : totalDelta > 0.5 ? 'negative' : 'neutral';

        const rows = groups.map((group, idx) => {
            const deltaClass = group.delta < -0.5 ? 'positive' : group.delta > 0.5 ? 'negative' : 'neutral';
            const deltaIcon = group.delta < -0.5 ? '‚úÖ' : group.delta > 0.5 ? '‚ùå' : '‚ö™';
            const modeIcon = group.mode.includes('HOME I') ? 'üè†' : group.mode.includes('HOME UPS') ? '‚ö°' : 'üîã';

            return `
                <div class="interval-row completed">
                    <div class="interval-summary">
                        <span class="interval-time">${group.start_time} - ${group.end_time}</span>
                        <span class="interval-mode">${modeIcon} ${group.mode}</span>
                        <span class="interval-count">(${group.interval_count}√ó15min)</span>
                        <span class="interval-cost ${deltaClass}">${group.actual_cost.toFixed(2)} Kƒç</span>
                        <span class="interval-delta ${deltaClass}">${deltaIcon} ${Math.abs(group.delta_pct || 0).toFixed(0)}%</span>
                    </div>
                </div>
            `;
        }).join('');

        return `
            <div class="interval-section collapsible collapsed">
                <div class="section-header" onclick="toggleSection('completed-intervals-be')">
                    <span class="section-icon">‚úÖ</span>
                    <span class="section-title">UPLYNUL√â</span>
                    <span class="section-meta">
                        <span class="meta-item">üí∞ ${totalActualCost.toFixed(2)} Kƒç</span>
                        <span class="meta-item ${deltaClass}">‚ñ≥ ${totalDelta > 0 ? '+' : ''}${totalDelta.toFixed(2)} Kƒç</span>
                    </span>
                    <span class="section-toggle">‚ñ∂</span>
                </div>
                <div class="interval-list" id="completed-intervals-be" style="display: none;">
                    ${rows}
                </div>
            </div>
        `;
    }

    /**
     * Render active interval from BE data (F√ÅZE 1)
     */
    renderActiveIntervalBE(group) {
        const modeIcon = group.mode.includes('HOME I') ? 'üè†' : group.mode.includes('HOME UPS') ? '‚ö°' : 'üîã';
        const plannedCost = group.planned_cost || 0;
        const actualCost = group.actual_cost || 0;
        const progress = 50; // Default mid-interval

        return `
            <div class="interval-section active">
                <div class="section-header">
                    <span class="section-icon">üî•</span>
                    <span class="section-title">AKTIVN√ç INTERVAL</span>
                </div>
                <div class="interval-list">
                    <div class="interval-row active-interval">
                        <div class="interval-summary">
                            <span class="interval-time">${group.start_time}</span>
                            <span class="interval-mode">${modeIcon} ${group.mode}</span>
                            <span class="interval-cost">${plannedCost.toFixed(2)} Kƒç pl√°n</span>
                            <span class="interval-progress">‚è≥ ${progress}%</span>
                        </div>
                        <div class="active-progress-bar">
                            <div class="progress-fill" style="width: ${progress}%"></div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    /**
     * Render future interval groups from BE data (F√ÅZE 1)
     */
    renderFutureIntervalGroupsBE(groups) {
        if (!groups || groups.length === 0) {
            return '<div class="interval-section"><p>≈Ω√°dn√© budouc√≠ intervaly</p></div>';
        }

        const totalPlannedCost = groups.reduce((sum, g) => sum + (g.planned_cost || 0), 0);
        const totalPlannedSavings = groups.reduce((sum, g) => sum + (g.planned_savings || 0), 0);

        const rows = groups.map((group, idx) => {
            const modeIcon = group.mode.includes('HOME I') ? 'üè†' : group.mode.includes('HOME UPS') ? '‚ö°' : 'üîã';
            const plannedSavings = group.planned_savings || 0;

            return `
                <div class="interval-row future">
                    <div class="interval-summary">
                        <span class="interval-time">${group.start_time} - ${group.end_time}</span>
                        <span class="interval-mode">${modeIcon} ${group.mode}</span>
                        <span class="interval-count">(${group.interval_count}√ó15min)</span>
                        <span class="interval-cost">${group.planned_cost.toFixed(2)} Kƒç</span>
                        ${plannedSavings > 0 ? `<span class="interval-savings">üíé ${plannedSavings.toFixed(2)} Kƒç</span>` : ''}
                    </div>
                </div>
            `;
        }).join('');

        return `
            <div class="interval-section collapsible collapsed">
                <div class="section-header" onclick="toggleSection('future-intervals-be')">
                    <span class="section-icon">üîÆ</span>
                    <span class="section-title">BUDOUC√ç PL√ÅN</span>
                    <span class="section-meta">
                        <span class="meta-item">üí∞ ${totalPlannedCost.toFixed(2)} Kƒç</span>
                        ${totalPlannedSavings > 0 ? `<span class="meta-item">üíé ${totalPlannedSavings.toFixed(2)} Kƒç</span>` : ''}
                    </span>
                    <span class="section-toggle">‚ñ∂</span>
                </div>
                <div class="interval-list" id="future-intervals-be" style="display: none;">
                    ${rows}
                </div>
            </div>
        `;
    }

    /**
     * Render active interval with progress bar
     */
    renderActiveInterval(interval, activeData) {
        const time = new Date(interval.time);
        const timeStr = `${time.getHours().toString().padStart(2, '0')}:${time.getMinutes().toString().padStart(2, '0')}`;

        const mode = interval.planned?.mode_name || '?';
        const modeIcon = mode.includes('HOME I') ? 'üè†' : mode.includes('HOME UPS') ? '‚ö°' : 'üîã';

        const plannedCost = interval.planned?.net_cost || 0;
        const progress = activeData?.progress_pct || 0;
        const actualCostSoFar = activeData?.actual_cost_so_far || 0;
        const expectedCost = activeData?.expected_cost_at_progress || 0;
        const costDelta = actualCostSoFar - expectedCost;
        const costDeltaPct = activeData?.cost_delta_pct || 0;

        const deltaClass = costDelta < -0.5 ? 'positive' : costDelta > 0.5 ? 'negative' : 'neutral';
        const deltaIcon = costDelta < -0.5 ? '‚úÖ' : costDelta > 0.5 ? '‚ùå' : '‚ö™';

        return `
            <div class="interval-section active">
                <div class="section-header">
                    <span class="section-icon">üî•</span>
                    <span class="section-title">AKTIVN√ç INTERVAL</span>
                    <span class="section-count">1 interval</span>
                </div>
                <div class="interval-list">
                    <div class="interval-row active-interval">
                        <div class="interval-summary">
                            <span class="interval-time">${timeStr}</span>
                            <span class="interval-mode">${modeIcon} ${mode}</span>
                            <span class="interval-cost">${plannedCost.toFixed(2)} Kƒç pl√°n</span>
                            <span class="interval-progress">‚è≥ ${progress.toFixed(0)}%</span>
                        </div>
                        <div class="active-progress-bar">
                            <div class="progress-fill" style="width: ${progress}%"></div>
                        </div>
                        <div class="active-details">
                            <span>Skuteƒçnƒõ dosud: ${actualCostSoFar.toFixed(2)} Kƒç (${progress.toFixed(0)}% pl√°nu) ${deltaIcon} ${costDeltaPct > 0 ? '+' : ''}${costDeltaPct.toFixed(1)}%</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }

    /**
     * Render future interval groups - minimalist format
     */
    renderFutureIntervalGroups(groups, unifiedCostData) {
        if (groups.length === 0) {
            return '';
        }

        const totalIntervals = groups.reduce((sum, g) => sum + g.intervals.length, 0);

        // Calculate aggregated planned costs for FUTURE intervals only
        const totalPlannedCost = groups.reduce((sum, g) => {
            return sum + g.intervals.reduce((s, iv) => s + (iv.planned?.net_cost || 0), 0);
        }, 0);

        const displayGroups = groups.slice(0, 20);  // Show first 20 groups

        const rows = displayGroups.map((group, idx) => {
            const startTime = new Date(group.startTime);
            const endTime = new Date(group.endTime);

            // Calculate end time + 15 minutes for the range
            const rangeEnd = new Date(endTime.getTime() + 15 * 60 * 1000);

            const startStr = `${startTime.getHours().toString().padStart(2, '0')}:${startTime.getMinutes().toString().padStart(2, '0')}`;
            const endStr = `${rangeEnd.getHours().toString().padStart(2, '0')}:${rangeEnd.getMinutes().toString().padStart(2, '0')}`;
            const timeRange = `${startStr} - ${endStr}`;

            const mode = group.mode;
            const modeIcon = mode.includes('HOME I') ? 'üè†' : mode.includes('HOME UPS') ? '‚ö°' : 'üîã';

            const plannedCost = group.intervals.reduce((sum, iv) => sum + (iv.planned?.net_cost || 0), 0);
            const plannedSavings = group.intervals.reduce((sum, iv) => sum + (iv.planned?.savings_vs_home_i || 0), 0);
            const intervalCount = group.intervals.length;

            return `
                <div class="interval-row future">
                    <div class="interval-summary">
                        <span class="interval-time">${timeRange}</span>
                        <span class="interval-mode">${modeIcon} ${mode}</span>
                        <span class="interval-count">(${intervalCount}√ó15min)</span>
                        <span class="interval-cost">${plannedCost.toFixed(2)} Kƒç</span>
                        ${plannedSavings > 0 ? `<span class="interval-savings">üíé ${plannedSavings.toFixed(2)} Kƒç</span>` : ''}
                    </div>
                </div>
            `;
        }).join('');

        const remaining = groups.length - 20;

        return `
            <div class="interval-section collapsible collapsed">
                <div class="section-header" onclick="toggleSection('future-intervals')">
                    <span class="section-icon">üìÖ</span>
                    <span class="section-title">BUDOUC√ç</span>
                    <span class="section-meta">
                        <span class="meta-item">üí∞ ${totalPlannedCost.toFixed(2)} Kƒç</span>
                    </span>
                    <span class="section-toggle">‚ñ∂</span>
                </div>
                <div class="interval-list" id="future-intervals" style="display: none;">
                    ${rows}
                    ${remaining > 0 ? `<div class="interval-row future muted">... a dal≈°√≠ch ${remaining} √∫sek≈Ø</div>` : ''}
                </div>
            </div>
        `;
    }

    /**
    /**
     * Render Z√çTRA tab - Tomorrow's plan with card design
     */
    renderTomorrowTab(data) {
        const { intervals, summary } = data;

        // Load unified_cost_tile.tomorrow data
        let tomorrowCostData = null;
        try {
            const hass = getHass();
            const forecastSensorId = `sensor.oig_${INVERTER_SN}_battery_forecast`;
            if (hass && hass.states && hass.states[forecastSensorId]) {
                const forecastState = hass.states[forecastSensorId];
                if (forecastState.attributes && forecastState.attributes.unified_cost_tile) {
                    tomorrowCostData = forecastState.attributes.unified_cost_tile.tomorrow;
                    console.log('[TimelineDialog Z√çTRA] Loaded unified_cost_tile.tomorrow data', tomorrowCostData);
                }
            }
        } catch (error) {
            console.warn('[TimelineDialog Z√çTRA] Could not load unified_cost_tile:', error);
        }

        // F√ÅZE 3: Use BE data if available
        if (tomorrowCostData && tomorrowCostData.mode_distribution && tomorrowCostData.dominant_mode_name) {
            console.log('[TimelineDialog Z√çTRA] Using BE mode distribution:', {
                total_modes: Object.keys(tomorrowCostData.mode_distribution).length,
                dominant: tomorrowCostData.dominant_mode_name,
                planned_groups: tomorrowCostData.planned_groups?.length || 0
            });

            return this.renderTomorrowTabBE(tomorrowCostData);
        }

        // Fallback: FE calculation (backward compatibility)
        console.log('[TimelineDialog Z√çTRA] Using FE calculations (BE data not available)');
        const plannedCost = summary?.planned_total_cost || 0;
        const intervalCount = intervals?.length || 0;

        // Calculate mode distribution
        const modeDistribution = {};
        intervals?.forEach(interval => {
            const mode = interval.planned?.mode || 'Unknown';
            modeDistribution[mode] = (modeDistribution[mode] || 0) + 1;
        });

        const topMode = Object.entries(modeDistribution)
            .sort((a, b) => b[1] - a[1])[0];
        const topModeName = topMode ? topMode[0] : 'N/A';
        const topModeCount = topMode ? topMode[1] : 0;
        const topModePct = intervalCount > 0 ? ((topModeCount / intervalCount) * 100) : 0;

        return `
            <div class="today-header-cards">
                <div class="header-progress-large">
                    <div class="progress-bar-gradient">
                        <div class="progress-fill-gradient" style="width: ${topModePct}%"></div>
                        <div class="progress-label-overlay">${topModeName} ${topModePct.toFixed(0)}%</div>
                    </div>
                </div>

                <div class="metric-cards-grid">
                    <div class="metric-card card-completed">
                        <div class="card-header">
                            <span class="card-icon">üí∞</span>
                            <span class="card-title">Pl√°novan√© n√°klady</span>
                        </div>
                        <div class="card-body">
                            <div class="card-main-value">${plannedCost.toFixed(2)} Kƒç</div>
                            <div class="card-details">
                                <span class="detail-item">${intervalCount} interval≈Ø</span>
                            </div>
                        </div>
                    </div>

                    <div class="metric-card card-active">
                        <div class="card-header">
                            <span class="card-icon">‚ö°</span>
                            <span class="card-title">Dominantn√≠ re≈æim</span>
                        </div>
                        <div class="card-body">
                            <div class="card-main-value" style="font-size: 1.5rem;">${topModeName}</div>
                            <div class="card-details">
                                <span class="detail-item">${topModeCount} interval≈Ø (${topModePct.toFixed(0)}%)</span>
                            </div>
                        </div>
                    </div>

                    <div class="metric-card card-eod">
                        <div class="card-header">
                            <span class="card-icon">üìä</span>
                            <span class="card-title">Re≈æimy celkem</span>
                        </div>
                        <div class="card-body">
                            <div class="card-main-value">${Object.keys(modeDistribution).length}</div>
                            <div class="card-details">
                                <span class="detail-item">r≈Øzn√Ωch re≈æim≈Ø</span>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="tomorrow-intervals">
                    <h4>üìÖ Pl√°n interval≈Ø</h4>
                    ${this.renderTomorrowIntervals(intervals)}
                </div>
            </div>
        `;
    }

    /**
     * Render Z√çTRA tab from BE data (F√ÅZE 3)
     */
    renderTomorrowTabBE(summary) {
        const plannedCost = summary.plan_total_cost || 0;
        const dominantMode = summary.dominant_mode_name || 'N/A';
        const dominantCount = summary.dominant_mode_count || 0;
        const dominantPct = summary.dominant_mode_pct || 0;
        const modeCount = Object.keys(summary.mode_distribution || {}).length;
        const totalIntervals = Object.values(summary.mode_distribution || {}).reduce((a, b) => a + b, 0);

        return `
            <div class="today-header-cards">
                <div class="header-progress-large">
                    <div class="progress-bar-gradient">
                        <div class="progress-fill-gradient" style="width: ${dominantPct}%"></div>
                        <div class="progress-label-overlay">${dominantMode} ${dominantPct.toFixed(0)}%</div>
                    </div>
                </div>

                <div class="metric-cards-grid">
                    <div class="metric-card card-completed">
                        <div class="card-header">
                            <span class="card-icon">üí∞</span>
                            <span class="card-title">Pl√°novan√© n√°klady</span>
                        </div>
                        <div class="card-body">
                            <div class="card-main-value">${plannedCost.toFixed(2)} Kƒç</div>
                            <div class="card-details">
                                <span class="detail-item">${totalIntervals} interval≈Ø</span>
                            </div>
                        </div>
                    </div>

                    <div class="metric-card card-active">
                        <div class="card-header">
                            <span class="card-icon">‚ö°</span>
                            <span class="card-title">Dominantn√≠ re≈æim</span>
                        </div>
                        <div class="card-body">
                            <div class="card-main-value" style="font-size: 1.5rem;">${dominantMode}</div>
                            <div class="card-details">
                                <span class="detail-item">${dominantCount} interval≈Ø (${dominantPct.toFixed(0)}%)</span>
                            </div>
                        </div>
                    </div>

                    <div class="metric-card card-eod">
                        <div class="card-header">
                            <span class="card-icon">üìä</span>
                            <span class="card-title">Re≈æimy celkem</span>
                        </div>
                        <div class="card-body">
                            <div class="card-main-value">${modeCount}</div>
                            <div class="card-details">
                                <span class="detail-item">r≈Øzn√Ωch re≈æim≈Ø</span>
                            </div>
                        </div>
                    </div>
                </div>

                ${this.renderTomorrowPlannedGroupsBE(summary.planned_groups || [])}
            </div>
        `;
    }

    /**
     * Render planned groups from BE (F√ÅZE 3)
     */
    renderTomorrowPlannedGroupsBE(groups) {
        if (!groups || groups.length === 0) {
            return '<p style="color: var(--text-secondary);">≈Ω√°dn√© intervaly k dispozici</p>';
        }

        const modeIcons = {
            'HOME I': 'üè†',
            'HOME II': '‚ö°',
            'HOME III': 'üîã',
            'HOME UPS': '‚ö°'
        };

        const totalCost = groups.reduce((sum, g) => sum + (g.planned_cost || 0), 0);
        const totalSavings = groups.reduce((sum, g) => sum + (g.planned_savings || 0), 0);

        const rows = groups.map(group => {
            const icon = modeIcons[group.mode] || 'üéØ';
            const timeRange = `${group.start_time || 'N/A'} - ${group.end_time || 'N/A'}`;

            return `
                <div class="interval-row future">
                    <div class="interval-summary">
                        <span class="interval-time">${timeRange}</span>
                        <span class="interval-mode">${icon} ${group.mode}</span>
                        <span class="interval-count">(${group.interval_count}√ó15min)</span>
                        <span class="interval-cost">${group.planned_cost.toFixed(2)} Kƒç</span>
                        ${group.planned_savings > 0 ? `<span class="interval-savings">üíé ${group.planned_savings.toFixed(2)} Kƒç</span>` : ''}
                    </div>
                </div>
            `;
        }).join('');

        return `
            <div class="interval-section collapsible collapsed">
                <div class="section-header" onclick="toggleSection('tomorrow-intervals-be')">
                    <span class="section-icon">üìÖ</span>
                    <span class="section-title">PL√ÅN INTERVAL≈Æ</span>
                    <span class="section-meta">
                        <span class="meta-item">üí∞ ${totalCost.toFixed(2)} Kƒç</span>
                        ${totalSavings > 0 ? `<span class="meta-item">üíé ${totalSavings.toFixed(2)} Kƒç</span>` : ''}
                    </span>
                    <span class="section-toggle">‚ñ∂</span>
                </div>
                <div class="interval-list" id="tomorrow-intervals-be" style="display: none;">
                    ${rows}
                </div>
            </div>
        `;
    }

    /**
     * Render mode distribution chart (F√ÅZE 3)
     */
    renderModeDistributionBE(distribution) {
        if (!distribution || Object.keys(distribution).length === 0) {
            return '<p style="color: var(--text-secondary);">≈Ω√°dn√° distribuce</p>';
        }

        const total = Object.values(distribution).reduce((a, b) => a + b, 0);
        const modeIcons = {
            'HOME I': 'üè†',
            'HOME II': '‚ö°',
            'HOME III': 'üîã',
            'HOME UPS': '‚ö°'
        };

        const bars = Object.entries(distribution)
            .sort((a, b) => b[1] - a[1])
            .map(([mode, count]) => {
                const pct = total > 0 ? (count / total * 100) : 0;
                const icon = modeIcons[mode] || 'üéØ';

                return `
                    <div class="mode-dist-row">
                        <span class="mode-name">${icon} ${mode}</span>
                        <div class="mode-bar-container">
                            <div class="mode-bar-fill" style="width: ${pct}%"></div>
                            <span class="mode-bar-label">${count} interval≈Ø (${pct.toFixed(0)}%)</span>
                        </div>
                    </div>
                `;
            }).join('');

        return `<div class="mode-distribution">${bars}</div>`;
    }

    /**
     * Render tomorrow's intervals grouped by mode
     */
    renderTomorrowIntervals(intervals) {
        if (!intervals || intervals.length === 0) {
            return '<p style="color: var(--text-secondary);">≈Ω√°dn√© intervaly k dispozici</p>';
        }

        // Group by mode
        const groups = this.groupIntervalsByMode(intervals);

        return groups.map(group => {
            const totalCost = group.intervals.reduce((sum, iv) => sum + (iv.planned?.net_cost || 0), 0);
            const timeRange = `${group.intervals[0].time_start} - ${group.intervals[group.intervals.length - 1].time_end}`;

            return `
                <div class="interval-group tomorrow-group">
                    <div class="group-header">
                        <span class="mode-badge">${group.mode}</span>
                        <span class="time-range">${timeRange}</span>
                        <span class="interval-count">${group.intervals.length} blok≈Ø</span>
                        <span class="group-cost">${totalCost.toFixed(2)} Kƒç</span>
                    </div>
                </div>
            `;
        }).join('');
    }

    /**
     * Render HISTORIE tab - Multi-day historical comparison
     */
    renderHistoryTab(data) {
        // For now, placeholder
        return `
            <div style="padding: 40px 20px; text-align: center;">
                <div style="font-size: 3em; margin-bottom: 20px;">üìà</div>
                <h3 style="color: var(--text-secondary); margin-bottom: 10px;">
                    Historie posledn√≠ch 7 dn√≠
                </h3>
                <p style="color: var(--text-muted); margin-top: 10px;">
                    Graf p≈ôesnosti pl√°nu a kumulativn√≠ dopady<br>
                    <small>(v p≈ô√≠pravƒõ)</small>
                </p>
            </div>
        `;
    }

    /**
     * Render header with overall stats
     */
    renderHeader(summary, dayType) {
        const plannedCost = summary?.planned_total_cost || 0;
        const actualCost = summary?.actual_total_cost || 0;
        const deltaCost = actualCost - plannedCost;
        const deltaPercent = plannedCost > 0 ? ((deltaCost / plannedCost) * 100) : 0;

        const deltaClass = deltaCost > 0 ? 'negative' : 'positive';
        const deltaIcon = deltaCost > 0 ? '‚ùå' : '‚úÖ';

        // Calculate mode adherence from intervals (need to pass it separately)
        const modeAdherence = summary?.mode_adherence_pct || 0;
        const modeMatches = summary?.mode_matches || 0;
        const totalIntervals = summary?.total_intervals || 96;

        // Find biggest variance
        const biggestVariance = summary?.biggest_variance || null;

        return `
            <div class="yesterday-header">
                <h3>üìä Vƒçera - Pl√°n vs Skuteƒçnost</h3>

                <div class="stats-row">
                    <div class="stat-box">
                        <div class="stat-label">üí∞ Pl√°n</div>
                        <div class="stat-value">${plannedCost.toFixed(2)} Kƒç</div>
                    </div>

                    <div class="stat-box">
                        <div class="stat-label">üí∏ Skuteƒçnost</div>
                        <div class="stat-value">${actualCost.toFixed(2)} Kƒç</div>
                    </div>

                    <div class="stat-box ${deltaClass}">
                        <div class="stat-label">üìä V√Ωsledek</div>
                        <div class="stat-value">
                            ${deltaCost > 0 ? '+' : ''}${deltaCost.toFixed(2)} Kƒç<br>
                            <small>${deltaIcon} ${Math.abs(deltaPercent).toFixed(1)}% ${deltaCost > 0 ? 'hor≈°√≠' : 'lep≈°√≠'}</small>
                        </div>
                    </div>
                </div>

                <div class="header-footer">
                    <div class="footer-stat">
                        ‚úÖ Shoda re≈æim≈Ø: ${modeAdherence.toFixed(0)}% (${modeMatches}/${totalIntervals} interval≈Ø)
                    </div>
                    ${biggestVariance ? `
                        <div class="footer-stat">
                            ‚ö†Ô∏è Nejvƒõt≈°√≠ odchylka: ${biggestVariance.time} (${biggestVariance.delta > 0 ? '+' : ''}${biggestVariance.delta.toFixed(2)} Kƒç)
                        </div>
                    ` : ''}
                </div>
            </div>
        `;
    }

    /**
     * Render top 3 variances ranking
     */
    renderTopVariances(variances) {
        if (variances.length === 0) {
            return '<div class="top-variances"><p>≈Ω√°dn√© v√Ωznamn√© odchylky</p></div>';
        }

        const medals = ['ü•á', 'ü•à', 'ü•â'];

        const html = variances.map((v, idx) => {
            const deltaClass = v.delta > 0 ? 'negative' : 'positive';
            const arrow = v.delta > 0 ? '‚¨ÜÔ∏è' : '‚¨áÔ∏è';
            const percent = v.planned > 0 ? Math.abs((v.delta / v.planned) * 100) : 0;

            return `
                <div class="variance-item ${deltaClass}">
                    <div class="variance-rank">${medals[idx] || `#${idx + 1}`}</div>
                    <div class="variance-details">
                        <div class="variance-time">${v.time}</div>
                        <div class="variance-modes">${v.plannedMode} ‚Üí ${v.actualMode}</div>
                        <div class="variance-impact">
                            ${v.delta > 0 ? '+' : ''}${v.delta.toFixed(2)} Kƒç ${arrow} ${percent.toFixed(0)}% ${v.delta > 0 ? 'hor≈°√≠' : 'lep≈°√≠'}
                        </div>
                        <div class="variance-reason">${v.reason}</div>
                    </div>
                </div>
            `;
        }).join('');

        return `
            <div class="top-variances">
                <h4>‚ö†Ô∏è Top 3 nejvƒõt≈°√≠ odchylky</h4>
                ${html}
            </div>
        `;
    }

    /**
     * Render variance chart for VƒåERA
     */
    renderVarianceChart(intervals, dayType) {
        // Return placeholder div, actual chart will be rendered via Chart.js after DOM insert
        return `
            <div class="variance-chart-container">
                <h4>üìä Variance Analysis - Pl√°n vs Skuteƒçnost</h4>
                <canvas id="variance-chart-${dayType}" style="height: 300px;"></canvas>
            </div>
        `;
    }

    /**
     * Render live header for DNES tab (v2.1 compact format)
     */
    renderLiveHeader(progress, eodPrediction, unifiedCostData) {
        const now = new Date();
        const timeStr = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;

        const today = unifiedCostData || {};
        const eod = today.eod_prediction || {};
        const completed = today.completed_so_far || {};

        const progressPercent = today.progress_pct || progress.percent || 0;
        const eodPredicted = eod.predicted_total || eodPrediction.predicted || 0;
        // FIX: Use today.plan_total_cost FIRST (contains full day plan), not eod.planned_total
        const eodPlanned = today.plan_total_cost || eod.planned_total || eodPrediction.planned || 0;
        const eodSavingsPredicted = eod.predicted_savings || 0;

        const completedCost = completed.actual_cost || progress.actualCost || 0;
        const completedPlanned = completed.planned_cost || progress.plannedCost || 0;

        const eodDelta = eodPredicted - eodPlanned;
        const eodDeltaPct = eodPlanned > 0 ? ((eodDelta / eodPlanned) * 100) : 0;
        const eodDeltaClass = eodDelta < -0.5 ? 'positive' : eodDelta > 0.5 ? 'negative' : 'neutral';
        const eodDeltaIcon = eodDelta < -0.5 ? '‚úÖ' : eodDelta > 0.5 ? '‚ùå' : '‚ö™';

        const completedDelta = completedCost - completedPlanned;
        const completedDeltaPct = completed.delta_pct || (completedPlanned > 0 ? ((completedDelta / completedPlanned) * 100) : 0);
        const completedDeltaClass = completedDelta < -0.5 ? 'positive' : completedDelta > 0.5 ? 'negative' : 'neutral';

        return `
            <div class="today-header-simple">
                <div class="header-progress">
                    <div class="progress-bar-large">
                        <div class="progress-fill" style="width: ${progressPercent}%"></div>
                        <div class="progress-label">${progressPercent.toFixed(0)}% dne ‚Ä¢ ${timeStr}</div>
                    </div>
                </div>

                <div class="header-cards">
                    <div class="card card-primary">
                        <div class="card-icon">üí∞</div>
                        <div class="card-content">
                            <div class="card-title">Odhad n√°klad≈Ø na konec dne</div>
                            <div class="card-value">${eodPredicted.toFixed(2)} Kƒç</div>
                            <div class="card-sub">pl√°n: ${eodPlanned.toFixed(2)} Kƒç ‚Ä¢ ${eodDeltaIcon} ${eodDeltaPct > 0 ? '+' : ''}${eodDeltaPct.toFixed(1)}%</div>
                        </div>
                    </div>

                    <div class="card card-secondary">
                        <div class="card-icon">üìä</div>
                        <div class="card-content">
                            <div class="card-title">Dosud skuteƒçnƒõ</div>
                            <div class="card-value ${completedDeltaClass}">${completedCost.toFixed(2)} Kƒç</div>
                            <div class="card-sub">pl√°n: ${completedPlanned.toFixed(2)} Kƒç ‚Ä¢ ${completedDeltaPct > 0 ? '+' : ''}${completedDeltaPct.toFixed(1)}%</div>
                        </div>
                    </div>

                    <div class="card card-accent">
                        <div class="card-icon">üíé</div>
                        <div class="card-content">
                            <div class="card-title">P≈ôedpokl√°dan√° √∫spora</div>
                            <div class="card-value">${eodSavingsPredicted.toFixed(2)} Kƒç</div>
                            <div class="card-sub">vs. HOME I re≈æim</div>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
    /**
     * Render timeline chart for DNES tab
     */
    renderTimelineChart(intervals, dayType) {
        return `
            <div class="timeline-chart-container">
                <h4>üìä Timeline - Pl√°n vs Skuteƒçnost</h4>
                <canvas id="timeline-chart-${dayType}" style="height: 350px;"></canvas>
            </div>
        `;
    }

    /**
     * Calculate statistics from intervals
     */
    calculateStats(intervals) {
        let plannedCost = 0;
        let actualCost = 0;
        let modeMatches = 0;
        let totalIntervals = 0;

        intervals.forEach(interval => {
            if (interval.planned) {
                plannedCost += interval.planned.net_cost || 0;
            }

            if (interval.actual) {
                actualCost += interval.actual.net_cost || 0;
                totalIntervals++;

                if (interval.planned && interval.actual.mode_name === interval.planned.mode_name) {
                    modeMatches++;
                }
            }
        });

        return {
            plannedCost,
            actualCost,
            deltaCost: actualCost - plannedCost,
            modeMatches,
            totalIntervals,
            adherence: totalIntervals > 0 ? (modeMatches / totalIntervals) * 100 : 0
        };
    }

    /**
     * Get top N variances sorted by absolute delta
     */
    getTopVariances(intervals, count = 3) {
        const variances = [];

        intervals.forEach(interval => {
            if (!interval.actual || !interval.planned) return;

            const delta = (interval.actual.net_cost || 0) - (interval.planned.net_cost || 0);

            // Only include significant variances (>0.5 Kƒç)
            if (Math.abs(delta) < 0.5) return;

            const time = new Date(interval.time);
            const timeStr = `${time.getHours().toString().padStart(2, '0')}:${time.getMinutes().toString().padStart(2, '0')}`;

            variances.push({
                time: timeStr,
                delta: delta,
                planned: interval.planned.net_cost || 0,
                actual: interval.actual.net_cost || 0,
                plannedMode: interval.planned.mode_name || '?',
                actualMode: interval.actual.mode_name || '?',
                reason: this.getVarianceReason(interval)
            });
        });

        // Sort by absolute delta (biggest first)
        variances.sort((a, b) => Math.abs(b.delta) - Math.abs(a.delta));

        return variances.slice(0, count);
    }

    /**
     * Determine reason for variance
     */
    getVarianceReason(interval) {
        const planned = interval.planned;
        const actual = interval.actual;

        if (!planned || !actual) return 'Nezn√°m√Ω d≈Øvod';

        // Check mode mismatch
        if (planned.mode_name !== actual.mode_name) {
            return `Re≈æim se nezmƒõnil na ${planned.mode_name}`;
        }

        // Check consumption variance
        const consumptionDelta = (actual.consumption_kwh || 0) - (planned.consumption_kwh || 0);
        if (Math.abs(consumptionDelta) > 0.1) {
            return consumptionDelta > 0 ? 'Vy≈°≈°√≠ spot≈ôeba ne≈æ pl√°nov√°no' : 'Ni≈æ≈°√≠ spot≈ôeba ne≈æ pl√°nov√°no';
        }

        // Check price variance
        const priceDelta = (actual.spot_price || 0) - (planned.spot_price || 0);
        if (Math.abs(priceDelta) > 0.1) {
            return priceDelta > 0 ? 'Vy≈°≈°√≠ cena ne≈æ pl√°nov√°no' : 'Ni≈æ≈°√≠ cena ne≈æ pl√°nov√°no';
        }

        return 'Odchylka zp≈Øsobena kombinac√≠ faktor≈Ø';
    }

    /**
     * Calculate current progress (for DNES tab)
     */
    calculateProgress(intervals) {
        const now = new Date();
        const historical = intervals.filter(i => i.status === 'historical' || i.status === 'current');

        console.log(`[TimelineDialog] calculateProgress - total intervals: ${intervals.length}, historical: ${historical.length}`);

        if (historical.length > 0) {
            console.log('[TimelineDialog] Sample historical interval:', historical[0]);
            console.log('[TimelineDialog] Sample planned object:', historical[0].planned);
            console.log('[TimelineDialog] Sample actual object:', historical[0].actual);
            console.log('[TimelineDialog] Sample delta object:', historical[0].delta);
        }

        let plannedCost = 0;
        let actualCost = 0;
        let modeMatches = 0;

        historical.forEach((interval, idx) => {
            const pCost = interval.planned?.net_cost || 0;
            const aCost = interval.actual?.net_cost || 0;

            if (idx === 0) {
                console.log(`[TimelineDialog] First interval - planned.net_cost: ${interval.planned?.net_cost}, actual.net_cost: ${interval.actual?.net_cost}`);
            }

            plannedCost += pCost;
            actualCost += aCost;

            // Count mode matches
            if (interval.actual && interval.planned) {
                const plannedMode = interval.planned.mode_name || '';
                const actualMode = interval.actual.mode_name || '';
                if (plannedMode === actualMode) {
                    modeMatches++;
                }
            }
        });

        console.log(`[TimelineDialog] Progress - planned: ${plannedCost.toFixed(2)}, actual: ${actualCost.toFixed(2)}`);

        // Calculate % of day elapsed (96 intervals = 24 hours)
        const percent = (historical.length / 96) * 100;
        const modeAdherence = historical.length > 0 ? (modeMatches / historical.length) * 100 : 0;

        return {
            plannedCost,
            actualCost,
            percent,
            intervalsCompleted: historical.length,
            modeMatches,
            modeAdherence
        };
    }

    /**
     * Calculate EOD prediction (for DNES tab)
     */
    calculateEODPrediction(intervals) {
        const historical = intervals.filter(i => i.status === 'historical' || i.status === 'current');
        const planned = intervals.filter(i => i.status === 'planned');

        // Historical costs
        let historicalPlanned = 0;
        let historicalActual = 0;

        historical.forEach(interval => {
            historicalPlanned += interval.planned?.net_cost || 0;
            historicalActual += interval.actual?.net_cost || 0;
        });

        // Future planned costs
        let futurePlanned = 0;
        planned.forEach(interval => {
            futurePlanned += interval.planned?.net_cost || 0;
        });

        // Total planned
        const totalPlanned = historicalPlanned + futurePlanned;

        // Calculate drift ratio
        const driftRatio = historicalPlanned > 0 ? (historicalActual / historicalPlanned) : 1.0;

        // Predict EOD = actual so far + (future planned * drift ratio)
        const predicted = historicalActual + (futurePlanned * driftRatio);

        return {
            planned: totalPlanned,
            predicted: predicted
        };
    }

    /**
     * Start update interval (refresh every 60s)
     */
    startUpdateInterval() {
        this.stopUpdateInterval(); // Clear existing

        this.updateInterval = setInterval(() => {
            console.log('[TimelineDialog] Auto-refresh...');

            // Reload today data
            this.loadTabData('today').then(() => {
                if (this.activeTab === 'today') {
                    this.renderTab('today');
                }
            });
        }, 60000); // 60 seconds
    }

    /**
     * Stop update interval
     */
    stopUpdateInterval() {
        if (this.updateInterval) {
            clearInterval(this.updateInterval);
            this.updateInterval = null;
        }
    }

    /**
     * Initialize Chart.js for VƒåERA tab - Variance Chart
     */
    initializeYesterdayCharts(intervals, dayType) {
        const canvasId = `variance-chart-${dayType}`;
        const canvas = document.getElementById(canvasId);

        if (!canvas) {
            console.warn(`[TimelineDialog] Canvas ${canvasId} not found`);
            return;
        }

        console.log(`[TimelineDialog] Initializing variance chart for ${dayType}`);

        // Prepare data
        const labels = [];
        const deltaData = [];
        const colors = [];

        intervals.forEach((interval, idx) => {
            const intervalTime = new Date(interval.time);
            const timeStr = `${intervalTime.getHours().toString().padStart(2, '0')}:${intervalTime.getMinutes().toString().padStart(2, '0')}`;

            // Show every 4th label (1 hour)
            labels.push(idx % 4 === 0 ? timeStr : '');

            // Calculate delta
            const delta = interval.actual && interval.planned
                ? (interval.actual.net_cost || 0) - (interval.planned.net_cost || 0)
                : 0;

            deltaData.push(delta);

            // Color coding
            let color = 'rgba(150, 150, 150, 0.5)';
            if (delta < -0.05) {
                color = 'rgba(76, 175, 80, 0.8)'; // Green - better
            } else if (delta > 0.05) {
                color = 'rgba(244, 67, 54, 0.8)'; // Red - worse
            } else if (interval.actual) {
                color = 'rgba(33, 150, 243, 0.8)'; // Blue - neutral
            }
            colors.push(color);
        });

        // Create chart
        const ctx = canvas.getContext('2d');
        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Odchylka od pl√°nu (Kƒç)',
                    data: deltaData,
                    backgroundColor: colors,
                    borderColor: colors.map(c => c.replace('0.8', '1').replace('0.5', '0.8')),
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        enabled: true,
                        backgroundColor: 'rgba(30, 40, 50, 0.95)',
                        titleColor: 'rgba(255, 255, 255, 0.95)',
                        bodyColor: 'rgba(255, 255, 255, 0.8)',
                        borderColor: 'rgba(255, 255, 255, 0.2)',
                        borderWidth: 1,
                        callbacks: {
                            title: (context) => {
                                const idx = context[0].dataIndex;
                                const interval = intervals[idx];
                                const time = new Date(interval.time);
                                const endTime = new Date(time.getTime() + 15 * 60000);
                                return `${time.getHours().toString().padStart(2, '0')}:${time.getMinutes().toString().padStart(2, '0')} - ${endTime.getHours().toString().padStart(2, '0')}:${endTime.getMinutes().toString().padStart(2, '0')}`;
                            },
                            label: (context) => {
                                const idx = context.dataIndex;
                                const interval = intervals[idx];
                                const delta = context.parsed.y;

                                if (!interval.actual) {
                                    return 'Pl√°nov√°no (je≈°tƒõ nenastalo)';
                                }

                                return [
                                    `Odchylka: ${delta >= 0 ? '+' : ''}${delta.toFixed(2)} Kƒç`,
                                    `Pl√°n: ${(interval.planned?.net_cost || 0).toFixed(2)} Kƒç`,
                                    `Skuteƒçnost: ${(interval.actual?.net_cost || 0).toFixed(2)} Kƒç`,
                                    `Re≈æim: ${interval.actual?.mode_name || interval.planned?.mode_name || '?'}`
                                ];
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        grid: {
                            display: false
                        },
                        ticks: {
                            color: 'rgba(255, 255, 255, 0.7)',
                            maxRotation: 0,
                            autoSkip: false
                        }
                    },
                    y: {
                        grid: {
                            color: 'rgba(255, 255, 255, 0.1)'
                        },
                        ticks: {
                            color: 'rgba(255, 255, 255, 0.7)',
                            callback: function(value) {
                                return value.toFixed(1) + ' Kƒç';
                            }
                        },
                        title: {
                            display: true,
                            text: 'Odchylka od pl√°nu',
                            color: 'rgba(255, 255, 255, 0.9)'
                        }
                    }
                }
            }
        });
    }

    /**
     * Initialize Chart.js for DNES tab - Timeline Chart with NOW marker
     */
    initializeTodayCharts(intervals, dayType) {
        const canvasId = `timeline-chart-${dayType}`;
        const canvas = document.getElementById(canvasId);

        if (!canvas) {
            console.warn(`[TimelineDialog] Canvas ${canvasId} not found`);
            return;
        }

        console.log(`[TimelineDialog] Initializing timeline chart for ${dayType}`);

        const now = new Date();
        const labels = [];
        const deltaData = [];
        const colors = [];
        let nowIndex = -1;

        intervals.forEach((interval, idx) => {
            const intervalTime = new Date(interval.time);
            const timeStr = `${intervalTime.getHours().toString().padStart(2, '0')}:${intervalTime.getMinutes().toString().padStart(2, '0')}`;

            labels.push(idx % 4 === 0 ? timeStr : '');

            const isHistorical = interval.status === 'historical' || interval.status === 'current';

            if (isHistorical && interval.actual && interval.planned) {
                const delta = (interval.actual.net_cost || 0) - (interval.planned.net_cost || 0);
                deltaData.push(delta);

                // Color: green/red/blue for historical
                if (delta < -0.05) {
                    colors.push('rgba(76, 175, 80, 0.8)');
                } else if (delta > 0.05) {
                    colors.push('rgba(244, 67, 54, 0.8)');
                } else {
                    colors.push('rgba(33, 150, 243, 0.8)');
                }
            } else {
                // Future: show as 0 with gray
                deltaData.push(0);
                colors.push('rgba(150, 150, 150, 0.3)');
            }

            // Find NOW marker
            if (intervalTime <= now) {
                nowIndex = idx;
            }
        });

        // Build annotations object for NOW marker
        const annotations = {};
        if (nowIndex >= 0) {
            annotations.nowLine = {
                type: 'line',
                xMin: nowIndex,
                xMax: nowIndex,
                borderColor: 'rgba(255, 152, 0, 0.8)',
                borderWidth: 3,
                label: {
                    display: true,
                    content: 'TEƒéKA',
                    position: 'start',
                    backgroundColor: 'rgba(255, 152, 0, 0.9)',
                    color: '#fff',
                    font: {
                        size: 11,
                        weight: 'bold'
                    }
                }
            };
        }

        // Create chart with NOW marker annotation
        const ctx = canvas.getContext('2d');
        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: labels,
                datasets: [{
                    label: 'Odchylka od pl√°nu (Kƒç)',
                    data: deltaData,
                    backgroundColor: colors,
                    borderColor: colors.map(c => c.replace('0.8', '1').replace('0.3', '0.5')),
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: false
                    },
                    tooltip: {
                        enabled: true,
                        callbacks: {
                            title: (context) => {
                                const idx = context[0].dataIndex;
                                const interval = intervals[idx];
                                const time = new Date(interval.time);
                                const endTime = new Date(time.getTime() + 15 * 60000);
                                return `${time.getHours().toString().padStart(2, '0')}:${time.getMinutes().toString().padStart(2, '0')} - ${endTime.getHours().toString().padStart(2, '0')}:${endTime.getMinutes().toString().padStart(2, '0')}`;
                            },
                            label: (context) => {
                                const idx = context.dataIndex;
                                const interval = intervals[idx];
                                const isHistorical = interval.status === 'historical' || interval.status === 'current';

                                if (!isHistorical || !interval.actual) {
                                    return 'Pl√°nov√°no (je≈°tƒõ nenastalo)';
                                }

                                const delta = context.parsed.y;
                                return [
                                    `Odchylka: ${delta >= 0 ? '+' : ''}${delta.toFixed(2)} Kƒç`,
                                    `Pl√°n: ${(interval.planned?.net_cost || 0).toFixed(2)} Kƒç`,
                                    `Skuteƒçnost: ${(interval.actual?.net_cost || 0).toFixed(2)} Kƒç`,
                                    `Re≈æim: ${interval.actual?.mode_name || interval.planned?.mode_name || '?'}`
                                ];
                            }
                        }
                    },
                    annotation: {
                        annotations: annotations
                    }
                },
                scales: {
                    x: {
                        grid: {
                            display: false
                        },
                        ticks: {
                            color: 'var(--text-secondary)',
                            maxRotation: 0,
                            autoSkip: false
                        }
                    },
                    y: {
                        grid: {
                            color: 'rgba(255, 255, 255, 0.1)'
                        },
                        ticks: {
                            color: 'var(--text-secondary)',
                            callback: function(value) {
                                return value.toFixed(1) + ' Kƒç';
                            }
                        },
                        title: {
                            display: true,
                            text: 'Odchylka od pl√°nu',
                            color: 'var(--text-secondary)'
                        }
                    }
                }
            }
        });
    }

    /**
     * Destroy dialog instance
     */
    destroy() {
        this.close();
        this.dialogElement = null;
        this.cache = {};
    }
}

// Global instance
let timelineDialogInstance = null;

// Initialize on page load
function initTimelineDialog() {
    timelineDialogInstance = new TimelineDialog();
    timelineDialogInstance.init();
}

// Open dialog (called from Today Plan Tile)
function openModeTimelineDialog() {
    if (!timelineDialogInstance) {
        initTimelineDialog();
    }
    timelineDialogInstance.open();
}

// Alias for openModeTimelineDialog (used by Unified Cost Tile onclick)
function openTimelineDialog(tabName = null) {
    if (!timelineDialogInstance) {
        initTimelineDialog();
    }
    if (tabName) {
        timelineDialogInstance.open(tabName);
    } else {
        timelineDialogInstance.open();
    }
}

// Close dialog
function closeModeTimelineDialog() {
    if (timelineDialogInstance) {
        timelineDialogInstance.close();
    }
}

// =============================================================================
// END TIMELINE DIALOG
// =============================================================================

// Global instance for Today Plan Tile
let todayPlanTileInstance = null;

// Build mode timeline from mode_recommendations (Phase 2.8: Load from API)

async function buildModeTimeline() {
    const hass = getHass();
    if (!hass) return;

    const forecastSensorId = `sensor.oig_${INVERTER_SN}_battery_forecast`;
    const forecastSensor = hass.states[forecastSensorId];

    if (!forecastSensor || forecastSensor.state === 'unavailable' || forecastSensor.state === 'unknown') {
        console.warn('Battery forecast sensor not available');
        return;
    }

    // Phase 2.8: Fetch mode_recommendations from API instead of attributes
    const apiUrl = `/api/oig_cloud/battery_forecast/${INVERTER_SN}/timeline?type=active`;
    let recommendations = [];

    try {
        const response = await fetch(apiUrl);
        if (response.ok) {
            const data = await response.json();
            recommendations = data.mode_recommendations || [];
            console.log(`[Timeline] Loaded ${recommendations.length} mode recommendation blocks from API`);
        } else {
            console.error('[Timeline] Failed to fetch mode recommendations:', response.status);
            return;
        }
    } catch (error) {
        console.error('[Timeline] Error fetching mode recommendations:', error);
        return;
    }

    if (!recommendations || recommendations.length === 0) {
        console.warn('No mode recommendations data available');
        return;
    }

    // Split recommendations into TODAY and TOMORROW (based on from_time date)
    const now = new Date();
    const today = now.toISOString().split('T')[0]; // "2025-10-29"
    const tomorrow = new Date(now);
    tomorrow.setDate(tomorrow.getDate() + 1);
    const tomorrowStr = tomorrow.toISOString().split('T')[0]; // "2025-10-30"

    const todayBlocks = [];
    const tomorrowBlocks = [];

    recommendations.forEach(block => {
        const blockDate = block.from_time.split('T')[0]; // Extract "2025-10-29" from ISO string

        if (blockDate === today) {
            todayBlocks.push(block);
        } else if (blockDate === tomorrowStr) {
            tomorrowBlocks.push(block);
        }
        // Skip other days (shouldn't happen - backend filters to DNES+Z√çTRA only)
    });

    // Calculate stats for each day
    const todayStats = calculateDayStats(todayBlocks);
    const tomorrowStats = calculateDayStats(tomorrowBlocks);

    // Update summary (overall)
    const totalCost = todayStats.cost + tomorrowStats.cost;
    const totalSavings = todayStats.savings + tomorrowStats.savings;
    const totalSwitches = todayStats.switches + tomorrowStats.switches;

    document.getElementById('timeline-total-cost').textContent = `${totalCost.toFixed(2)} Kƒç`;
    document.getElementById('timeline-total-savings').textContent = `${totalSavings.toFixed(2)} Kƒç`;
    document.getElementById('timeline-total-switches').textContent = `${totalSwitches}√ó`;

    // Build tabs content
    buildDayTab('today', todayBlocks, todayStats);
    buildDayTab('tomorrow', tomorrowBlocks, tomorrowStats);

    // Show TODAY tab by default
    showTimelineTab('today');
}

// Calculate stats for a day
function calculateDayStats(blocks) {
    let cost = 0;
    let savings = 0;
    let switches = 0;
    let lastMode = null;

    blocks.forEach(block => {
        cost += block.total_cost || 0;
        savings += block.savings_vs_home_i || 0;
        if (lastMode && lastMode !== block.mode_name) {
            switches++;
        }
        lastMode = block.mode_name;
    });

    return { cost, savings, switches, blocks: blocks.length };
}

// Build day tab content
function buildDayTab(dayId, blocks, stats) {
    const container = document.getElementById(`timeline-${dayId}-content`);
    if (!container) return;

    if (blocks.length === 0) {
        container.innerHTML = '<p style="color: var(--text-secondary); padding: 20px; text-align: center;">≈Ω√°dn√° data pro tento den.</p>';
        return;
    }

    // Build stats header
    const statsHtml = `
        <div class="day-stats">
            <div class="day-stat">
                <div class="day-stat-label">üí∞ N√°klady celkem</div>
                <div class="day-stat-value">${stats.cost.toFixed(2)} Kƒç</div>
            </div>
            <div class="day-stat">
                <div class="day-stat-label">üí° √öspora vs HOME I</div>
                <div class="day-stat-value ${stats.savings > 0 ? 'positive' : ''}">${stats.savings > 0 ? '+' : ''}${stats.savings.toFixed(2)} Kƒç</div>
            </div>
            <div class="day-stat">
                <div class="day-stat-label">üîÑ P≈ôepnut√≠ re≈æim≈Ø</div>
                <div class="day-stat-value">${stats.switches}√ó</div>
            </div>
            <div class="day-stat">
                <div class="day-stat-label">üìä Poƒçet blok≈Ø</div>
                <div class="day-stat-value">${stats.blocks}</div>
            </div>
        </div>
    `;

    // Build detail cards
    const cardsHtml = blocks.map((block, index) => {
        const config = MODE_CONFIG[block.mode_name] || MODE_CONFIG['HOME I'];
        const savings = block.savings_vs_home_i || 0;
        const savingsClass = savings > 0 ? 'positive' : savings < 0 ? 'negative' : '';

        // Format times
        const fromTime = new Date(block.from_time);
        const toTime = new Date(block.to_time);
        const fromStr = `${fromTime.getHours().toString().padStart(2, '0')}:${fromTime.getMinutes().toString().padStart(2, '0')}`;
        const toStr = `${toTime.getHours().toString().padStart(2, '0')}:${toTime.getMinutes().toString().padStart(2, '0')}`;

        return `
            <div class="detail-block" data-block-id="${dayId}-${index}">
                <div class="detail-header" onclick="toggleDetailBlock('${dayId}-${index}')">
                    <div class="detail-time">${fromStr} - ${toStr}</div>
                    <div class="detail-mode">
                        <span class="detail-mode-icon">${config.icon}</span>
                        <span>${block.mode_name}</span>
                    </div>
                    <div class="detail-cost">${(block.total_cost || 0).toFixed(2)} Kƒç</div>
                    <div class="detail-savings ${savingsClass}">${savings > 0 ? '+' : ''}${savings.toFixed(2)} Kƒç</div>
                    <div class="detail-expand">‚ñº</div>
                </div>
                <div class="detail-body">
                    <div class="detail-rationale">
                        <strong>üìã Od≈Øvodnƒõn√≠:</strong><br>
                        ${block.rationale || 'Optimalizov√°no podle aktu√°ln√≠ ceny elekt≈ôiny a predikce spot≈ôeby.'}
                    </div>
                    ${block.savings_note ? `<div class="detail-savings-note">üí° ${block.savings_note}</div>` : ''}
                    <div class="detail-metrics">
                        <div class="metric-row">
                            <span>‚ö° FVE v√Ωroba:</span>
                            <span>${(block.avg_solar_kw || 0).toFixed(2)} kW</span>
                        </div>
                        <div class="metric-row">
                            <span>üè† Spot≈ôeba:</span>
                            <span>${(block.avg_load_kw || 0).toFixed(2)} kW</span>
                        </div>
                        <div class="metric-row">
                            <span>üí∞ Spot cena:</span>
                            <span>${(block.avg_spot_price || 0).toFixed(2)} Kƒç/kWh</span>
                        </div>
                        <div class="metric-row">
                            <span>‚è±Ô∏è Trv√°n√≠:</span>
                            <span>${(block.duration_hours || 0).toFixed(2)} h (${block.intervals_count || 0} √ó 15min)</span>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }).join('');

    container.innerHTML = statsHtml + '<div class="timeline-cards">' + cardsHtml + '</div>';
}

// Toggle detail card expansion
function toggleDetailBlock(blockId) {
    const card = document.querySelector(`[data-block-id="${blockId}"]`);
    if (card) {
        card.classList.toggle('expanded');
    }
}

// Show specific timeline tab
// Build visual timeline blocks
function buildTimelineBlocks(recommendations) {
    const container = document.getElementById('timeline-blocks');
    if (!container) return;

    container.innerHTML = '';

    recommendations.forEach((block, index) => {
        // Parse ISO datetime to get hours and minutes
        const fromTime = new Date(block.from_time);
        const toTime = new Date(block.to_time);

        const startHour = fromTime.getHours();
        const startMin = fromTime.getMinutes();
        const endHour = toTime.getHours();
        const endMin = toTime.getMinutes();

        const startPercent = ((startHour * 60 + startMin) / 1440) * 100;
        const endPercent = ((endHour * 60 + endMin) / 1440) * 100;
        const widthPercent = endPercent - startPercent;

        const config = MODE_CONFIG[block.mode_name] || MODE_CONFIG['HOME I'];

        const blockEl = document.createElement('div');
        blockEl.className = 'timeline-block';
        blockEl.style.left = `${startPercent}%`;
        blockEl.style.width = `${widthPercent}%`;
        blockEl.style.background = config.color;
        blockEl.setAttribute('data-block-index', index);

        const timeStr = `${startHour.toString().padStart(2, '0')}:${startMin.toString().padStart(2, '0')}`;

        blockEl.innerHTML = `
            <div class="block-icon">${config.icon}</div>
            <div class="block-label">${config.label}</div>
            ${widthPercent > 8 ? `<div class="block-time">${timeStr}</div>` : ''}
        `;

        blockEl.onclick = () => toggleDetailBlock(index);

        container.appendChild(blockEl);
    });
}

// Build hour markers
function buildHourMarkers() {
    const container = document.getElementById('timeline-hour-markers');
    if (!container) return;

    container.innerHTML = '';

    for (let h = 0; h < 24; h += 3) {
        const marker = document.createElement('div');
        marker.className = 'hour-marker';
        marker.textContent = `${h.toString().padStart(2, '0')}:00`;
        container.appendChild(marker);
    }
}

// Build detail cards
function buildDetailCards(recommendations) {
    const container = document.getElementById('timeline-details');
    if (!container) return;

    container.innerHTML = '';

    recommendations.forEach((block, index) => {
        const config = MODE_CONFIG[block.mode_name] || MODE_CONFIG['HOME I'];
        const savings = block.savings_vs_home_i || 0;
        const savingsClass = savings > 0 ? 'positive' : savings < 0 ? 'negative' : '';
        const savingsText = savings > 0 ? `+${savings.toFixed(2)} Kƒç` : `${savings.toFixed(2)} Kƒç`;

        // Format times
        const fromTime = new Date(block.from_time);
        const toTime = new Date(block.to_time);
        const fromStr = `${fromTime.getHours().toString().padStart(2, '0')}:${fromTime.getMinutes().toString().padStart(2, '0')}`;
        const toStr = `${toTime.getHours().toString().padStart(2, '0')}:${toTime.getMinutes().toString().padStart(2, '0')}`;

        const card = document.createElement('div');
        card.className = 'detail-block';
        card.setAttribute('data-block-index', index);

        card.innerHTML = `
            <div class="detail-header">
                <div class="detail-time">${fromStr} - ${toStr}</div>
                <div class="detail-mode">
                    <span class="detail-mode-icon">${config.icon}</span>
                    <span>${block.mode_name}</span>
                </div>
                <div class="detail-cost">${(block.total_cost || 0).toFixed(2)} Kƒç</div>
                <div class="detail-savings ${savingsClass}">${savingsText}</div>
                <div class="detail-expand">‚ñº</div>
            </div>
            <div class="detail-body">
                <div class="detail-rationale">
                    <strong>üìã Od≈Øvodnƒõn√≠:</strong><br>
                    ${block.rationale || 'Optimalizov√°no podle aktu√°ln√≠ ceny elekt≈ôiny a predikce spot≈ôeby.'}
                </div>
                <div class="detail-metrics">
                    <div class="metric-row">
                        <span>Pr≈Ømƒõrn√° FVE v√Ωroba:</span>
                        <span>${(block.avg_solar_kw || 0).toFixed(2)} kW</span>
                    </div>
                    <div class="metric-row">
                        <span>Pr≈Ømƒõrn√° spot≈ôeba:</span>
                        <span>${(block.avg_load_kw || 0).toFixed(2)} kW</span>
                    </div>
                    <div class="metric-row">
                        <span>Pr≈Ømƒõrn√° spot cena:</span>
                        <span>${(block.avg_spot_price || 0).toFixed(2)} Kƒç/kWh</span>
                    </div>
                    <div class="metric-row">
                        <span>Trv√°n√≠:</span>
                        <span>${(block.duration_hours || 0).toFixed(1)} h</span>
                    </div>
                </div>
            </div>
        `;

        container.appendChild(card);
    });

    // Add click handlers
    container.querySelectorAll('.detail-header').forEach(header => {
        header.onclick = () => {
            const card = header.closest('.detail-block');
            const index = card.getAttribute('data-block-index');
            toggleDetailBlock(index);
        };
    });
}

// Build alternatives section
function buildAlternatives(alternatives) {
    const container = document.getElementById('timeline-alternatives-list');
    if (!container) return;

    if (!alternatives || alternatives.length === 0) {
        container.innerHTML = '<p style="color: var(--text-secondary); font-style: italic;">≈Ω√°dn√© alternativy k zobrazen√≠.</p>';
        return;
    }

    container.innerHTML = '';

    alternatives.forEach(alt => {
        const delta = alt.cost_difference || 0;
        const deltaClass = delta > 0 ? 'negative' : delta < 0 ? 'positive' : '';
        const deltaText = delta > 0 ? `+${delta.toFixed(2)} Kƒç` : `${delta.toFixed(2)} Kƒç`;

        const item = document.createElement('div');
        item.className = 'alt-item';

        item.innerHTML = `
            <div class="alt-header">
                <div class="alt-name">${alt.scenario_name || 'Nezn√°m√° alternativa'}</div>
                <div class="alt-cost">${(alt.total_cost || 0).toFixed(2)} Kƒç</div>
                <div class="alt-delta ${deltaClass}">${deltaText}</div>
            </div>
            <div class="alt-explain">${alt.why_more_expensive || alt.explanation || '≈Ω√°dn√© vysvƒõtlen√≠ nen√≠ k dispozici.'}</div>
        `;

        container.appendChild(item);
    });
}

// Update current time indicator
function updateTimelineNowIndicator() {
    const indicator = document.getElementById('timeline-now-indicator');
    if (!indicator) return;

    const now = new Date();
    const minutesFromMidnight = now.getHours() * 60 + now.getMinutes();
    const percent = (minutesFromMidnight / 1440) * 100;

    indicator.style.left = `${percent}%`;
}

// Close dialog on overlay click
document.addEventListener('click', (e) => {
    const dialog = document.getElementById('mode-timeline-dialog');
    if (dialog && e.target === dialog) {
        closeModeTimelineDialog();
    }
});

// =============================================================================
// PHASE 2.9: EXTENDED TIMELINE - Historie vs Pl√°n
// =============================================================================

/**
 * Build extended timeline with historical data - ONLY TODAY's plan vs actual
 * Shows clear comparison for completed intervals
 */
async function buildExtendedTimeline() {
    const apiUrl = `/api/oig_cloud/battery_forecast/${INVERTER_SN}/timeline?type=active`;

    try {
        const response = await fetch(apiUrl);
        if (!response.ok) {
            console.error('[Extended Timeline] Failed to fetch data:', response.status);
            return;
        }

        const data = await response.json();
        const timelineExtended = data.timeline_extended;
        const dailyPlanState = data.daily_plan_state;

        // today_tile_summary je UVNIT≈ò timeline_extended (API struktura)
        const todayTileSummary = timelineExtended?.today_tile_summary;

        if (!timelineExtended || !timelineExtended.today) {
            console.warn('[Extended Timeline] No today data available');
            return;
        }

        console.log('[Extended Timeline] Loaded TODAY data:', {
            intervals: timelineExtended.today?.intervals?.length || 0,
            dailyPlanStatus: dailyPlanState?.status,
            todayTileSummary: todayTileSummary ? 'present' : 'missing'
        });

        // NOTE: renderTodayComparison() removed - replaced by Today Plan Tile
        // Old timeline comparison view is deprecated

        // Update Today Plan Tile (event-driven refresh)
        if (todayTileSummary) {
            renderTodayPlanTile(todayTileSummary);
        }

        // Update Unified Cost Tile (event-driven refresh)
        // Load unified_cost_tile from API endpoint
        await loadUnifiedCostTile();

    } catch (error) {
        console.error('[Extended Timeline] Error fetching data:', error);
    }
}


/**
 * Render Today Plan Tile - live tracking of today's plan vs actual with EOD prediction
 * Event-driven refresh triggered by buildExtendedTimeline()
 */
function renderTodayPlanTile(tileSummary) {
    const container = document.getElementById('today-plan-tile-container');
    if (!container) {
        console.warn('[Today Plan Tile] Container not found - skipping render');
        return;
    }

    // Lazy load TodayPlanTile class if not already loaded
    if (typeof TodayPlanTile === 'undefined') {
        console.log('[Today Plan Tile] Loading module...');
        const script = document.createElement('script');
        script.type = 'module';
        script.src = 'modules/today-plan-tile.js';  // Relativn√≠ cesta (stejn√Ω z√°klad jako dashboard-core.js)
        script.onload = () => {
            console.log('[Today Plan Tile] Module loaded, rendering...');
            initTodayPlanTile(container, tileSummary);
        };
        script.onerror = () => {
            console.error('[Today Plan Tile] Failed to load module');
        };
        document.head.appendChild(script);
        return;
    }

    // Update existing instance or create new one
    if (todayPlanTileInstance) {
        console.log('[Today Plan Tile] Updating existing instance');
        todayPlanTileInstance.update(tileSummary);
    } else {
        console.log('[Today Plan Tile] Creating new instance');
        initTodayPlanTile(container, tileSummary);
    }
}


/**
 * Initialize Today Plan Tile instance
 * @param {HTMLElement} container - Container element
 * @param {object} tileSummary - Tile summary data from API
 */
function initTodayPlanTile(container, tileSummary) {
    try {
        todayPlanTileInstance = new TodayPlanTile(
            container,
            tileSummary,
            () => {
                // Click handler - open timeline dialog and show DNES tab
                console.log('[Today Plan Tile] Opening timeline dialog with DNES view...');

                // Initialize dialog if needed
                if (!timelineDialogInstance) {
                    initTimelineDialog();
                }

                // Open dialog (will automatically show 'today' tab via TimelineDialog.open())
                timelineDialogInstance.open();
            }
        );
        console.log('[Today Plan Tile] Instance created successfully');
    } catch (error) {
        console.error('[Today Plan Tile] Failed to create instance:', error);
    }
}


/**
 * Load Unified Cost Tile data from API endpoint
 * PLAN_VS_ACTUAL_UX_REDESIGN_V2.md - F√°ze 1 (UCT-FE-001)
 */
async function loadUnifiedCostTile() {
    try {
        console.log('[Unified Cost Tile] Loading data from API...');
        const response = await fetch(`/api/oig_cloud/battery_forecast/${INVERTER_SN}/unified_cost_tile`);

        if (!response.ok) {
            console.error('[Unified Cost Tile] API error:', response.status);
            return;
        }

        const data = await response.json();
        console.log('[Unified Cost Tile] Data loaded from API:', data);

        renderUnifiedCostTile(data);
    } catch (error) {
        console.error('[Unified Cost Tile] Failed to load from API:', error);
    }
}

/**
 * Render Unified Cost Tile - consolidated view of today/yesterday/tomorrow costs
 * PLAN_VS_ACTUAL_UX_REDESIGN_V2.md - F√°ze 1 (UCT-FE-001)
 * Event-driven refresh triggered by buildExtendedTimeline()
 */
let unifiedCostTileInstance = null;

function renderUnifiedCostTile(unifiedCostData) {
    const container = document.getElementById('unified-cost-tile-container');
    if (!container) {
        console.warn('[Unified Cost Tile] Container not found - skipping render');
        return;
    }

    // Lazy load UnifiedCostTile class if not already loaded
    if (typeof UnifiedCostTile === 'undefined') {
        console.log('[Unified Cost Tile] Loading module...');
        const script = document.createElement('script');
        script.src = 'modules/unified-cost-tile.js';
        script.onload = () => {
            console.log('[Unified Cost Tile] Module loaded, rendering...');
            initUnifiedCostTile(container, unifiedCostData);
        };
        script.onerror = () => {
            console.error('[Unified Cost Tile] Failed to load module');
        };
        document.head.appendChild(script);
        return;
    }

    // Update existing instance or create new one
    if (unifiedCostTileInstance) {
        console.log('[Unified Cost Tile] Updating existing instance');
        unifiedCostTileInstance.update(unifiedCostData);
    } else {
        console.log('[Unified Cost Tile] Creating new instance');
        initUnifiedCostTile(container, unifiedCostData);
    }
}

/**
 * Initialize Unified Cost Tile instance
 * @param {HTMLElement} container - Container element
 * @param {object} unifiedCostData - unified_cost_tile data from sensor attributes
 */
function initUnifiedCostTile(container, unifiedCostData) {
    try {
        unifiedCostTileInstance = new UnifiedCostTile(
            container,
            unifiedCostData,
            () => {
                // Click handler - open timeline dialog and show DNES tab
                console.log('[Unified Cost Tile] Opening timeline dialog with DNES view...');

                // Initialize dialog if needed
                if (!timelineDialogInstance) {
                    initTimelineDialog();
                }

                // Open dialog (will automatically show 'today' tab)
                timelineDialogInstance.open();
            }
        );
        console.log('[Unified Cost Tile] Instance created successfully');
    } catch (error) {
        console.error('[Unified Cost Tile] Failed to create instance:', error);
    }
}


/**
 * Render TODAY's plan vs actual comparison + future intervals
 * FIRST: "Pr≈Øbƒõ≈æn√Ω v√Ωsledek" (completed intervals with plan vs actual)
 * THEN: "Nadch√°zej√≠c√≠ intervaly" (future planned intervals)
 */
function renderTodayComparison(todayData, dailyPlanState) {
    const container = document.getElementById('extended-timeline-container');
    if (!container) {
        console.warn('[Extended Timeline] Container not found');
        return;
    }

    const { date, intervals, summary } = todayData;

    if (!intervals || intervals.length === 0) {
        container.innerHTML = `
            <div class="today-comparison">
                <p class="no-data" style="padding: 40px; text-align: center; color: var(--text-tertiary);">
                    üìÖ ≈Ω√°dn√° data pro dne≈°n√≠ porovn√°n√≠
                </p>
            </div>
        `;
        return;
    }

    // Split intervals: historical (completed) vs future (planned)
    const historicalIntervals = intervals.filter(i => i.status === 'historical' && i.actual && i.planned);
    const futureIntervals = intervals.filter(i => i.status !== 'historical');

    let html = '<div class="today-comparison">';

    // Header with summary stats
    html += `
        <div class="comparison-header">
            <h2>üìä Dnes (${date}) - Pl√°n vs Skuteƒçnost</h2>
    `;

    if (summary && historicalIntervals.length > 0) {
        const deltaClass = summary.delta_cost > 0 ? 'worse' : 'better';
        const deltaIcon = summary.delta_cost > 0 ? 'üìà' : 'üìâ';

        html += `
            <div class="summary-cards">
                <div class="summary-card">
                    <div class="card-label">Pl√°novan√© n√°klady</div>
                    <div class="card-value">${summary.planned_total_cost?.toFixed(2) || '0.00'} Kƒç</div>
                </div>
                <div class="summary-card">
                    <div class="card-label">Skuteƒçn√© n√°klady</div>
                    <div class="card-value">${summary.actual_total_cost?.toFixed(2) || '0.00'} Kƒç</div>
                </div>
                <div class="summary-card ${deltaClass}">
                    <div class="card-label">${deltaIcon} Rozd√≠l</div>
                    <div class="card-value ${deltaClass}">
                        ${summary.delta_cost > 0 ? '+' : ''}${summary.delta_cost?.toFixed(2) || '0.00'} Kƒç
                    </div>
                    <div class="card-sublabel">${summary.delta_cost > 0 ? 'Dr√°≈æ ne≈æ pl√°n' : 'Levnƒõji ne≈æ pl√°n'}</div>
                </div>
                <div class="summary-card">
                    <div class="card-label">P≈ôesnost re≈æim≈Ø</div>
                    <div class="card-value">${summary.accuracy_pct?.toFixed(0) || '0'}%</div>
                    <div class="card-sublabel">${historicalIntervals.length} interval≈Ø dokonƒçeno</div>
                </div>
            </div>
        `;
    }

    html += '</div>'; // comparison-header

    // Only show if there are historical intervals
    if (historicalIntervals.length === 0) {
        html += `
            <div class="no-historical" style="padding: 40px; text-align: center; color: var(--text-secondary);">
                ‚è≥ Zat√≠m neprobƒõhl ≈æ√°dn√Ω interval.<br>
                <span style="font-size: 0.9em;">Porovn√°n√≠ bude k dispozici po dokonƒçen√≠ prvn√≠ho intervalu.</span>
            </div>
        `;
    } else {
        // Find top 3 worst deviations
        const sortedByDelta = [...historicalIntervals]
            .filter(i => i.delta && Math.abs(i.delta.net_cost) > 0.01)
            .sort((a, b) => Math.abs(b.delta.net_cost) - Math.abs(a.delta.net_cost))
            .slice(0, 3);

        if (sortedByDelta.length > 0) {
            html += `
                <div class="top-deviations">
                    <h3>‚ö†Ô∏è Nejvƒõt≈°√≠ odchylky od pl√°nu</h3>
                    <div class="deviation-list">
            `;

            sortedByDelta.forEach((interval, idx) => {
                const time = new Date(interval.time);
                const timeStr = `${time.getHours().toString().padStart(2, '0')}:${time.getMinutes().toString().padStart(2, '0')}`;
                const delta = interval.delta;
                const deltaClass = delta.net_cost > 0 ? 'worse' : 'better';
                const icon = idx === 0 ? 'ü•á' : idx === 1 ? 'ü•à' : 'ü•â';

                html += `
                    <div class="deviation-item ${deltaClass}">
                        <span class="rank">${icon}</span>
                        <span class="time">${timeStr}</span>
                        <span class="modes">
                            ${interval.planned.mode_name} ‚Üí ${interval.actual.mode_name}
                        </span>
                        <span class="delta ${deltaClass}">
                            ${delta.net_cost > 0 ? '+' : ''}${delta.net_cost.toFixed(2)} Kƒç
                        </span>
                    </div>
                `;
            });

            html += `
                    </div>
                </div>
            `;
        }

        // Detailed comparison table
        html += `
            <div class="comparison-table">
                <h3>üìã Detail v≈°ech dokonƒçen√Ωch interval≈Ø</h3>
                <table>
                    <thead>
                        <tr>
                            <th>ƒåas</th>
                            <th>Pl√°n</th>
                            <th>Skuteƒçnost</th>
                            <th>SOC pl√°n</th>
                            <th>SOC skuteƒçnost</th>
                            <th>N√°klady pl√°n</th>
                            <th>N√°klady skuteƒçnost</th>
                            <th>Rozd√≠l</th>
                        </tr>
                    </thead>
                    <tbody>
        `;

        historicalIntervals.forEach(interval => {
            const time = new Date(interval.time);
            const timeStr = `${time.getHours().toString().padStart(2, '0')}:${time.getMinutes().toString().padStart(2, '0')}`;
            const planned = interval.planned;
            const actual = interval.actual;
            const delta = interval.delta;

            const modeMatch = planned.mode_name === actual.mode_name;
            const modeIcon = modeMatch ? '‚úÖ' : '‚ùå';
            const deltaClass = delta && delta.net_cost > 0 ? 'worse' : delta && delta.net_cost < 0 ? 'better' : '';

            const plannedModeConfig = MODE_CONFIG[planned.mode_name] || MODE_CONFIG['HOME I'];
            const actualModeConfig = MODE_CONFIG[actual.mode_name] || MODE_CONFIG['HOME I'];

            html += `
                <tr class="${modeMatch ? 'match' : 'mismatch'}">
                    <td class="time-cell">${timeStr}</td>
                    <td class="mode-cell">
                        <span class="mode-badge" style="background: ${plannedModeConfig.color};">
                            ${planned.mode_name}
                        </span>
                    </td>
                    <td class="mode-cell">
                        ${modeIcon}
                        <span class="mode-badge" style="background: ${actualModeConfig.color};">
                            ${actual.mode_name}
                        </span>
                    </td>
                    <td class="soc-cell">${planned.battery_soc?.toFixed(0) || '-'}%</td>
                    <td class="soc-cell">${actual.battery_soc?.toFixed(0) || '-'}%</td>
                    <td class="cost-cell">${planned.net_cost?.toFixed(2) || '0.00'} Kƒç</td>
                    <td class="cost-cell">${actual.net_cost?.toFixed(2) || '0.00'} Kƒç</td>
                    <td class="delta-cell ${deltaClass}">
                        ${delta && delta.net_cost ?
                            `${delta.net_cost > 0 ? '+' : ''}${delta.net_cost.toFixed(2)} Kƒç` :
                            '0.00 Kƒç'
                        }
                    </td>
                </tr>
            `;
        });

        html += `
                    </tbody>
                </table>
            </div>
        `;
    }

    // === SEKCE 2: NADCH√ÅZEJ√çC√ç INTERVALY ===
    if (futureIntervals.length > 0) {
        html += `
            <div class="future-intervals-section" style="margin-top: 30px; padding-top: 20px; border-top: 2px solid rgba(255,255,255,0.1);">
                <h3>üîÆ Nadch√°zej√≠c√≠ intervaly (${futureIntervals.length})</h3>
                <table>
                    <thead>
                        <tr>
                            <th>ƒåas</th>
                            <th>Pl√°novan√Ω re≈æim</th>
                            <th>SOC pl√°n</th>
                            <th>N√°klady pl√°n</th>
                            <th>Spotov√° cena</th>
                        </tr>
                    </thead>
                    <tbody>
        `;

        futureIntervals.forEach(interval => {
            const time = new Date(interval.time);
            const timeStr = `${time.getHours().toString().padStart(2, '0')}:${time.getMinutes().toString().padStart(2, '0')}`;
            const planned = interval.planned;
            const plannedModeConfig = MODE_CONFIG[planned?.mode_name] || MODE_CONFIG['HOME I'];
            const isActive = interval.status === 'active';

            html += `
                <tr class="${isActive ? 'active-interval' : ''}">
                    <td class="time-cell">${timeStr}${isActive ? ' ‚è±Ô∏è' : ''}</td>
                    <td class="mode-cell">
                        <span class="mode-badge" style="background: ${plannedModeConfig.color};">
                            ${planned?.mode_name || 'N/A'}
                        </span>
                    </td>
                    <td class="soc-cell">${planned?.battery_soc?.toFixed(0) || '-'}%</td>
                    <td class="cost-cell">${planned?.net_cost?.toFixed(2) || '0.00'} Kƒç</td>
                    <td class="cost-cell">${planned?.spot_price?.toFixed(2) || '0.00'} Kƒç/kWh</td>
                </tr>
            `;
        });

        html += `
                    </tbody>
                </table>
            </div>
        `;
    }

    html += '</div>'; // today-comparison

    container.innerHTML = html;
}


// =============================================================================
// PHASE 2.10: YESTERDAY ANALYSIS - Vƒçerej≈°√≠ pl√°n vs skuteƒçnost
// =============================================================================

/**
 * Build yesterday's plan vs actual analysis
 */
async function buildYesterdayAnalysis() {
    const apiUrl = `/api/oig_cloud/battery_forecast/${INVERTER_SN}/timeline?type=active`;

    try {
        const response = await fetch(apiUrl);
        if (!response.ok) {
            console.error('[Yesterday Analysis] Failed to fetch data:', response.status);
            return;
        }

        const data = await response.json();
        const timelineExtended = data.timeline_extended;

        if (!timelineExtended || !timelineExtended.yesterday) {
            console.warn('[Yesterday Analysis] No yesterday data available');
            showYesterdayNoData();
            return;
        }

        console.log('[Yesterday Analysis] Loaded YESTERDAY data:', {
            intervals: timelineExtended.yesterday?.intervals?.length || 0,
            summary: timelineExtended.yesterday?.summary
        });

        // Render yesterday's analysis
        renderYesterdayAnalysis(timelineExtended.yesterday);

    } catch (error) {
        console.error('[Yesterday Analysis] Error fetching data:', error);
        showYesterdayNoData();
    }
}


/**
 * Show "no data" message for yesterday
 */
function showYesterdayNoData() {
    const container = document.getElementById('yesterday-timeline-container');
    if (!container) return;

    container.innerHTML = `
        <div style="padding: 60px 20px; text-align: center;">
            <div style="font-size: 3em; margin-bottom: 20px; opacity: 0.3;">üìÖ</div>
            <h3 style="color: var(--text-secondary); margin-bottom: 10px;">Vƒçerej≈°√≠ data nejsou k dispozici</h3>
            <p style="color: var(--text-tertiary); font-size: 0.9em;">
                Data se archivuj√≠ automaticky ka≈æd√Ω den o p≈Ølnoci.<br>
                Pokud jste integraci spustili dnes, vƒçerej≈°√≠ data je≈°tƒõ nejsou k dispozici.
            </p>
        </div>
    `;
}


/**
 * Render yesterday's plan vs actual analysis
 */
function renderYesterdayAnalysis(yesterdayData) {
    const container = document.getElementById('yesterday-timeline-container');
    if (!container) {
        console.warn('[Yesterday Analysis] Container not found');
        return;
    }

    const { date, intervals, summary } = yesterdayData;

    if (!intervals || intervals.length === 0) {
        showYesterdayNoData();
        return;
    }

    // Filter only historical (completed) intervals
    const historicalIntervals = intervals.filter(i => i.status === 'historical' && i.actual && i.planned);

    let html = '<div class="yesterday-analysis">';

    // Header with date
    html += `
        <div class="analysis-header">
            <h2>üìä Vƒçera (${date}) - Pl√°n vs Skuteƒçnost</h2>
        </div>
    `;

    // Summary cards
    if (summary && historicalIntervals.length > 0) {
        const deltaClass = summary.delta_cost > 0 ? 'worse' : 'better';
        const deltaIcon = summary.delta_cost > 0 ? 'üìà' : 'üìâ';
        const deltaPct = summary.delta_cost !== null && summary.planned_total_cost > 0
            ? ((summary.delta_cost / summary.planned_total_cost) * 100).toFixed(1)
            : '0.0';

        html += `
            <div class="summary-cards">
                <div class="summary-card">
                    <div class="card-label">üí∞ Pl√°novan√© n√°klady</div>
                    <div class="card-value">${summary.planned_total_cost?.toFixed(2) || '0.00'} Kƒç</div>
                </div>
                <div class="summary-card">
                    <div class="card-label">üí∏ Skuteƒçn√© n√°klady</div>
                    <div class="card-value">${summary.actual_total_cost?.toFixed(2) || '0.00'} Kƒç</div>
                </div>
                <div class="summary-card ${deltaClass}">
                    <div class="card-label">${deltaIcon} V√Ωsledek</div>
                    <div class="card-value ${deltaClass}">
                        ${summary.delta_cost > 0 ? '+' : ''}${summary.delta_cost?.toFixed(2) || '0.00'} Kƒç
                    </div>
                    <div class="card-sublabel ${deltaClass}">
                        ${summary.delta_cost > 0 ? '‚ùå' : '‚úÖ'} ${deltaPct}% ${summary.delta_cost > 0 ? 'hor≈°√≠' : 'lep≈°√≠'}
                    </div>
                </div>
                <div class="summary-card">
                    <div class="card-label">üéØ P≈ôesnost re≈æim≈Ø</div>
                    <div class="card-value">${summary.accuracy_pct?.toFixed(0) || '0'}%</div>
                    <div class="card-sublabel">${historicalIntervals.length}/96 interval≈Ø</div>
                </div>
            </div>
        `;
    } else {
        html += `
            <div style="padding: 40px; text-align: center; color: var(--text-secondary);">
                ‚ÑπÔ∏è Vƒçerej≈°√≠ data jsou ne√∫pln√° nebo se je≈°tƒõ zpracov√°vaj√≠.
            </div>
        `;
    }

    html += '</div>'; // yesterday-analysis

    container.innerHTML = html;
}

// Global function for toggling interval details
window.toggleIntervalDetail = function(intervalId) {
    const detailEl = document.getElementById(`interval-detail-${intervalId}`);
    const rowEl = document.querySelector(`[data-interval-id="${intervalId}"]`);

    if (detailEl && rowEl) {
        const isVisible = detailEl.style.display !== 'none';
        detailEl.style.display = isVisible ? 'none' : 'block';

        if (isVisible) {
            rowEl.classList.remove('expanded');
        } else {
            rowEl.classList.add('expanded');
        }
    }
};

// Global function for toggling section collapse
window.toggleSection = function(sectionId) {
    const sectionEl = document.getElementById(sectionId);
    const headerEl = sectionEl?.parentElement.querySelector('.section-header');

    if (sectionEl && headerEl) {
        const isVisible = sectionEl.style.display !== 'none';
        sectionEl.style.display = isVisible ? 'none' : 'block';

        const toggleEl = headerEl.querySelector('.section-toggle');
        if (toggleEl) {
            toggleEl.textContent = isVisible ? '‚ñ∂' : '‚ñº';
        }

        if (isVisible) {
            headerEl.parentElement.classList.add('collapsed');
        } else {
            headerEl.parentElement.classList.remove('collapsed');
        }
    }
};




