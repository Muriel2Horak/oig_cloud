const INVERTER_SN = new URLSearchParams(window.location.search).get('inverter_sn') || '2206237016';

// === LAYOUT (using dashboard-layout.js module) ===
// Import layout functions
const getCurrentBreakpoint = window.DashboardLayout.getCurrentBreakpoint;
const saveLayout = window.DashboardLayout.saveLayout;
const loadLayout = window.DashboardLayout.loadLayout;
const resetLayout = window.DashboardLayout.resetLayout;
const toggleEditMode = window.DashboardLayout.toggleEditMode;

// === GLOBAL VARIABLES FOR CHART DATA ===

// Detekce viewportu
function getCurrentBreakpoint() {
    const width = window.innerWidth;
    if (width <= 768) return 'mobile';
    if (width <= 1024) return 'tablet';
    return 'desktop';
}

// UloÅ¾enÃ­ layoutu pro aktuÃ¡lnÃ­ breakpoint
function saveLayout(breakpoint, positions) {
    const key = `oig-layout-${breakpoint}`;
    localStorage.setItem(key, JSON.stringify(positions));
    console.log(`[Layout] Saved ${breakpoint} layout:`, positions);
}

// NaÄtenÃ­ layoutu pro aktuÃ¡lnÃ­ breakpoint
function loadLayout(breakpoint) {
    const key = `oig-layout-${breakpoint}`;
    const saved = localStorage.getItem(key);

    if (saved) {
        try {
            const positions = JSON.parse(saved);
            console.log(`[Layout] Loading ${breakpoint} layout:`, positions);
            applyCustomPositions(positions);
            return true;
        } catch (e) {
            console.error(`[Layout] Failed to parse ${breakpoint} layout:`, e);
            return false;
        }
    }
    return false;
}

// Aplikace custom pozic
function applyCustomPositions(positions) {
    const nodes = ['solar', 'grid-node', 'battery', 'house', 'inverter'];

    nodes.forEach(nodeClass => {
        const node = document.querySelector(`.${nodeClass}`);
        if (!node || !positions[nodeClass]) return;

        const pos = positions[nodeClass];

        // Aplikovat pozice
        if (pos.top !== undefined) node.style.top = pos.top;
        if (pos.left !== undefined) node.style.left = pos.left;
        if (pos.right !== undefined) node.style.right = pos.right;
        if (pos.bottom !== undefined) node.style.bottom = pos.bottom;
        if (pos.transform !== undefined) node.style.transform = pos.transform;
    });

    // Invalidovat cache a pÅ™epoÄÃ­tat ÄÃ¡ry a ÄÃ¡stice
    invalidateNodeCentersCache();
    if (typeof drawConnections === 'function') {
        drawConnections();
    }
    if (typeof updateAllParticleFlows === 'function') {
        updateAllParticleFlows();
    }
}

// Reset layoutu pro aktuÃ¡lnÃ­ breakpoint
function resetLayout(breakpoint) {
    const key = `oig-layout-${breakpoint}`;
    localStorage.removeItem(key);
    console.log(`[Layout] Reset ${breakpoint} layout`);

    // Odstranit inline styles a vrÃ¡tit k CSS variables
    const nodes = document.querySelectorAll('.solar, .grid-node, .battery, .house, .inverter');
    nodes.forEach(node => {
        node.style.top = '';
        node.style.left = '';
        node.style.right = '';
        node.style.bottom = '';
        node.style.transform = '';
    });

    // Invalidovat cache a pÅ™epoÄÃ­tat ÄÃ¡ry a ÄÃ¡stice
    invalidateNodeCentersCache();
    if (typeof drawConnections === 'function') {
        drawConnections();
    }
    if (typeof updateAllParticleFlows === 'function') {
        updateAllParticleFlows();
    }
}

// Toggle edit mode
function toggleEditMode() {
    editMode = !editMode;
    const canvas = document.querySelector('.flow-canvas');
    const btn = document.getElementById('edit-layout-btn');

    if (editMode) {
        canvas.classList.add('edit-mode');
        if (btn) btn.classList.add('active');
        console.log('[Layout] Edit mode enabled');
        initializeDragAndDrop();
    } else {
        canvas.classList.remove('edit-mode');
        if (btn) btn.classList.remove('active');
        console.log('[Layout] Edit mode disabled');
    }
}

// Inicializace drag & drop
function initializeDragAndDrop() {
    const nodes = document.querySelectorAll('.solar, .grid-node, .battery, .house, .inverter');

    nodes.forEach(node => {
        // Mouse events
        node.addEventListener('mousedown', handleDragStart);

        // Touch events
        node.addEventListener('touchstart', handleTouchStart, { passive: false });
    });

    // Global handlers
    document.addEventListener('mousemove', handleDragMove);
    document.addEventListener('mouseup', handleDragEnd);
    document.addEventListener('touchmove', handleTouchMove, { passive: false });
    document.addEventListener('touchend', handleTouchEnd);
}

// Mouse drag handlers
function handleDragStart(e) {
    if (!editMode) return;

    e.preventDefault();
    draggedNode = e.target.closest('.node');
    if (!draggedNode) return;

    draggedNode.classList.add('dragging');

    const rect = draggedNode.getBoundingClientRect();
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    dragStartTop = rect.top;
    dragStartLeft = rect.left;

    console.log('[Drag] Started:', draggedNode.className);
}

function handleDragMove(e) {
    if (!draggedNode || !editMode) return;

    e.preventDefault();

    const canvas = document.querySelector('.flow-canvas');
    const canvasRect = canvas.getBoundingClientRect();

    const deltaX = e.clientX - dragStartX;
    const deltaY = e.clientY - dragStartY;

    const newLeft = dragStartLeft + deltaX;
    const newTop = dragStartTop + deltaY;

    // Constraints - keep within canvas
    const nodeRect = draggedNode.getBoundingClientRect();
    const minLeft = canvasRect.left;
    const maxLeft = canvasRect.right - nodeRect.width;
    const minTop = canvasRect.top;
    const maxTop = canvasRect.bottom - nodeRect.height;

    const constrainedLeft = Math.max(minLeft, Math.min(maxLeft, newLeft));
    const constrainedTop = Math.max(minTop, Math.min(maxTop, newTop));

    // PÅ™evÃ©st na pozice relativnÃ­ k canvas
    const relativeLeft = ((constrainedLeft - canvasRect.left) / canvasRect.width) * 100;
    const relativeTop = ((constrainedTop - canvasRect.top) / canvasRect.height) * 100;

    draggedNode.style.left = `${relativeLeft}%`;
    draggedNode.style.top = `${relativeTop}%`;
    draggedNode.style.right = 'auto';
    draggedNode.style.bottom = 'auto';
    draggedNode.style.transform = 'none';

    // Live update Äar a ÄÃ¡stic bÄ›hem taÅ¾enÃ­
    invalidateNodeCentersCache();
    if (typeof drawConnections === 'function') {
        drawConnections();
    }
}

function handleDragEnd(e) {
    if (!draggedNode || !editMode) return;

    e.preventDefault();

    draggedNode.classList.remove('dragging');

    // UloÅ¾it pozice
    saveCurrentLayout();

    // FinÃ¡lnÃ­ update Äar a ÄÃ¡stic
    invalidateNodeCentersCache();
    if (typeof drawConnections === 'function') {
        drawConnections();
    }
    if (typeof updateAllParticleFlows === 'function') {
        updateAllParticleFlows();
    }

    console.log('[Drag] Ended');
    draggedNode = null;
}

// Touch handlers
function handleTouchStart(e) {
    if (!editMode) return;

    e.preventDefault();
    draggedNode = e.target.closest('.node');
    if (!draggedNode) return;

    draggedNode.classList.add('dragging');

    const touch = e.touches[0];
    const rect = draggedNode.getBoundingClientRect();

    dragStartX = touch.clientX;
    dragStartY = touch.clientY;
    dragStartTop = rect.top;
    dragStartLeft = rect.left;

    console.log('[Touch] Started:', draggedNode.className);
}

function handleTouchMove(e) {
    if (!draggedNode || !editMode) return;

    e.preventDefault();

    const touch = e.touches[0];
    const canvas = document.querySelector('.flow-canvas');
    const canvasRect = canvas.getBoundingClientRect();

    const deltaX = touch.clientX - dragStartX;
    const deltaY = touch.clientY - dragStartY;

    const newLeft = dragStartLeft + deltaX;
    const newTop = dragStartTop + deltaY;

    // Constraints
    const nodeRect = draggedNode.getBoundingClientRect();
    const minLeft = canvasRect.left;
    const maxLeft = canvasRect.right - nodeRect.width;
    const minTop = canvasRect.top;
    const maxTop = canvasRect.bottom - nodeRect.height;

    const constrainedLeft = Math.max(minLeft, Math.min(maxLeft, newLeft));
    const constrainedTop = Math.max(minTop, Math.min(maxTop, newTop));

    // RelativnÃ­ pozice
    const relativeLeft = ((constrainedLeft - canvasRect.left) / canvasRect.width) * 100;
    const relativeTop = ((constrainedTop - canvasRect.top) / canvasRect.height) * 100;

    draggedNode.style.left = `${relativeLeft}%`;
    draggedNode.style.top = `${relativeTop}%`;
    draggedNode.style.right = 'auto';
    draggedNode.style.bottom = 'auto';
    draggedNode.style.transform = 'none';

    // Live update Äar bÄ›hem touch taÅ¾enÃ­
    invalidateNodeCentersCache();
    if (typeof drawConnections === 'function') {
        drawConnections();
    }
}

function handleTouchEnd(e) {
    if (!draggedNode || !editMode) return;

    e.preventDefault();

    draggedNode.classList.remove('dragging');

    // UloÅ¾it pozice
    saveCurrentLayout();

    // FinÃ¡lnÃ­ update Äar a ÄÃ¡stic
    invalidateNodeCentersCache();
    if (typeof drawConnections === 'function') {
        drawConnections();
    }
    if (typeof updateAllParticleFlows === 'function') {
        updateAllParticleFlows();
    }

    console.log('[Touch] Ended');
    draggedNode = null;
}

// UloÅ¾it aktuÃ¡lnÃ­ pozice vÅ¡ech nodes
function saveCurrentLayout() {
    const breakpoint = getCurrentBreakpoint();
    const canvas = document.querySelector('.flow-canvas');
    const canvasRect = canvas.getBoundingClientRect();

    const positions = {};
    const nodes = {
        'solar': document.querySelector('.solar'),
        'grid-node': document.querySelector('.grid-node'),
        'battery': document.querySelector('.battery'),
        'house': document.querySelector('.house'),
        'inverter': document.querySelector('.inverter')
    };

    Object.entries(nodes).forEach(([key, node]) => {
        if (!node) return;

        const rect = node.getBoundingClientRect();
        const relativeLeft = ((rect.left - canvasRect.left) / canvasRect.width) * 100;
        const relativeTop = ((rect.top - canvasRect.top) / canvasRect.height) * 100;

        positions[key] = {
            top: `${relativeTop}%`,
            left: `${relativeLeft}%`,
            right: 'auto',
            bottom: 'auto',
            transform: 'none'
        };
    });

    saveLayout(breakpoint, positions);
}

// Invalidace cache pro node centers
function invalidateNodeCentersCache() {
    if (typeof window.lastLayoutHash !== 'undefined') {
        window.lastLayoutHash = null;
    }
    if (typeof window.cachedNodeCenters !== 'undefined') {
        window.cachedNodeCenters = null;
    }
}

// Debounced resize handler
let resizeTimer = null;
function handleLayoutResize() {
    if (resizeTimer) clearTimeout(resizeTimer);

    resizeTimer = setTimeout(() => {
        const newBreakpoint = getCurrentBreakpoint();

        if (newBreakpoint !== currentBreakpoint) {
            console.log(`[Layout] Breakpoint changed: ${currentBreakpoint} â†’ ${newBreakpoint}`);
            currentBreakpoint = newBreakpoint;

            // NaÄÃ­st layout pro novÃ½ breakpoint
            const loaded = loadLayout(newBreakpoint);
            if (!loaded) {
                console.log(`[Layout] No custom ${newBreakpoint} layout, using defaults`);
            }
        }

        // OPRAVA: VÅ¾dy pÅ™ekreslit ÄÃ¡ry pÅ™i resize (i bez zmÄ›ny breakpointu)
        // protoÅ¾e pozice nodes se mÄ›nÃ­ v % â†’ zmÄ›na pixel pozic
        invalidateNodeCentersCache();
        if (typeof drawConnections === 'function') {
            drawConnections();
        }
        if (typeof updateAllParticleFlows === 'function') {
            updateAllParticleFlows();
        }
    }, 300);
}

// === GLOBAL VARIABLES FOR CHART DATA ===
// Store complete dataset for extremes calculation regardless of zoom
let originalPriceData = null;

// === TOOLTIP POSITIONING ===

// === CONTROL PANEL FUNCTIONS ===

// Toggle control panel
function toggleControlPanel() {
    const panel = document.getElementById('control-panel');
    const icon = document.getElementById('panel-toggle-icon');
    panel.classList.toggle('minimized');
    icon.textContent = panel.classList.contains('minimized') ? '+' : 'âˆ’';
}

// Toggle queue section
// === SHIELD (moved to dashboard-shield.js) ===
// Import shield functions
const startShieldQueueLiveUpdate = window.DashboardShield.startShieldQueueLiveUpdate;
const stopShieldQueueLiveUpdate = window.DashboardShield.stopShieldQueueLiveUpdate;
const loadShieldData = window.DashboardShield.loadShieldData;
const debouncedShieldMonitor = window.DashboardShield.debouncedShieldMonitor;
const setShieldMode = window.DashboardShield.setShieldMode;
const setShieldModeWithConfirmation = window.DashboardShield.setShieldModeWithConfirmation;
const cancelShieldAction = window.DashboardShield.cancelShieldAction;
const loadControlPanelStatus = window.DashboardShield.loadControlPanelStatus;
}

// === FLOW DIAGRAM (moved to dashboard-flow.js) ===
// Import functions from DashboardFlow module
const getSensorId = window.DashboardFlow.getSensorId;
const findShieldSensorId = window.DashboardFlow.findShieldSensorId;
const updateTime = window.DashboardFlow.updateTime;
const debouncedDrawConnections = window.DashboardFlow.debouncedDrawConnections;
const drawConnections = window.DashboardFlow.drawConnections;
const getNodeCenters = window.DashboardFlow.getNodeCenters;
const updateNode = window.DashboardFlow.updateNode;
const updateNodeDetails = window.DashboardFlow.updateNodeDetails;
const loadData = window.DashboardFlow.loadData;
const debouncedLoadData = window.DashboardFlow.debouncedLoadData;
const debouncedLoadNodeDetails = window.DashboardFlow.debouncedLoadNodeDetails;

// Find shield sensor dynamically (may have suffix like _2, _3)
function findShieldSensorId(sensorName) {
            btn.disabled = false;
            btn.classList.remove('pending');
        }
    }
}

// Initialize
// === THEME DETECTION ===

/**
 * Detekuje aktuÃ¡lnÃ­ tÃ©ma Home Assistantu a aplikuje sprÃ¡vnÃ© styly
 */
function detectAndApplyTheme() {
    try {
        const hass = getHass();
        const bodyElement = document.body;
        let isLightTheme = false;

        if (hass && hass.themes) {
            // Metoda 1: PÅ™Ã­mÃ½ pÅ™Ã­stup k HA theme konfiguraci (nejspolehlivÄ›jÅ¡Ã­)
            const selectedTheme = hass.selectedTheme || hass.themes.default_theme;
            const darkMode = hass.themes.darkMode;

            // console.log('[Theme] HA theme info:', {
            //     selectedTheme,
            //     darkMode,
            //     themes: hass.themes
            // });

            // HA mÃ¡ explicitnÃ­ dark mode flag
            if (darkMode !== undefined) {
                isLightTheme = !darkMode;
                // console.log('[Theme] Using HA darkMode flag:', darkMode, '-> light theme:', isLightTheme);
            } else if (selectedTheme) {
                // Fallback: nÄ›kterÃ¡ tÃ©mata majÃ­ v nÃ¡zvu "light" nebo "dark"
                const themeName = selectedTheme.toLowerCase();
                if (themeName.includes('light')) {
                    isLightTheme = true;
                } else if (themeName.includes('dark')) {
                    isLightTheme = false;
                }
                // console.log('[Theme] Detected from theme name:', selectedTheme, '-> light:', isLightTheme);
            }
        } else {
            console.warn('[Theme] Cannot access hass.themes, trying CSS detection');
        }

        // Metoda 2: Fallback - detekce z CSS promÄ›nnÃ½ch
        if (!hass || !hass.themes) {
            try {
                const haElement = parent.document.querySelector('home-assistant');
                if (haElement) {
                    const computedStyle = getComputedStyle(haElement);
                    const primaryBg = computedStyle.getPropertyValue('--primary-background-color');

                    if (primaryBg) {
                        const rgb = primaryBg.match(/\d+/g);
                        if (rgb && rgb.length >= 3) {
                            const brightness = (parseInt(rgb[0]) + parseInt(rgb[1]) + parseInt(rgb[2])) / 3;
                            isLightTheme = brightness > 128;
                            console.log('[Theme] CSS detection - brightness:', brightness, '-> light:', isLightTheme);
                        }
                    }
                }
            } catch (e) {
                console.warn('[Theme] CSS detection failed:', e);
            }
        }

        // Aplikovat tÅ™Ã­du na body
        if (isLightTheme) {
            bodyElement.classList.add('light-theme');
            bodyElement.classList.remove('dark-theme');
            // console.log('[Theme] âœ“ Light theme applied');
        } else {
            bodyElement.classList.add('dark-theme');
            bodyElement.classList.remove('light-theme');
            // console.log('[Theme] âœ“ Dark theme applied');
        }

    } catch (error) {
        console.error('[Theme] Error detecting theme:', error);
        // VÃ½chozÃ­: tmavÃ© tÃ©ma
        document.body.classList.add('dark-theme');
        document.body.classList.remove('light-theme');
    }
}

// === TOOLTIP SYSTEM ===

/**
 * GlobÃ¡lnÃ­ tooltip systÃ©m - pouÅ¾Ã­vÃ¡ dedikovanÃ© DOM elementy mimo flow
 * Toto Å™eÅ¡enÃ­ zaruÄuje sprÃ¡vnÃ© pozicovÃ¡nÃ­ bez ohledu na CSS transformace rodiÄÅ¯
 */
function initTooltips() {
    const tooltip = document.getElementById('global-tooltip');
    const arrow = document.getElementById('global-tooltip-arrow');
    const entityValues = document.querySelectorAll('.entity-value[data-tooltip], .entity-value[data-tooltip-html], .detail-value[data-tooltip-html], #battery-grid-charging-indicator[data-tooltip], #battery-grid-charging-indicator[data-tooltip-html], #balancing-planned-time-short[data-tooltip-html], #battery-balancing-indicator[data-tooltip-html]');

    if (!tooltip || !arrow) {
        console.error('[Tooltips] Global tooltip elements not found!');
        return;
    }

    entityValues.forEach(element => {
        element.addEventListener('mouseenter', function () {
            const tooltipText = this.getAttribute('data-tooltip');
            const tooltipHtml = this.getAttribute('data-tooltip-html');

            if (!tooltipText && !tooltipHtml) return;

            // Nastavit text nebo HTML
            if (tooltipHtml) {
                tooltip.innerHTML = tooltipHtml;
            } else {
                tooltip.textContent = tooltipText;
            }

            // ZÃ­skat pozici elementu v rÃ¡mci viewportu
            const rect = this.getBoundingClientRect();

            // Nejprve zobrazit tooltip pro zmÄ›Å™enÃ­ jeho skuteÄnÃ© velikosti
            tooltip.style.visibility = 'hidden';
            tooltip.style.opacity = '1';

            const tooltipRect = tooltip.getBoundingClientRect();
            const tooltipWidth = tooltipRect.width;
            const tooltipHeight = tooltipRect.height;
            const padding = 10;
            const arrowSize = 5;

            // VypoÄÃ­tat pozici tooltipu
            let tooltipTop = rect.top - tooltipHeight - arrowSize - padding;
            let tooltipLeft = rect.left + (rect.width / 2) - (tooltipWidth / 2);

            // Zajistit Å¾e tooltip nenÃ­ mimo viewport (horizontÃ¡lnÄ›)
            const viewportWidth = window.innerWidth;
            if (tooltipLeft < padding) {
                tooltipLeft = padding;
            }
            if (tooltipLeft + tooltipWidth > viewportWidth - padding) {
                tooltipLeft = viewportWidth - tooltipWidth - padding;
            }

            // Kontrola zda se tooltip vejde nad element
            let isBelow = false;
            if (tooltipTop < padding) {
                // Nedostatek mÃ­sta nahoÅ™e - zobrazit dole
                tooltipTop = rect.bottom + arrowSize + padding;
                isBelow = true;
            }

            // Pozice Å¡ipky - vÅ¾dy uprostÅ™ed pÅ¯vodnÃ­ho elementu
            const arrowLeft = rect.left + (rect.width / 2) - arrowSize;
            const arrowTop = isBelow
                ? rect.bottom + padding
                : rect.top - arrowSize - padding;

            // Aplikovat vypoÄÃ­tanÃ© pozice
            tooltip.style.top = `${tooltipTop}px`;
            tooltip.style.left = `${tooltipLeft}px`;
            tooltip.style.visibility = 'visible';

            arrow.style.top = `${arrowTop}px`;
            arrow.style.left = `${arrowLeft}px`;

            // Nastavit smÄ›r Å¡ipky
            if (isBelow) {
                arrow.classList.add('below');
            } else {
                arrow.classList.remove('below');
            }

            // Zobrazit tooltip a Å¡ipku
            tooltip.classList.add('visible');
            arrow.classList.add('visible');
        });

        element.addEventListener('mouseleave', function () {
            // SkrÃ½t tooltip a Å¡ipku
            tooltip.classList.remove('visible');
            arrow.classList.remove('visible');

            // Po animaci schovat mimo obrazovku
            setTimeout(() => {
                if (!tooltip.classList.contains('visible')) {
                    tooltip.style.top = '-9999px';
                    tooltip.style.left = '-9999px';
                    arrow.style.top = '-9999px';
                    arrow.style.left = '-9999px';
                }
            }, 200); // dÃ©lka CSS transition
        });
    });

    // console.log('[Tooltips] Initialized for', entityValues.length, 'elements');
}

// === GRID CHARGING (moved to dashboard-grid-charging.js) ===
const openGridChargingDialog = window.DashboardGridCharging.openGridChargingDialog;
const closeGridChargingDialog = window.DashboardGridCharging.closeGridChargingDialog;

    // Detekovat a aplikovat tÃ©ma z Home Assistantu
    detectAndApplyTheme();

    // === LAYOUT CUSTOMIZATION INITIALIZATION ===
    currentBreakpoint = getCurrentBreakpoint();
    console.log(`[Layout] Initial breakpoint: ${currentBreakpoint}`);

    // NaÄÃ­st custom layout pokud existuje
    const loaded = loadLayout(currentBreakpoint);
    if (loaded) {
        console.log(`[Layout] Custom ${currentBreakpoint} layout loaded`);
    } else {
        console.log(`[Layout] Using default ${currentBreakpoint} layout`);
    }

    // Resize listener pro breakpoint changes
    window.addEventListener('resize', handleLayoutResize);

    // Auto-collapse control panel on mobile
    if (window.innerWidth <= 768) {
        const panel = document.getElementById('control-panel');
        const icon = document.getElementById('panel-toggle-icon');
        if (panel && icon) {
            panel.classList.add('minimized');
            icon.textContent = '+';
        }
    }

    // Initialize tooltip system
    initTooltips();

    // Phase 2.7: Initialize performance tracking chart
    initPerformanceChart();

    // OPRAVA: PoÄkat na dokonÄenÃ­ layout naÄtenÃ­ pÅ™ed volÃ¡nÃ­m loadData()
    // Pokud byl naÄten custom layout, particles byly zastaveny
    // a needsFlowReinitialize je TRUE, takÅ¾e loadData() je restartuje
    setTimeout(() => {
        // Initial full load
        forceFullRefresh();
        updateTime();

        // NOVÃ‰: Load extended timeline for Today Plan Tile
        buildExtendedTimeline();

        // OPRAVA: NaÄÃ­st pricing data pokud je pricing tab aktivnÃ­ pÅ™i naÄtenÃ­ strÃ¡nky
        const pricingTab = document.getElementById('pricing-tab');
        if (pricingTab && pricingTab.classList.contains('active')) {
            console.log('[Init] Pricing tab is active, loading initial pricing data...');
            pricingTabActive = true;
            setTimeout(() => {
                loadPricingData();
            }, 200);
        }
    }, 50);

    // Subscribe to shield state changes for real-time updates
    subscribeToShield();

    // Initial shield UI update with retry logic (wait for sensors after HA restart)
    let retryCount = 0;
    const maxRetries = 10;
    const retryInterval = 2000; // 2s between retries

    function tryInitialShieldLoad() {
        console.log(`[Shield] Attempting initial load (attempt ${retryCount + 1}/${maxRetries})...`);

        // Check if shield sensors are available
        const hass = getHass();
        if (!hass || !hass.states) {
            console.warn('[Shield] HA connection not ready, will retry...');
            retryCount++;
            if (retryCount < maxRetries) {
                setTimeout(tryInitialShieldLoad, retryInterval);
            } else {
                console.error('[Shield] Failed to load after', maxRetries, 'attempts');
                console.warn('[Shield] Falling back to 20s polling as backup');
                // Fallback: Enable backup polling if initial load fails
                setInterval(() => {
                    console.log('[Shield] Backup polling triggered');
                    monitorShieldActivity();
                    updateShieldQueue();
                    updateShieldUI();
                    updateButtonStates();
                }, 20000);
            }
            return;
        }

        const activitySensorId = findShieldSensorId('service_shield_activity');
        if (!activitySensorId || !hass.states[activitySensorId]) {
            console.warn('[Shield] Shield sensors not ready yet, will retry...');
            retryCount++;
            if (retryCount < maxRetries) {
                setTimeout(tryInitialShieldLoad, retryInterval);
            } else {
                console.error('[Shield] Shield sensors not available after', maxRetries, 'attempts');
                console.warn('[Shield] Falling back to 20s polling as backup');
                // Fallback: Enable backup polling if sensors not available
                setInterval(() => {
                    console.log('[Shield] Backup polling triggered');
                    monitorShieldActivity();
                    updateShieldQueue();
                    updateShieldUI();
                    updateButtonStates();
                }, 20000);
            }
            return;
        }

        // Sensors are ready, load UI
        console.log('[Shield] Sensors ready, loading initial UI...');
        updateButtonStates(); // Set initial active states (green highlighting)
        updateShieldQueue();  // Load initial queue state
        updateShieldUI();     // Load initial shield status
        monitorShieldActivity(); // Start activity monitoring
    }

    // Start initial load with delay
    setTimeout(tryInitialShieldLoad, 1000);

    // === EVENT-DRIVEN ARCHITECTURE ===
    // VeÅ¡kerÃ© updates jsou Å™Ã­zeny pÅ™es WebSocket subscriptions v subscribeToShield()
    // - Data sensors -> debouncedLoadData() (200ms debounce)
    // - Detail sensors -> debouncedLoadNodeDetails() (500ms debounce)
    // - Pricing sensors -> debouncedLoadPricingData() (300ms debounce)
    // - Shield sensors -> debouncedShieldMonitor() (100ms debounce)

    // REMOVED: Polling-based updates (replaced by WebSocket events)
    // setInterval(loadData, 5000);  âŒ Nahrazeno event-driven
    // setInterval(loadNodeDetails, 30000);  âŒ Nahrazeno event-driven
    // setInterval(detectAndApplyTheme, 5000);  âŒ Nahrazeno event-driven

    // Theme detection - pouze event listeners (NO POLLING)
    // 1. Parent window theme changes
    try {
        if (parent && parent.addEventListener) {
            parent.addEventListener('theme-changed', () => {
                console.log('[Theme] Theme changed event detected');
                detectAndApplyTheme();
            });
        }
    } catch (e) {
        console.warn('[Theme] Cannot listen to parent events:', e);
    }

    // 2. System preference changes
    if (window.matchMedia) {
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
            console.log('[Theme] System preference changed');
            detectAndApplyTheme();
        });
    }

    // 3. Fallback: Check theme on visibility change (tab switch)
    document.addEventListener('visibilitychange', () => {
        if (!document.hidden) {
            console.log('[Theme] Tab became visible, checking theme');
            detectAndApplyTheme();
        }
    });

    // REMOVED: Backup shield monitoring - WebSocket events handle all updates in real-time
    // setInterval(() => {
    //     monitorShieldActivity();
    //     updateShieldQueue();
    // }, 10000);

    // Time update every second
    setInterval(updateTime, 1000);

    // Redraw lines on resize with debounce
    let resizeTimer;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        // Clear cache on resize
        cachedNodeCenters = null;
        lastLayoutHash = null;
        resizeTimer = setTimeout(() => {
            // OPRAVA: PÅ™i resize na flow tabu musÃ­me reinicializovat particles
            const flowTab = document.querySelector('#flow-tab');
            const isFlowTabActive = flowTab && flowTab.classList.contains('active');

            if (isFlowTabActive) {
                console.log('[Resize] Flow tab is active, reinitializing particles...');
                // Zastavit starÃ© particles
                stopAllParticleFlows();
                // PÅ™ekreslit connections s novÃ½m layoutem
                drawConnections();
                // Force restart particles s aktuÃ¡lnÃ­mi pozicemi
                needsFlowReinitialize = true;
                loadData();
            } else {
                // Jen pÅ™ekreslit connections pokud nejsme na flow tabu
                drawConnections();
            }
        }, 100);
    });

    // FIX: Force layout stabilization after initial render
    // ProblÃ©m: Po restartu HA se nÄ›kdy naÄÃ­tajÃ­ CSS/HTML v jinÃ©m poÅ™adÃ­
    // Å˜eÅ¡enÃ­: OpakovanÃ© pÅ™ekreslenÃ­ po rÅ¯znÃ½ch intervalech
    // OPRAVA BUG #3: Inicializovat cache pÅ™ed prvnÃ­m kreslenÃ­m
    setTimeout(() => { getNodeCenters(); drawConnections(); }, 100);   // PrvnÃ­ pokus po 100ms
    setTimeout(() => { getNodeCenters(); drawConnections(); }, 500);   // DruhÃ½ pokus po 500ms
    setTimeout(() => { getNodeCenters(); drawConnections(); }, 1000);  // TÅ™etÃ­ pokus po 1s
    setTimeout(() => { getNodeCenters(); drawConnections(); }, 2000);  // FinÃ¡lnÃ­ po 2s

    // Mobile: Toggle node details on click (collapsed by default)
    if (window.innerWidth <= 768) {
        const nodes = document.querySelectorAll('.node');
        nodes.forEach(node => {
            node.addEventListener('click', function (e) {
                // Ignore clicks on buttons inside nodes
                if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                    return;
                }
                this.classList.toggle('expanded');
            });

            // Add cursor pointer to indicate clickability
            node.style.cursor = 'pointer';
        });
    }

    // === CUSTOM TILES INITIALIZATION ===
    initCustomTiles();

    // === PERIODICKÃ CLEANUP PARTICLES (PREVENCE ÃšNIK PAMÄšTI) ===
    // KaÅ¾dÃ½ch 30 sekund zkontrolujeme poÄet particles
    // Pokud NEJSME na tab Toky, NEMAÅ½ particles (budou potÅ™eba po nÃ¡vratu)
    // Pokud JSME na tab Toky a je > 40 kuliÄek, proveÄ cleanup
    setInterval(() => {
        const flowTab = document.querySelector('#flow-tab');
        const isFlowTabActive = flowTab && flowTab.classList.contains('active');
        const particlesContainer = document.getElementById('particles');

        if (!isFlowTabActive) {
            // OPRAVA: NEMAÅ½ particles kdyÅ¾ nejsi na tabu - budou potÅ™eba pÅ™i nÃ¡vratu
            // Jen zkontroluj count pro monitoring
            if (particlesContainer) {
                const particleCount = particlesContainer.children.length;
                if (particleCount > 50) {
                    console.log(`[Particles] âš ï¸ High particle count while tab inactive: ${particleCount} (will cleanup on tab switch)`);
                }
            }
        } else if (particlesContainer) {
            // Jsme na tab flow (toky) -> cleanup jen pokud je > 40 kuliÄek
            const particleCount = particlesContainer.children.length;
            if (particleCount > 40) {
                console.log(`[Particles] â° Periodic cleanup (${particleCount} particles exceeded threshold)`);
                stopAllParticleFlows();
                // Po cleanup restartovat animace s aktuÃ¡lnÃ­mi daty
                setTimeout(() => {
                    needsFlowReinitialize = true;
                    loadData();
                }, 200);
            }
        }
    }, 30000); // 30 sekund

    console.log('[Particles] âœ“ Periodic cleanup timer started (30s interval)');
}

// Wait for DOM
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
} else {
    init();
}

// === TAB SWITCHING ===
let pricingTabActive = false;
let needsFlowReinitialize = false; // Flag pro vynucenÃ© restartovÃ¡nÃ­ flow animacÃ­

function switchTab(tabName) {
    // Zapamatuj si pÅ™edchozÃ­ tab PÅ˜ED zmÄ›nou
    const previousActiveContent = document.querySelector('.tab-content.active');
    const previousTab = previousActiveContent ? previousActiveContent.id.replace('-tab', '') : null;

    console.log(`[Tab] Switching from '${previousTab}' to '${tabName}'`);

    // Remove active from all tabs and contents
    document.querySelectorAll('.dashboard-tab').forEach(tab => tab.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

    // Add active to clicked tab (find by checking which one was clicked via event)
    const clickedTab = event ? event.target : document.querySelector('.dashboard-tab');
    if (clickedTab) {
        clickedTab.classList.add('active');
    }

    // Add active to corresponding content
    const tabContent = document.getElementById(tabName + '-tab');
    if (tabContent) {
        tabContent.classList.add('active');
    }

    // Track active tab for event-driven updates
    pricingTabActive = (tabName === 'pricing');

    // OPRAVA: PÅ™i ODCHODU z tab flow (toky), zastavit particles (cleanup)
    if (previousTab === 'flow' && tabName !== 'flow') {
        console.log('[Tab] ========== LEAVING FLOW TAB - CLEANUP ==========');
        stopAllParticleFlows();
    }

    // OPRAVA: PÅ™i pÅ™epnutÃ­ NA tab flow (toky), pÅ™ekreslit connections a FORCE restart particles
    if (tabName === 'flow') {
        console.log('[Tab] ========== SWITCHING TO FLOW TAB ==========');

        // DÅ®LEÅ½ITÃ‰: PoÄkat aÅ¾ se tab zobrazÃ­ a DOM se vykreslÃ­
        setTimeout(() => {
            console.log('[Tab] --- Timeout fired, starting redraw ---');

            const flowTab = document.getElementById('flow-tab');
            console.log('[Tab] Flow tab visible?', flowTab && flowTab.classList.contains('active'));
            console.log('[Tab] Flow tab offsetHeight:', flowTab?.offsetHeight);

            // OPRAVA: Zkontrolovat jestli je tab skuteÄnÄ› viditelnÃ½
            if (!flowTab || !flowTab.classList.contains('active')) {
                console.warn('[Tab] âœ— Flow tab not visible yet, aborting redraw');
                return;
            }

            // 3. Invalidovat cache pozic
            cachedNodeCenters = null;
            lastLayoutHash = null;
            console.log('[Tab] âœ“ Cache invalidated');

            // 4. Force browser reflow aby DOM byl stabilnÃ­
            if (flowTab) {
                const reflow = flowTab.offsetHeight; // Trigger reflow
                console.log('[Tab] âœ“ Browser reflow triggered:', reflow, 'px');
            }

            // 5. NaÄÃ­st fresh pozice node elementÅ¯
            console.log('[Tab] Getting node centers...');
            const centers = getNodeCenters();
            console.log('[Tab] Node centers result:', centers);

            // OPRAVA: Zkontrolovat jestli se pozice naÄetly sprÃ¡vnÄ›
            if (!centers || Object.keys(centers).length === 0) {
                console.error('[Tab] âœ— Failed to get node centers (DOM not ready), retrying...');
                // Zkusit znovu s delÅ¡Ã­m timeout
                setTimeout(() => {
                    cachedNodeCenters = null;
                    lastLayoutHash = null;
                    const retryCenters = getNodeCenters();
                    console.log('[Tab] Retry node centers result:', retryCenters);

                    if (!retryCenters || Object.keys(retryCenters).length === 0) {
                        console.error('[Tab] âœ— Retry also failed, giving up');
                        return;
                    }

                    console.log('[Tab] âœ“ Node centers loaded on retry:', Object.keys(retryCenters).length);
                    drawConnections();
                    needsFlowReinitialize = true;
                    loadData();
                    console.log('[Tab] âœ“ Retry complete');
                }, 200);
                return;
            }

            // 6. PÅ™ekreslit ÄÃ¡ry (teÄ uÅ¾ mÃ¡me sprÃ¡vnÃ© pozice)
            console.log('[Tab] âœ“ Node centers cached:', Object.keys(centers).length);
            console.log('[Tab] Drawing connections...');
            drawConnections();
            console.log('[Tab] âœ“ Connections drawn');

            // 7. Nastavit flag pro vynucenÃ© restartovÃ¡nÃ­ animacÃ­
            needsFlowReinitialize = true;
            console.log('[Tab] Flag needsFlowReinitialize set to TRUE');

            // 8. NaÄÃ­st aktuÃ¡lnÃ­ data a restartovat particles
            console.log('[Tab] Loading fresh data for animations...');
            loadData(); // NaÄte data a zavolÃ¡ animateFlow() s aktuÃ¡lnÃ­mi hodnotami
            console.log('[Tab] ========== TOKY TAB SWITCH COMPLETE ==========');
        }, 150); // DelÅ¡Ã­ timeout aby se DOM stihl vykreslit
    }

    // Load data when entering pricing tab
    if (tabName === 'pricing') {
        console.log('[Tab] ========== SWITCHING TO PRICING TAB ==========');
        // PoÄkat aÅ¾ se tab zobrazÃ­ a canvas bude viditelnÃ½
        setTimeout(() => {
            console.log('[Pricing] Tab visible, loading pricing data...');
            loadPricingData();
        }, 150); // StejnÃ½ timeout jako u Toky pro konzistenci
    }

    // Load boiler dashboard when entering boiler tab
    if (tabName === 'boiler') {
        console.log('[Tab] ========== SWITCHING TO BOILER TAB ==========');
        setTimeout(() => {
            console.log('[Boiler] Tab visible, initializing boiler dashboard...');
            if (typeof initBoilerDashboard === 'function') {
                initBoilerDashboard();
            } else {
                console.error('[Boiler] initBoilerDashboard function not found');
            }
        }, 150);
    }

    // Load data when entering boiler tab
    if (tabName === 'boiler') {
        console.log('[Tab] ========== SWITCHING TO BOILER TAB ==========');
        // PoÄkat aÅ¾ se tab zobrazÃ­ a canvas bude viditelnÃ½
        setTimeout(() => {
            console.log('[Boiler] Tab visible, loading boiler data...');
            loadBoilerData();
        }, 150);
    }
}

// === BOILER (enhanced in dashboard-boiler.js) ===
const loadBoilerData = window.DashboardBoiler.loadBoilerData;
const updateBoilerChart = window.DashboardBoiler.updateBoilerChart;
const loadPricingData = window.DashboardPricing.loadPricingData;
const updatePlannedConsumptionStats = window.DashboardPricing.updatePlannedConsumptionStats;
let tileDialog = null;

/**
 * Initialize custom tiles system
 */
async function initCustomTiles() {
    console.log('[Tiles] Initializing custom tiles system...');

    // Initialize tile dialog only if not already initialized
    const hass = getHass();
    if (!hass) {
        console.warn('[Tiles] Cannot initialize - no HA connection, retrying...');
        setTimeout(initCustomTiles, 1000); // Retry
        return;
    }

    // Initialize tile manager (only once)
    if (!tileManager) {
        tileManager = new DashboardTileManager(hass);
        window.tileManager = tileManager; // Export for dialog access

        // Listen for config changes
        tileManager.addChangeListener(() => {
            console.log('[Tiles] Config changed, re-rendering...');
            renderAllTiles();
            updateTileControlsUI();
        });

        // ASYNCHRONNÄš naÄÃ­st konfiguraci z HA storage
        console.log('[Tiles] Loading configuration...');
        await tileManager.init();
        console.log('[Tiles] Configuration loaded');
    }

    // Initialize tile dialog (only once)
    if (!tileDialog) {
        tileDialog = new TileConfigDialog(hass, tileManager);
        window.tileDialog = tileDialog; // Export for onclick handlers
    }

    // Initial render
    renderAllTiles();
    updateTileControlsUI();

    console.log('[Tiles] Initialization complete');
}

/**
 * Update tile count from UI input
 */
function updateTileCount(side, value) {
    if (!tileManager) {
        console.error('[Tiles] Tile manager not initialized');
        return;
    }

    tileManager.setTileCount(side, value);
}

/**
 * Toggle tiles section visibility
 */
function toggleTilesVisibility() {
    if (!tileManager) {
        console.error('[Tiles] Tile manager not initialized');
        return;
    }

    tileManager.toggleVisibility();

    const section = document.querySelector('.custom-tiles-section');
    if (section) {
        section.style.display = tileManager.isVisible() ? 'block' : 'none';
    }
}

/**
 * Reset all tiles to default
 */
function resetAllTiles() {
    if (!tileManager) {
        console.error('[Tiles] Tile manager not initialized');
        return;
    }

    if (!confirm('Opravdu smazat vÅ¡echny dlaÅ¾dice a vrÃ¡tit nastavenÃ­ na vÃ½chozÃ­?')) {
        return;
    }

    tileManager.reset();

    // Reset UI inputs
    document.getElementById('tiles-left-count').value = 6;
    document.getElementById('tiles-right-count').value = 6;
}

/**
 * Update tile controls UI (inputs visibility toggle button)
 */
function updateTileControlsUI() {
    if (!tileManager) return;

    // Update inputs
    const leftInput = document.getElementById('tiles-left-count');
    const rightInput = document.getElementById('tiles-right-count');

    if (leftInput) {
        leftInput.value = tileManager.getTileCount('left');
    }
    if (rightInput) {
        rightInput.value = tileManager.getTileCount('right');
    }

    // Update visibility
    const section = document.querySelector('.custom-tiles-section');
    if (section) {
        const isVisible = tileManager.isVisible();
        section.style.display = isVisible ? 'block' : 'none';
        console.log(`[Tiles] Section visibility updated: ${isVisible}`);
    }

    // Update toggle button text
    const toggleBtn = document.getElementById('btn-tiles-toggle');
    if (toggleBtn && tileManager.isVisible()) {
        toggleBtn.style.background = 'rgba(76, 175, 80, 0.2)';
        toggleBtn.style.borderColor = 'rgba(76, 175, 80, 0.5)';
    } else if (toggleBtn) {
        toggleBtn.style.background = 'var(--button-bg)';
        toggleBtn.style.borderColor = 'var(--button-border)';
    }
}

/**
 * Render all tiles (both blocks)
 */
function renderAllTiles() {
    renderTilesBlock('left');
    renderTilesBlock('right');
}

/**
 * Render one tiles block
 * @param {string} side - 'left' or 'right'
 */
function renderTilesBlock(side) {
    const blockElement = document.getElementById(`tiles-${side}`);
    if (!blockElement) {
        console.warn(`[Tiles] Block element not found: tiles-${side}`);
        return;
    }

    const gridElement = blockElement.querySelector('.tiles-grid');
    if (!gridElement) {
        console.warn(`[Tiles] Grid element not found in tiles-${side}`);
        return;
    }

    // Get tile count for this side
    const tileCount = tileManager.getTileCount(side);

    // Hide block if count is 0
    if (tileCount === 0) {
        blockElement.style.display = 'none';
        return;
    } else {
        blockElement.style.display = 'block';
    }

    // Get configuration
    const tiles = tileManager.getTiles(side);

    // Debug log pro diagnostiku
    // console.log(`[Tiles] DEBUG ${side} tiles:`, tiles, 'non-null:', tiles.filter(t => t !== null));

    // Render tiles up to count
    gridElement.innerHTML = '';
    for (let i = 0; i < tileCount; i++) {
        const tileConfig = tiles[i];
        const tileElement = renderTile(side, i, tileConfig);
        gridElement.appendChild(tileElement);
    }

    // console.log(`[Tiles] Rendered ${side} block with ${tileCount} slots (${tiles.filter(t => t !== null).length} configured)`);
}

/**
 * Render single tile
 * @param {string} side - 'left' or 'right'
 * @param {number} index - Tile index (0-5)
 * @param {object|null} config - Tile configuration
 * @returns {HTMLElement} - Tile element
 */
function renderTile(side, index, config) {
    const tile = document.createElement('div');
    tile.className = 'dashboard-tile';
    tile.dataset.side = side;
    tile.dataset.index = index.toString();

    if (!config) {
        // Placeholder tile
        tile.classList.add('tile-placeholder');
        tile.innerHTML = `
            <div class="tile-placeholder-content" onclick="window.tileDialog.open(${index}, '${side}')">
                <div class="tile-placeholder-icon">â•</div>
                <div class="tile-placeholder-text">PÅ™idat dlaÅ¾dici</div>
            </div>
        `;
    } else if (config.type === 'entity') {
        // Entity tile
        tile.classList.add('tile-entity');
        tile.innerHTML = renderEntityTile(config, side, index);
    } else if (config.type === 'button') {
        // Button tile
        tile.classList.add('tile-button');
        tile.innerHTML = renderButtonTile(config, side, index);
    }

    // Add edit button (visible on hover)
    if (config) {
        const editBtn = document.createElement('button');
        editBtn.className = 'tile-edit';
        editBtn.innerHTML = 'âš™ï¸';
        editBtn.title = 'Upravit dlaÅ¾dici';
        editBtn.onclick = (e) => {
            e.stopPropagation();
            window.tileDialog.open(index, side);
        };
        tile.appendChild(editBtn);
    }

    // Add remove button (visible on hover)
    if (config) {
        const removeBtn = document.createElement('button');
        removeBtn.className = 'tile-remove';
        removeBtn.innerHTML = 'âœ•';
        removeBtn.title = 'Odstranit dlaÅ¾dici';
        removeBtn.onclick = (e) => {
            e.stopPropagation();
            if (confirm('Opravdu odstranit tuto dlaÅ¾dici?')) {
                tileManager.removeTile(side, index);
            }
        };
        tile.appendChild(removeBtn);
    }

    return tile;
}

/**
 * Render icon - podporuje emoji i MDI ikony
 * @param {string} icon - Icon string (emoji nebo mdi:xxx)
 * @param {string} color - Icon color
 * @returns {string} - HTML string
 */
function renderIcon(icon, color) {
    if (!icon) return '';

    // MDI ikona (formÃ¡t mdi:xxx) - pouÅ¾Ã­t emoji fallback protoÅ¾e ha-icon nefunguje v iframe
    if (icon.startsWith('mdi:')) {
        const iconName = icon.substring(4); // Odstranit 'mdi:' prefix

        // Emoji mapa - stejnÃ¡ jako v dashboard-dialog.js
        const emojiMap = {
            // SpotÅ™ebiÄe
            'fridge': 'â„ï¸', 'fridge-outline': 'â„ï¸', 'dishwasher': 'ğŸ½ï¸', 'washing-machine': 'ğŸ§º',
            'tumble-dryer': 'ğŸŒªï¸', 'stove': 'ğŸ”¥', 'microwave': 'ğŸ“¦', 'coffee-maker': 'â˜•',
            'kettle': 'ğŸ«–', 'toaster': 'ğŸ',
            // OsvÄ›tlenÃ­
            'lightbulb': 'ğŸ’¡', 'lightbulb-outline': 'ğŸ’¡', 'lamp': 'ğŸª”', 'ceiling-light': 'ğŸ’¡',
            'floor-lamp': 'ğŸª”', 'led-strip': 'âœ¨', 'led-strip-variant': 'âœ¨', 'wall-sconce': 'ğŸ’¡',
            'chandelier': 'ğŸ’¡',
            // VytÃ¡pÄ›nÃ­
            'thermometer': 'ğŸŒ¡ï¸', 'thermostat': 'ğŸŒ¡ï¸', 'radiator': 'â™¨ï¸', 'radiator-disabled': 'â„ï¸',
            'heat-pump': 'â™¨ï¸', 'air-conditioner': 'â„ï¸', 'fan': 'ğŸŒ€', 'hvac': 'â™¨ï¸', 'fire': 'ğŸ”¥',
            'snowflake': 'â„ï¸',
            // Energie
            'lightning-bolt': 'âš¡', 'flash': 'âš¡', 'battery': 'ğŸ”‹', 'battery-charging': 'ğŸ”‹',
            'battery-50': 'ğŸ”‹', 'solar-panel': 'â˜€ï¸', 'solar-power': 'â˜€ï¸', 'meter-electric': 'âš¡',
            'power-plug': 'ğŸ”Œ', 'power-socket': 'ğŸ”Œ',
            // Auto
            'car': 'ğŸš—', 'car-electric': 'ğŸš—', 'car-battery': 'ğŸ”‹', 'ev-station': 'ğŸ”Œ',
            'ev-plug-type2': 'ğŸ”Œ', 'garage': 'ğŸ ', 'garage-open': 'ğŸ ',
            // ZabezpeÄenÃ­
            'door': 'ğŸšª', 'door-open': 'ğŸšª', 'lock': 'ğŸ”’', 'lock-open': 'ğŸ”“', 'shield-home': 'ğŸ›¡ï¸',
            'cctv': 'ğŸ“¹', 'camera': 'ğŸ“¹', 'motion-sensor': 'ğŸ‘ï¸', 'alarm-light': 'ğŸš¨', 'bell': 'ğŸ””',
            // Okna
            'window-closed': 'ğŸªŸ', 'window-open': 'ğŸªŸ', 'blinds': 'ğŸªŸ', 'blinds-open': 'ğŸªŸ',
            'curtains': 'ğŸªŸ', 'roller-shade': 'ğŸªŸ',
            // MÃ©dia
            'television': 'ğŸ“º', 'speaker': 'ğŸ”Š', 'speaker-wireless': 'ğŸ”Š', 'music': 'ğŸµ',
            'volume-high': 'ğŸ”Š', 'cast': 'ğŸ“¡', 'chromecast': 'ğŸ“¡',
            // SÃ­Å¥
            'router-wireless': 'ğŸ“¡', 'wifi': 'ğŸ“¶', 'access-point': 'ğŸ“¡', 'lan': 'ğŸŒ',
            'network': 'ğŸŒ', 'home-assistant': 'ğŸ ',
            // Voda
            'water': 'ğŸ’§', 'water-percent': 'ğŸ’§', 'water-boiler': 'â™¨ï¸', 'water-pump': 'ğŸ’§',
            'shower': 'ğŸš¿', 'toilet': 'ğŸš½', 'faucet': 'ğŸš°', 'pipe': 'ğŸ”§',
            // PoÄasÃ­
            'weather-sunny': 'â˜€ï¸', 'weather-cloudy': 'â˜ï¸', 'weather-night': 'ğŸŒ™',
            'weather-rainy': 'ğŸŒ§ï¸', 'weather-snowy': 'â„ï¸', 'weather-windy': 'ğŸ’¨',
            // OstatnÃ­
            'information': 'â„¹ï¸', 'help-circle': 'â“', 'alert-circle': 'âš ï¸',
            'checkbox-marked-circle': 'âœ…', 'toggle-switch': 'ğŸ”˜', 'power': 'âš¡', 'sync': 'ğŸ”„'
        };

        const emoji = emojiMap[iconName] || 'âš™ï¸';
        return `<span style="font-size: 28px; color: ${color};">${emoji}</span>`;
    }

    // Emoji nebo jinÃ½ text
    return icon;
}/**
 * Render entity tile content
 * @param {object} config - Entity tile config
 * @param {string} side - Tile side (left/right)
 * @param {number} index - Tile index
 * @returns {string} - HTML string
 */
function renderEntityTile(config, side, index) {
    const hass = getHass();
    if (!hass || !hass.states) {
        return '<div class="tile-error">HA nedostupnÃ©</div>';
    }

    const state = hass.states[config.entity_id];
    if (!state) {
        return `<div class="tile-error">Entita nenalezena:<br>${config.entity_id}</div>`;
    }

    const label = config.label || state.attributes.friendly_name || config.entity_id;
    // PouÅ¾ij POUZE ikonu z config, pokud nenÃ­ nastavena, pouÅ¾ij vÃ½chozÃ­ - nikdy ne z HA state
    const icon = config.icon || 'ğŸ“Š';
    let value = state.state;
    let unit = state.attributes.unit_of_measurement || '';
    const color = config.color || '#03A9F4';

    // Konverze W/Wh na kW/kWh pokud >= 1000
    if (unit === 'W' || unit === 'Wh') {
        const numValue = parseFloat(value);
        if (!isNaN(numValue)) {
            if (Math.abs(numValue) >= 1000) {
                value = (numValue / 1000).toFixed(1);
                unit = unit === 'W' ? 'kW' : 'kWh';
            } else {
                value = Math.round(numValue);
            }
        }
    }

    // PodpornÃ© entity
    let supportHtml = '';
    if (config.support_entities) {
        // Top right
        if (config.support_entities.top_right) {
            const topRightState = hass.states[config.support_entities.top_right];
            if (topRightState) {
                let topRightValue = topRightState.state;
                let topRightUnit = topRightState.attributes.unit_of_measurement || '';
                const topRightIcon = topRightState.attributes.icon || '';

                // Konverze W/Wh na kW/kWh
                if (topRightUnit === 'W' || topRightUnit === 'Wh') {
                    const numValue = parseFloat(topRightValue);
                    if (!isNaN(numValue)) {
                        if (Math.abs(numValue) >= 1000) {
                            topRightValue = (numValue / 1000).toFixed(1);
                            topRightUnit = topRightUnit === 'W' ? 'kW' : 'kWh';
                        } else {
                            topRightValue = Math.round(numValue);
                        }
                    }
                }

                supportHtml += `
                    <div class="tile-support tile-support-top-right" onclick="event.stopPropagation(); openEntityDialog('${config.support_entities.top_right}')">
                        <span class="support-icon">${topRightIcon}</span>
                        <span class="support-value">${topRightValue}${topRightUnit}</span>
                    </div>
                `;
            }
        }

        // Bottom right
        if (config.support_entities.bottom_right) {
            const bottomRightState = hass.states[config.support_entities.bottom_right];
            if (bottomRightState) {
                let bottomRightValue = bottomRightState.state;
                let bottomRightUnit = bottomRightState.attributes.unit_of_measurement || '';
                const bottomRightIcon = bottomRightState.attributes.icon || '';

                // Konverze W/Wh na kW/kWh
                if (bottomRightUnit === 'W' || bottomRightUnit === 'Wh') {
                    const numValue = parseFloat(bottomRightValue);
                    if (!isNaN(numValue)) {
                        if (Math.abs(numValue) >= 1000) {
                            bottomRightValue = (numValue / 1000).toFixed(1);
                            bottomRightUnit = bottomRightUnit === 'W' ? 'kW' : 'kWh';
                        } else {
                            bottomRightValue = Math.round(numValue);
                        }
                    }
                }

                supportHtml += `
                    <div class="tile-support tile-support-bottom-right" onclick="event.stopPropagation(); openEntityDialog('${config.support_entities.bottom_right}')">
                        <span class="support-icon">${bottomRightIcon}</span>
                        <span class="support-value">${bottomRightValue}${bottomRightUnit}</span>
                    </div>
                `;
            }
        }
    }

    // Detekce neaktivnÃ­ho stavu (0 W nebo 0 hodnota)
    const numericValue = parseFloat(state.state);
    const isInactive = !isNaN(numericValue) && numericValue === 0;
    const inactiveClass = isInactive ? ' tile-inactive' : '';

    return `
        <div class="tile-content tile-content-horizontal${inactiveClass}" style="border-left: 3px solid ${color};">
            <div class="tile-main-content">
                <div class="tile-icon-large" style="color: ${color};">${renderIcon(icon, color)}</div>
                <div class="tile-value-large" onclick="openEntityDialog('${config.entity_id}')" style="cursor: pointer;">${value}<span class="tile-unit">${unit}</span></div>
            </div>
            ${supportHtml}
            <div class="tile-label-hover">${label}</div>
        </div>
    `;
}

/**
 * Render button tile content
 * @param {object} config - Button tile config
 * @param {string} side - Tile side (left/right)
 * @param {number} index - Tile index
 * @returns {string} - HTML string
 */
function renderButtonTile(config, side, index) {
    const hass = getHass();
    if (!hass || !hass.states) {
        return '<div class="tile-error">HA nedostupnÃ©</div>';
    }

    const state = hass.states[config.entity_id];
    if (!state) {
        return `<div class="tile-error">Entita nenalezena:<br>${config.entity_id}</div>`;
    }

    const label = config.label || state.attributes.friendly_name || config.entity_id;
    // PouÅ¾ij POUZE ikonu z config, pokud nenÃ­ nastavena, pouÅ¾ij vÃ½chozÃ­ - nikdy ne z HA state
    const icon = config.icon || 'ğŸ”˜';
    const color = config.color || '#FFC107';
    const action = config.action || 'toggle';
    const isOn = state.state === 'on';

    const buttonClass = isOn ? 'tile-button-active' : 'tile-button-inactive';

    // Popis akce pro uÅ¾ivatele
    const actionLabels = {
        'toggle': 'PÅ™epnout',
        'turn_on': 'Zapnout',
        'turn_off': 'Vypnout'
    };
    const actionLabel = actionLabels[action] || 'OvlÃ¡dat';

    // PodpornÃ© entity
    let supportHtml = '';
    if (config.support_entities) {
        // Top right
        if (config.support_entities.top_right) {
            const topRightState = hass.states[config.support_entities.top_right];
            if (topRightState) {
                let topRightValue = topRightState.state;
                let topRightUnit = topRightState.attributes.unit_of_measurement || '';
                const topRightIcon = topRightState.attributes.icon || '';

                // Konverze W/Wh na kW/kWh
                if (topRightUnit === 'W' || topRightUnit === 'Wh') {
                    const numValue = parseFloat(topRightValue);
                    if (!isNaN(numValue)) {
                        if (Math.abs(numValue) >= 1000) {
                            topRightValue = (numValue / 1000).toFixed(1);
                            topRightUnit = topRightUnit === 'W' ? 'kW' : 'kWh';
                        } else {
                            topRightValue = Math.round(numValue);
                        }
                    }
                }

                supportHtml += `
                    <div class="tile-support tile-support-top-right" onclick="event.stopPropagation(); openEntityDialog('${config.support_entities.top_right}')">
                        <span class="support-icon">${topRightIcon}</span>
                        <span class="support-value">${topRightValue}${topRightUnit}</span>
                    </div>
                `;
            }
        }

        // Bottom right
        if (config.support_entities.bottom_right) {
            const bottomRightState = hass.states[config.support_entities.bottom_right];
            if (bottomRightState) {
                let bottomRightValue = bottomRightState.state;
                let bottomRightUnit = bottomRightState.attributes.unit_of_measurement || '';
                const bottomRightIcon = bottomRightState.attributes.icon || '';

                // Konverze W/Wh na kW/kWh
                if (bottomRightUnit === 'W' || bottomRightUnit === 'Wh') {
                    const numValue = parseFloat(bottomRightValue);
                    if (!isNaN(numValue)) {
                        if (Math.abs(numValue) >= 1000) {
                            bottomRightValue = (numValue / 1000).toFixed(1);
                            bottomRightUnit = bottomRightUnit === 'W' ? 'kW' : 'kWh';
                        } else {
                            bottomRightValue = Math.round(numValue);
                        }
                    }
                }

                supportHtml += `
                    <div class="tile-support tile-support-bottom-right" onclick="event.stopPropagation(); openEntityDialog('${config.support_entities.bottom_right}')">
                        <span class="support-icon">${bottomRightIcon}</span>
                        <span class="support-value">${bottomRightValue}${bottomRightUnit}</span>
                    </div>
                `;
            }
        }
    }

    return `
        <div class="tile-content tile-content-horizontal ${buttonClass}"
             style="border-left: 3px solid ${color};"
             onclick="executeTileButtonAction('${config.entity_id}', '${action}')">
            <div class="tile-main-content">
                <div class="tile-icon-large" style="color: ${color};">${renderIcon(icon, color)}</div>
                <div class="tile-button-state">${isOn ? 'ON' : 'OFF'}</div>
            </div>
            ${supportHtml}
            <div class="tile-label-hover">${label} â€¢ ${actionLabel}</div>
        </div>
    `;
}

/**
 * Execute button action
 * @param {string} entityId - Entity ID
 * @param {string} action - Action (toggle, turn_on, turn_off)
 */
function executeTileButtonAction(entityId, action) {
    const hass = getHass();
    if (!hass) {
        console.error('[Tiles] Cannot execute action - no HA connection');
        return;
    }

    const domain = entityId.split('.')[0];
    const service = action === 'toggle' ? 'toggle' : action;

    console.log(`[Tiles] Calling ${domain}.${service} on ${entityId}`);

    hass.callService(domain, service, { entity_id: entityId })
        .then(() => {
            console.log(`[Tiles] Service call successful`);
            // Re-render tiles after state change (debounced)
            setTimeout(renderAllTiles, 500);
        })
        .catch((err) => {
            console.error(`[Tiles] Service call failed:`, err);
            alert(`Chyba pÅ™i volÃ¡nÃ­ sluÅ¾by: ${err.message}`);
        });
}

// === ÄŒHMÃš (moved to dashboard-chmu.js) ===
const updateChmuWarningBadge = window.DashboardChmu.updateChmuWarningBadge;
const toggleChmuWarningModal = window.DashboardChmu.toggleChmuWarningModal;
const openChmuWarningModal = window.DashboardChmu.openChmuWarningModal;
const closeChmuWarningModal = window.DashboardChmu.closeChmuWarningModal;
    if (!hass) return;

    const sensorId = `sensor.oig_${INVERTER_SN}_battery_efficiency`;
    const sensor = hass.states[sensorId];

    if (!sensor || sensor.state === 'unavailable' || sensor.state === 'unknown') {
        console.log('[Battery Efficiency] Sensor not available:', sensorId);
        return;
    }

    const attrs = sensor.attributes || {};

    // Prefer last month (complete), fallback to current month (partial)
    let displayEff, displayLossesPct, displayLossesKwh, displayCharge, displayDischarge, displayLabel;

    const lastMonthEff = attrs.efficiency_last_month_pct;
    const lastMonthLossesPct = attrs.losses_last_month_pct;
    const lastMonthLossesKwh = attrs.losses_last_month_kwh;
    const lastMonthCharge = attrs.last_month_charge_kwh;
    const lastMonthDischarge = attrs.last_month_discharge_kwh;

    const currentMonthEff = attrs.efficiency_current_month_pct;
    const currentMonthLossesPct = attrs.losses_current_month_pct;
    const currentMonthLossesKwh = attrs.losses_current_month_kwh;
    const currentMonthCharge = attrs.current_month_charge_kwh;
    const currentMonthDischarge = attrs.current_month_discharge_kwh;
    const currentMonthDays = attrs.current_month_days;

    // Use last month if available (complete data), otherwise use current month (partial)
    if (lastMonthEff !== null && lastMonthEff !== undefined &&
        lastMonthCharge !== null && lastMonthDischarge !== null) {
        displayEff = lastMonthEff;
        displayLossesPct = lastMonthLossesPct;
        displayLossesKwh = lastMonthLossesKwh;
        displayCharge = lastMonthCharge;
        displayDischarge = lastMonthDischarge;
        displayLabel = 'MinulÃ½ mÄ›sÃ­c';
    } else if (currentMonthEff !== null && currentMonthEff !== undefined) {
        displayEff = currentMonthEff;
        displayLossesPct = currentMonthLossesPct;
        displayLossesKwh = currentMonthLossesKwh;
        displayCharge = currentMonthCharge;
        displayDischarge = currentMonthDischarge;
        displayLabel = `Tento mÄ›sÃ­c (${currentMonthDays} dnÃ­)`;
    }

    if (displayEff !== undefined) {
        // Main value
        updateElementIfChanged('battery-efficiency-main', `${displayEff.toFixed(1)}%`, 'batt-eff-main');

        // Trend comparison
        if (lastMonthEff !== null && currentMonthEff !== null &&
            lastMonthEff !== undefined && currentMonthEff !== undefined) {
            const diff = currentMonthEff - lastMonthEff;
            const diffAbs = Math.abs(diff);
            let trendText = '';
            let trendColor = '';

            if (diff > 0.5) {
                trendText = `â†—ï¸ Vs minulÃ½ mÄ›sÃ­c +${diffAbs.toFixed(1)}%`;
                trendColor = '#4CAF50';
            } else if (diff < -0.5) {
                trendText = `â†˜ï¸ Vs minulÃ½ mÄ›sÃ­c -${diffAbs.toFixed(1)}%`;
                trendColor = '#FF5722';
            } else {
                trendText = `â¡ï¸ PodobnÄ› jako minulÃ½ mÄ›sÃ­c`;
                trendColor = 'var(--text-secondary)';
            }

            const trendEl = document.getElementById('battery-efficiency-trend');
            if (trendEl) {
                trendEl.textContent = trendText;
                trendEl.style.color = trendColor;
            }
        } else {
            updateElementIfChanged('battery-efficiency-trend', displayLabel, 'batt-trend');
        }

        // Detail values
        updateElementIfChanged('battery-charge-value', `${displayCharge?.toFixed(1) || '--'} kWh`, 'batt-charge-val');
        updateElementIfChanged('battery-discharge-value', `${displayDischarge?.toFixed(1) || '--'} kWh`, 'batt-discharge-val');
        updateElementIfChanged('battery-losses-value', `${displayLossesKwh?.toFixed(1) || '--'} kWh (${displayLossesPct?.toFixed(1) || '--'}%)`, 'batt-loss-val');

        // Update period label
        updateElementIfChanged('battery-efficiency-period-label', displayLabel, 'batt-period-label');

        // Update gradient bar comparison
        updateBatteryEfficiencyBar(lastMonthEff, currentMonthEff);
    } else {
        updateElementIfChanged('battery-efficiency-main', '--', 'batt-eff-main');
        updateElementIfChanged('battery-efficiency-period-label', 'ÄŒekÃ¡m na data...', 'batt-period-label');
        updateElementIfChanged('battery-efficiency-trend', 'ÄŒekÃ¡m na data...', 'batt-trend');
        updateElementIfChanged('battery-charge-value', '--', 'batt-charge-val');
        updateElementIfChanged('battery-discharge-value', '--', 'batt-discharge-val');
        updateElementIfChanged('battery-losses-value', '--', 'batt-loss-val');
    }
}

/**
 * Update gradient bar showing battery efficiency comparison
 */
function updateBatteryEfficiencyBar(lastMonthEff, currentMonthEff) {
    const barLast = document.getElementById('battery-efficiency-bar-last');
    const barCurrent = document.getElementById('battery-efficiency-bar-current');
    const labelLast = document.getElementById('battery-efficiency-bar-last-label');
    const labelCurrent = document.getElementById('battery-efficiency-bar-current-label');

    if (!barLast || !barCurrent || !labelLast || !labelCurrent) return;

    // Pokud mÃ¡me obÄ› hodnoty, zobraz pomÄ›r
    if (lastMonthEff !== null && lastMonthEff !== undefined &&
        currentMonthEff !== null && currentMonthEff !== undefined) {

        const total = lastMonthEff + currentMonthEff;
        const lastPercent = (lastMonthEff / total) * 100;
        const currentPercent = (currentMonthEff / total) * 100;

        barLast.style.width = `${lastPercent}%`;
        barCurrent.style.width = `${currentPercent}%`;
        labelLast.textContent = `${lastMonthEff.toFixed(1)}%`;
        labelCurrent.textContent = `${currentMonthEff.toFixed(1)}%`;
    } else if (lastMonthEff !== null && lastMonthEff !== undefined) {
        // Jen minulÃ½ mÄ›sÃ­c
        barLast.style.width = '100%';
        barCurrent.style.width = '0%';
        labelLast.textContent = `${lastMonthEff.toFixed(1)}%`;
        labelCurrent.textContent = '--';
    } else if (currentMonthEff !== null && currentMonthEff !== undefined) {
        // Jen tento mÄ›sÃ­c
        barLast.style.width = '0%';
        barCurrent.style.width = '100%';
        labelLast.textContent = '--';
        labelCurrent.textContent = `${currentMonthEff.toFixed(1)}%`;
    } else {
        // Å½Ã¡dnÃ¡ data
        barLast.style.width = '0%';
        barCurrent.style.width = '0%';
        labelLast.textContent = '--';
        labelCurrent.textContent = '--';
    }
}

/**
 * Update planned consumption statistics on Pricing tab
 * Reads pre-calculated data from battery_forecast attributes
 */
async function updatePlannedConsumptionStats() {
    const hass = getHass();
    if (!hass) return;

    const forecastSensorId = `sensor.oig_${INVERTER_SN}_battery_forecast`;
    const forecastSensor = hass.states[forecastSensorId];

    // Check if sensor is available
    if (!forecastSensor || forecastSensor.state === 'unavailable' || forecastSensor.state === 'unknown') {
        console.log('[Planned Consumption] Battery forecast sensor not available:', forecastSensorId);
        updateElementIfChanged('planned-consumption-today', '--', 'planned-today');
        updateElementIfChanged('consumption-profile-today', 'ÄŒekÃ¡m na data...', 'profile-today');
        updateElementIfChanged('planned-consumption-tomorrow', '--', 'planned-tomorrow');
        updateElementIfChanged('consumption-profile-tomorrow', 'ÄŒekÃ¡m na data...', 'profile-tomorrow');
        return;
    }

    // Get pre-calculated consumption data from battery_forecast attributes
    const attrs = forecastSensor.attributes || {};

    // Display data (already calculated in Python) - naÄÃ­tÃ¡me pÅ™Ã­mo z root atributÅ¯
    const todayPlannedKwh = attrs.planned_consumption_today;
    const tomorrowKwh = attrs.planned_consumption_tomorrow;
    const profileToday = attrs.profile_today;
    const profileTomorrow = attrs.profile_tomorrow;

    // ZÃ­skat jiÅ¾ spotÅ™ebovanou energii dnes z ac_out_en_day (vracÃ­ Wh, pÅ™evÃ©st na kWh)
    const todayConsumedSensorId = `sensor.oig_${INVERTER_SN}_ac_out_en_day`;
    const todayConsumedSensor = hass.states[todayConsumedSensorId];
    const todayConsumedWh = todayConsumedSensor && todayConsumedSensor.state !== 'unavailable'
        ? parseFloat(todayConsumedSensor.state) || 0
        : 0;
    const todayConsumedKwh = todayConsumedWh / 1000; // PÅ™evod Wh -> kWh

    // CelkovÃ¡ spotÅ™eba dnes (uÅ¾ spotÅ™ebovÃ¡no + jeÅ¡tÄ› plÃ¡novÃ¡no)
    const todayTotalKwh = todayConsumedKwh + (todayPlannedKwh || 0);

    // CelkovÃ¡ plÃ¡novanÃ¡ spotÅ™eba (dnes zbÃ½vÃ¡ + zÃ­tÅ™ek celÃ½)
    const totalPlannedKwh = (todayPlannedKwh || 0) + (tomorrowKwh || 0);

    // Update UI - HlavnÃ­ hodnota (plÃ¡novanÃ¡: dnes zbÃ½vÃ¡ + zÃ­tÅ™ek)
    if (totalPlannedKwh > 0) {
        updateElementIfChanged('planned-consumption-main', `${totalPlannedKwh.toFixed(1)} kWh`, 'planned-main');
    } else {
        updateElementIfChanged('planned-consumption-main', '--', 'planned-main');
    }

    // Update trend text (porovnÃ¡nÃ­ celkem dnes vs zÃ­tÅ™ek)
    if (todayTotalKwh > 0 && tomorrowKwh !== null && tomorrowKwh !== undefined) {
        const diff = tomorrowKwh - todayTotalKwh;
        const diffPercent = todayTotalKwh > 0 ? ((diff / todayTotalKwh) * 100) : 0;
        let trendText = '';
        let trendIcon = '';

        if (Math.abs(diffPercent) < 5) {
            trendIcon = 'â¡ï¸';
            trendText = `ZÃ­tra podobnÄ›`;
        } else if (diff > 0) {
            trendIcon = 'ğŸ“ˆ';
            trendText = `ZÃ­tra vÃ­ce (+${Math.abs(diffPercent).toFixed(0)}%)`;
        } else {
            trendIcon = 'ğŸ“‰';
            trendText = `ZÃ­tra mÃ©nÄ› (-${Math.abs(diffPercent).toFixed(0)}%)`;
        }

        updateElementIfChanged('planned-consumption-trend', `${trendIcon} ${trendText}`, 'planned-trend');
    } else {
        updateElementIfChanged('planned-consumption-trend', '--', 'planned-trend');
    }

    // Detail Å™Ã¡dky - Dnes: spotÅ™ebovÃ¡no + zbÃ½vÃ¡ plÃ¡n, ZÃ­tra: celÃ½ den
    if (todayConsumedKwh !== null && todayConsumedKwh !== undefined) {
        updateElementIfChanged('planned-today-consumed-kwh', `${todayConsumedKwh.toFixed(1)} kWh`, 'planned-today-consumed');
    } else {
        updateElementIfChanged('planned-today-consumed-kwh', '--', 'planned-today-consumed');
    }

    if (todayPlannedKwh !== null && todayPlannedKwh !== undefined) {
        updateElementIfChanged('planned-today-remaining-kwh', `${todayPlannedKwh.toFixed(1)} kWh`, 'planned-today-remaining');
    } else {
        updateElementIfChanged('planned-today-remaining-kwh', '--', 'planned-today-remaining');
    }

    if (tomorrowKwh !== null && tomorrowKwh !== undefined) {
        updateElementIfChanged('planned-tomorrow-kwh', `${tomorrowKwh.toFixed(1)} kWh`, 'planned-tomorrow-kwh');
    } else {
        updateElementIfChanged('planned-tomorrow-kwh', '--', 'planned-tomorrow-kwh');
    }

    // Profil display - bez emoji, ÄistÃ½ text (nahoru mÃ­sto "ZbÃ½vÃ¡ dnes + celÃ½ zÃ­tÅ™ek")
    let profileDisplay = '';
    if (profileToday && profileToday !== 'Å½Ã¡dnÃ½ profil' && profileToday !== 'NeznÃ¡mÃ½ profil') {
        // ZkrÃ¡tit dlouhÃ© nÃ¡zvy profilÅ¯
        const shortProfile = profileToday.length > 55 ? profileToday.substring(0, 52) + '...' : profileToday;
        profileDisplay = shortProfile;
    } else {
        profileDisplay = 'Å½Ã¡dnÃ½ profil';
    }
    updateElementIfChanged('consumption-profile-display', profileDisplay, 'profile-display');

    // Update gradient bar (mÃ­sto canvas grafu)
    const barToday = document.getElementById('planned-consumption-bar-today');
    const barTomorrow = document.getElementById('planned-consumption-bar-tomorrow');
    const labelToday = document.getElementById('planned-bar-today-label');
    const labelTomorrow = document.getElementById('planned-bar-tomorrow-label');

    if (barToday && barTomorrow && todayTotalKwh > 0 && tomorrowKwh !== null && tomorrowKwh !== undefined) {
        const total = todayTotalKwh + tomorrowKwh;
        const todayPercent = (todayTotalKwh / total) * 100;
        const tomorrowPercent = (tomorrowKwh / total) * 100;

        barToday.style.width = `${todayPercent}%`;
        barTomorrow.style.width = `${tomorrowPercent}%`;

        if (labelToday) labelToday.textContent = `${todayTotalKwh.toFixed(1)}`;
        if (labelTomorrow) labelTomorrow.textContent = `${tomorrowKwh.toFixed(1)}`;
    }
}

/**
 * Update what-if analysis statistics on Pricing tab
 * Reads mode_optimization.alternatives from battery_forecast attributes
 */
async function updateWhatIfAnalysis() {
    const hass = getHass();
    if (!hass) return;

    const forecastSensorId = `sensor.oig_${INVERTER_SN}_battery_forecast`;
    const forecastSensor = hass.states[forecastSensorId];

    // Check if sensor is available
    if (!forecastSensor || forecastSensor.state === 'unavailable' || forecastSensor.state === 'unknown') {
        console.log('[What-if] Battery forecast sensor not available');
        updateElementIfChanged('whatif-optimized-cost', '--', 'whatif-main');
        updateElementIfChanged('whatif-savings-main', '--', 'whatif-savings');
        updateElementIfChanged('whatif-home-i-delta', '--', 'whatif-home-i');
        updateElementIfChanged('whatif-home-ii-delta', '--', 'whatif-home-ii');
        updateElementIfChanged('whatif-home-iii-delta', '--', 'whatif-home-iii');
        updateElementIfChanged('whatif-home-ups-delta', '--', 'whatif-home-ups');
        return;
    }

    // Get mode_optimization data (still in attributes)
    const attrs = forecastSensor.attributes || {};
    const modeOptData = attrs.mode_optimization || {};
    const alternatives = modeOptData.alternatives || {};

    console.log('[What-if Tile] modeOptData:', modeOptData);
    console.log('[What-if Tile] alternatives:', alternatives);

    // Phase 2.8: Use cached totals from mode_optimization instead of summing blocks
    // (mode_recommendations are per-interval, mode_optimization has pre-calculated totals for DNES+ZÃTRA)
    const totalCost = modeOptData.total_cost_czk || 0;
    const totalSavings = modeOptData.total_savings_vs_home_i_czk || 0;

    console.log('[What-if Tile] totalCost:', totalCost, 'totalSavings:', totalSavings);

    // Update optimized cost and savings
    updateElementIfChanged('whatif-optimized-cost', `${totalCost.toFixed(2)} KÄ`, 'whatif-main');

    if (totalSavings > 0) {
        updateElementIfChanged('whatif-savings-main', `+${totalSavings.toFixed(2)} KÄ`, 'whatif-savings');
    } else if (totalSavings < 0) {
        updateElementIfChanged('whatif-savings-main', `${totalSavings.toFixed(2)} KÄ`, 'whatif-savings');
    } else {
        updateElementIfChanged('whatif-savings-main', '0 KÄ', 'whatif-savings');
    }

    // Update what-if alternatives comparison - 4 modes only
    // Backend format: alternatives = { "HOME I": {...}, "HOME II": {...}, ... }
    const homeI = alternatives['HOME I'];
    const homeII = alternatives['HOME II'];
    const homeIII = alternatives['HOME III'];
    const homeUps = alternatives['HOME UPS'] || alternatives['FULL HOME UPS'];
    const doNothing = alternatives['DO NOTHING'];

    // Format deltas (delta_czk from backend - positive means alternative is more expensive)
    const formatDelta = (alt) => {
        if (!alt || alt.delta_czk === undefined) return '--';
        const delta = alt.delta_czk;
        if (delta > 0.01) {
            return `+${delta.toFixed(2)} KÄ`;
        } else if (delta < -0.01) {
            return `${delta.toFixed(2)} KÄ`;
        } else {
            return '~0 KÄ';
        }
    };

    // Update values
    updateElementIfChanged('whatif-home-i-delta', formatDelta(homeI), 'whatif-home-i');
    updateElementIfChanged('whatif-home-ii-delta', formatDelta(homeII), 'whatif-home-ii');
    updateElementIfChanged('whatif-home-iii-delta', formatDelta(homeIII), 'whatif-home-iii');
    updateElementIfChanged('whatif-home-ups-delta', formatDelta(homeUps), 'whatif-home-ups');

    // Highlight active mode (DO NOTHING = current mode)
    // Reset all rows first
    const rows = ['whatif-home-i-row', 'whatif-home-ii-row', 'whatif-home-iii-row', 'whatif-home-ups-row'];
    rows.forEach(rowId => {
        const row = document.getElementById(rowId);
        if (row) {
            row.style.background = 'transparent';
            row.style.border = 'none';
        }
    });

    // Highlight the active one (if DO NOTHING exists, check which mode it represents)
    if (doNothing && doNothing.current_mode) {
        // Backend provides current_mode field in DO NOTHING
        const activeMode = doNothing.current_mode;
        let activeRowId = null;

        if (activeMode === 'HOME I') {
            activeRowId = 'whatif-home-i-row';
        } else if (activeMode === 'HOME II') {
            activeRowId = 'whatif-home-ii-row';
        } else if (activeMode === 'HOME III') {
            activeRowId = 'whatif-home-iii-row';
        } else if (activeMode === 'HOME UPS') {
            activeRowId = 'whatif-home-ups-row';
        }

        if (activeRowId) {
            const activeRow = document.getElementById(activeRowId);
            if (activeRow) {
                activeRow.style.background = 'rgba(76, 175, 80, 0.15)';
                activeRow.style.border = '1px solid rgba(76, 175, 80, 0.3)';
            }
        }
    }
}


/**
 * Update mode recommendations timeline on Pricing tab
 * Reads mode_recommendations from battery_forecast attributes
 */
async function updateModeRecommendations() {
    const hass = getHass();
    if (!hass) return;

    const forecastSensorId = `sensor.oig_${INVERTER_SN}_battery_forecast`;
    const forecastSensor = hass.states[forecastSensorId];

    const container = document.getElementById('mode-recommendations-timeline');
    if (!container) return;

    // Check if sensor is available
    if (!forecastSensor || forecastSensor.state === 'unavailable' || forecastSensor.state === 'unknown') {
        console.log('[Mode Recommendations] Battery forecast sensor not available');
        container.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary);">ÄŒekÃ¡m na data...</div>';
        return;
    }

    // Get mode_recommendations data
    const attrs = forecastSensor.attributes || {};
    const recommendations = attrs.mode_recommendations || [];

    if (!recommendations || recommendations.length === 0) {
        container.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary);">Å½Ã¡dnÃ¡ doporuÄenÃ­ k dispozici</div>';
        return;
    }

    // Build timeline HTML
    const modeIcons = {
        'HOME I': 'ğŸ ',
        'HOME II': 'ğŸ¡',
        'HOME III': 'ğŸ˜ï¸',
        'HOME UPS': 'âš¡'
    };

    const modeColors = {
        'HOME I': '#4CAF50',
        'HOME II': '#2196F3',
        'HOME III': '#FF9800',
        'HOME UPS': '#9C27B0'
    };

    let html = '<div style="display: flex; flex-direction: column; gap: 10px;">';

    recommendations.forEach((rec, index) => {
        const icon = modeIcons[rec.mode_name] || 'ğŸ“';
        const color = modeColors[rec.mode_name] || '#757575';
        const fromTime = rec.from_time ? new Date(rec.from_time).toLocaleTimeString('cs-CZ', {hour: '2-digit', minute: '2-digit'}) : '--';
        const toTime = rec.to_time ? new Date(rec.to_time).toLocaleTimeString('cs-CZ', {hour: '2-digit', minute: '2-digit'}) : '--';
        const duration = rec.duration_hours || 0;

        html += `
            <div style="display: flex; align-items: center; padding: 8px 12px; background: rgba(255,255,255,0.02); border-left: 3px solid ${color}; border-radius: 4px;">
                <div style="font-size: 1.5em; margin-right: 10px;">${icon}</div>
                <div style="flex: 1;">
                    <div style="font-weight: 600; color: ${color};">${rec.mode_name}</div>
                    <div style="font-size: 0.85em; color: var(--text-secondary);">${fromTime} - ${toTime} (${duration.toFixed(1)}h)</div>
                </div>
                <div style="text-align: right; font-size: 0.85em; color: var(--text-secondary);">
                    ${rec.intervals_count || 0} intervalÅ¯
                </div>
            </div>
        `;
    });

    html += '</div>';

    container.innerHTML = html;
}

// === ANALYTICS (moved to dashboard-analytics.js) ===
const initPerformanceChart = window.DashboardAnalytics.initPerformanceChart;
const updatePerformanceChart = window.DashboardAnalytics.updatePerformanceChart;
const buildYesterdayAnalysis = window.DashboardAnalytics.buildYesterdayAnalysis;
const renderYesterdayAnalysis = window.DashboardAnalytics.renderYesterdayAnalysis;
