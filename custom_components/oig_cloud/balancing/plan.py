"""Balancing Plan Structure - unified format for balancing plans.

TODO 2: Define balancing plan structure per refactoring requirements.
"""

from __future__ import annotations

from dataclasses import dataclass, field, asdict
from datetime import datetime
from typing import Dict, List, Optional
from enum import Enum
import json


class BalancingMode(str, Enum):
    """Balancing plan mode."""

    NATURAL = "natural"  # 100% reached naturally via HYBRID
    OPPORTUNISTIC = "opportunistic"  # Planned charging to reach 100% (5-6 days)
    FORCED = "forced"  # Emergency charging to 100% (7+ days)


class BalancingPriority(str, Enum):
    """Balancing plan priority."""

    NORMAL = "normal"  # Natural or opportunistic
    HIGH = "high"  # Opportunistic nearing deadline
    CRITICAL = "critical"  # Forced balancing


@dataclass
class BalancingInterval:
    """Single interval with explicit mode in balancing plan.

    This is applied to HYBRID timeline to override automatic mode selection.
    Typically used to insert HOME_UPS intervals for charging to 100%.
    """

    ts: str  # ISO datetime
    mode: int  # CBB mode: 0=HOME_I, 1=HOME_II, 2=HOME_III, 3=HOME_UPS

    def to_dict(self) -> Dict:
        """Convert to dict."""
        return asdict(self)

    @classmethod
    def from_dict(cls, data: Dict) -> BalancingInterval:
        """Create from dict."""
        return cls(ts=data["ts"], mode=data["mode"])


@dataclass
class BalancingPlan:
    """Unified balancing plan format per TODO 2.

    This structure is:
    - Generated by balancing logic (balancing_manager.py)
    - Read by forecast during HYBRID calculation
    - Displayed in HA sensor attributes

    The plan defines which CBB modes to use in specific time intervals
    to achieve battery balancing (100% SoC for 3 hours every 7 days).
    """

    # Plan metadata
    mode: BalancingMode  # natural | opportunistic | forced
    created_at: str  # ISO datetime when plan was created
    reason: str  # Human-readable explanation

    # Holding window (3h @ 100%)
    holding_start: str  # ISO datetime when 100% should be reached
    holding_end: str  # ISO datetime when 100% holding ends (start + 3h)

    # Mode override intervals (typically UPS charging before holding)
    intervals: List[BalancingInterval] = field(default_factory=list)

    # Plan status
    locked: bool = False  # True for forced balancing (cannot be overridden)
    priority: BalancingPriority = BalancingPriority.NORMAL
    active: bool = True  # False if plan is cancelled/superseded

    # Tracking
    last_balancing_ts: Optional[str] = None  # ISO datetime of last successful balancing

    def to_dict(self) -> Dict:
        """Convert to dict for JSON serialization."""
        return {
            "mode": self.mode.value,
            "created_at": self.created_at,
            "reason": self.reason,
            "holding_start": self.holding_start,
            "holding_end": self.holding_end,
            "intervals": [i.to_dict() for i in self.intervals],
            "locked": self.locked,
            "priority": self.priority.value,
            "active": self.active,
            "last_balancing_ts": self.last_balancing_ts,
        }

    def to_json(self) -> str:
        """Serialize to JSON string."""
        return json.dumps(self.to_dict(), indent=2)

    @classmethod
    def from_dict(cls, data: Dict) -> BalancingPlan:
        """Create from dict."""
        return cls(
            mode=BalancingMode(data["mode"]),
            created_at=data["created_at"],
            reason=data["reason"],
            holding_start=data["holding_start"],
            holding_end=data["holding_end"],
            intervals=[
                BalancingInterval.from_dict(i) for i in data.get("intervals", [])
            ],
            locked=data.get("locked", False),
            priority=BalancingPriority(data.get("priority", "normal")),
            active=data.get("active", True),
            last_balancing_ts=data.get("last_balancing_ts"),
        )

    @classmethod
    def from_json(cls, json_str: str) -> BalancingPlan:
        """Deserialize from JSON string."""
        return cls.from_dict(json.loads(json_str))


def create_natural_plan(
    holding_start: datetime, holding_end: datetime, last_balancing_ts: datetime
) -> BalancingPlan:
    """Create natural balancing plan (no intervention needed).

    Args:
        holding_start: When 100% will be reached naturally
        holding_end: When 100% holding ends (start + 3h)
        last_balancing_ts: Timestamp to record successful balancing

    Returns:
        BalancingPlan with mode=natural, no override intervals
    """
    return BalancingPlan(
        mode=BalancingMode.NATURAL,
        created_at=datetime.now().isoformat(),
        reason="100% SoC reached naturally via HYBRID forecast",
        holding_start=holding_start.isoformat(),
        holding_end=holding_end.isoformat(),
        intervals=[],  # No overrides needed
        locked=False,
        priority=BalancingPriority.NORMAL,
        active=True,
        last_balancing_ts=last_balancing_ts.isoformat(),
    )


def create_opportunistic_plan(
    holding_start: datetime,
    holding_end: datetime,
    charging_intervals: List[BalancingInterval],
    days_since_last: int,
) -> BalancingPlan:
    """Create opportunistic balancing plan (proactive charging).

    Args:
        holding_start: When 100% should be reached
        holding_end: When 100% holding ends (start + 3h)
        charging_intervals: UPS intervals to charge before holding
        days_since_last: Days since last balancing (typically 5-6)

    Returns:
        BalancingPlan with mode=opportunistic, UPS override intervals
    """
    return BalancingPlan(
        mode=BalancingMode.OPPORTUNISTIC,
        created_at=datetime.now().isoformat(),
        reason=f"Proactive balancing after {days_since_last} days, using cheap hours",
        holding_start=holding_start.isoformat(),
        holding_end=holding_end.isoformat(),
        intervals=charging_intervals,
        locked=False,
        priority=(
            BalancingPriority.HIGH if days_since_last >= 6 else BalancingPriority.NORMAL
        ),
        active=True,
    )


def create_forced_plan(
    holding_start: datetime,
    holding_end: datetime,
    charging_intervals: List[BalancingInterval],
) -> BalancingPlan:
    """Create forced balancing plan (emergency, 7+ days).

    Args:
        holding_start: When 100% MUST be reached
        holding_end: When 100% holding ends (start + 3h)
        charging_intervals: UPS intervals to charge ASAP

    Returns:
        BalancingPlan with mode=forced, locked=True, priority=critical
    """
    return BalancingPlan(
        mode=BalancingMode.FORCED,
        created_at=datetime.now().isoformat(),
        reason="CRITICAL: 7+ days since last balancing, health priority over cost",
        holding_start=holding_start.isoformat(),
        holding_end=holding_end.isoformat(),
        intervals=charging_intervals,
        locked=True,  # Cannot be overridden
        priority=BalancingPriority.CRITICAL,
        active=True,
    )
